<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring注入bean的方式总结]]></title>
    <url>%2F2020%2F11%2F17%2FSpring%E6%B3%A8%E5%85%A5bean%E7%9A%84%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[本篇文章是基于作者的理解，总结一下关于Spring注入bean的所有方式。 准备工作为了演示所有注入方式，我们先做一些准备工作，供之后的测试顺利进行！ 导入Jar包/添加Maven依赖我们要使用Spring框架则需要导入必备的jar包。 spring-context spring-beans spring-core spring-expression commons-logging 除此之外，我们还需要进行测试代码，所以我们继续导入junit的jar包。作者的maven配置如下。123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;SpringDay01&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;5.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 编写需要的类作者这里构造了几个类，供我们进行测试 爱好类 有三个字段 分别为爱好的名字 爱好的分类 爱好的描述 1234567891011121314151617181920212223242526272829303132333435363738public class Hobby &#123; private String name; private String classify; private String describe; public Hobby() &#123; &#125; public Hobby(String name, String classify, String describe) &#123; this.name = name; this.classify = classify; this.describe = describe; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getClassify() &#123; return classify; &#125; public void setClassify(String classify) &#123; this.classify = classify; &#125; public String getDescribe() &#123; return describe; &#125; public void setDescribe(String describe) &#123; this.describe = describe; &#125; @Override public String toString() &#123; return "Hobby&#123;" + "name='" + name + '\'' + ", classify='" + classify + '\'' + ", describe='" + describe + '\'' + '&#125;'; &#125;&#125; 教师类 有三个字段 分别为教师的名字、年龄、以及性别 1234567891011121314151617181920212223242526272829303132333435363738public class Teacher &#123; private String name; private Integer age; private String sex; public Teacher() &#123; &#125; public Teacher(String name, Integer age, String sex) &#123; this.name = name; this.age = age; this.sex = sex; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; @Override public String toString() &#123; return "Teacher&#123;" + "name='" + name + '\'' + ", age=" + age + ", sex='" + sex + '\'' + '&#125;'; &#125;&#125; 学生类 包含了许多字段 为了测试bean的注入 name属性 为String类型 age属性 为Integer类型 Teacher属性 为自定义的类型 courses 为数组类型 friend 为集合容器中的List类型 hobbies 为集合容器中的Set类型 score 为集合容器中的Map类型 config 为Properties类型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import java.util.*;public class Student &#123; private String name; // String类型 private Integer age; // Integer类型 private Teacher teacher; // 自定义数据类型 private String[] courses; // 数组类型 private List&lt;Student&gt; friend; // 集合容器List private Set&lt;Hobby&gt; hobbies; // 集合容器Set private Map&lt;String, Integer&gt; score; // 集合容器Map private Properties config; // Properties类型 public Student() &#123; &#125; public Student(String name, Integer age, Teacher teacher, String[] courses, List&lt;Student&gt; friend, Set&lt;Hobby&gt; hobbies, Map&lt;String, Integer&gt; score, Properties config) &#123; this.name = name; this.age = age; this.teacher = teacher; this.courses = courses; this.friend = friend; this.hobbies = hobbies; this.score = score; this.config = config; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Teacher getTeacher() &#123; return teacher; &#125; public void setTeacher(Teacher teacher) &#123; this.teacher = teacher; &#125; public String[] getCourses() &#123; return courses; &#125; public void setCourses(String[] courses) &#123; this.courses = courses; &#125; public List&lt;Student&gt; getFriend() &#123; return friend; &#125; public void setFriend(List&lt;Student&gt; friend) &#123; this.friend = friend; &#125; public Set&lt;Hobby&gt; getHobbies() &#123; return hobbies; &#125; public void setHobbies(Set&lt;Hobby&gt; hobbies) &#123; this.hobbies = hobbies; &#125; public Map&lt;String, Integer&gt; getScore() &#123; return score; &#125; public void setScore(Map&lt;String, Integer&gt; score) &#123; this.score = score; &#125; public Properties getConfig() &#123; return config; &#125; public void setConfig(Properties config) &#123; this.config = config; &#125; @Override public String toString() &#123; return "Student&#123;" + "name='" + name + '\'' + ", age=" + age + ", teacher=" + teacher + ", courses=" + Arrays.toString(courses) + ", friend=" + friend + ", hobbies=" + hobbies + ", score=" + score + ", config=" + config + '&#125;'; &#125;&#125; 基于XML配置文件注入bean首先我们需要有一份spring关于xml配置的模板，这里作者贴一下。12345&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;&lt;/beans&gt; 使用property进行属性赋值property标签有三个key-value对可供赋值 name property是利用类的setter方法进行属性赋值的，所以name属性填写的值为set方法首字母小写之后的剩余部分。 value 对于基本数据类型及其包装类，String类型，可以直接给value填写相关值，spring会帮我们自动做类型转换。 ref 表示引用当前组件，我们在之后进行演示这种操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;bean id="hobby1" class="cn.hangcc.bean.Hobby"&gt; &lt;property name="name" value="踢足球"/&gt; &lt;property name="classify" value="体育"/&gt; &lt;property name="describe" value="球类运动,强身健体"/&gt; &lt;/bean&gt; &lt;bean id="hobby2" class="cn.hangcc.bean.Hobby"&gt; &lt;property name="name" value="打篮球"/&gt; &lt;property name="classify" value="体育"/&gt; &lt;property name="describe" value="球类运动，强身健体"/&gt; &lt;/bean&gt; &lt;bean id="hobby3" class="cn.hangcc.bean.Hobby"&gt; &lt;property name="name" value="读书"/&gt; &lt;property name="classify" value="学习"/&gt; &lt;property name="describe" value="阅读文学,开阔视野"/&gt; &lt;/bean&gt; &lt;bean id="teacher1" class="cn.hangcc.bean.Teacher"&gt; &lt;property name="name" value="张老师"/&gt; &lt;property name="sex" value="男"/&gt; &lt;property name="age" value="32"/&gt; &lt;/bean&gt; &lt;bean id="teacher2" class="cn.hangcc.bean.Teacher"&gt; &lt;property name="name" value="李老师"/&gt; &lt;property name="sex" value="女"/&gt; &lt;property name="age" value="28"/&gt; &lt;/bean&gt; &lt;bean id="student" class="cn.hangcc.bean.Student"&gt; &lt;!--String类型 可以直接给value赋字符串值--&gt; &lt;property name="name" value="张三"/&gt; &lt;!--基本数据类型的包装类 可以直接给value赋值 spring会帮我们做类型转化--&gt; &lt;property name="age" value="18"/&gt; &lt;!--这里是自定义的类类型 所以无法直接使用value进行赋值，我们有两种方法进行赋值 第一种就是在当前的bean内部,创建一个Teacher对象来对当前bean进行赋值 --&gt;&lt;!-- &lt;property name="teacher"&gt;--&gt;&lt;!-- &lt;bean class="cn.hangcc.bean.Teacher"&gt;--&gt;&lt;!-- &lt;property name="name" value="陈老师"/&gt;--&gt;&lt;!-- &lt;property name="age" value="23"/&gt;--&gt;&lt;!-- &lt;property name="sex" value="男"/&gt;--&gt;&lt;!-- &lt;/bean&gt;--&gt;&lt;!-- &lt;/property&gt;--&gt; &lt;!--第二种办法就是使用ref 引用当前ioc容器已有的组件进行赋值,其中ref填写的值为唯一标识id--&gt; &lt;property name="teacher" ref="teacher1" /&gt; &lt;!--对于数组类型，那么显然也是无法直接用value来直接赋值的 所有我们需要在property标签内部使用list或者array标签进行赋值 然后因为作者这里定义的是String数组 所以在array标签内部使用value直接进行赋值 如果是自定义的类型数组， 则可以使用ref或者bean进行赋值 写多少个bean或者ref就代表多少个数组元素 --&gt; &lt;property name="courses"&gt; &lt;array&gt; &lt;value&gt;123&lt;/value&gt; &lt;value&gt;234&lt;/value&gt; &lt;value&gt;345&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--对于集合容器中的List类型，那么显然也是无法直接用value来直接赋值的 所有我们需要在property标签内部使用list标签进行赋值 然后因为作者这里定义的是Student类型的List, 可以使用ref或者bean进行赋值 写多少个bean或者ref就代表多少个数组元素 --&gt; &lt;property name="friend"&gt; &lt;list&gt; &lt;bean class="cn.hangcc.bean.Student"&gt; &lt;property name="name" value="Hang_c"/&gt; &lt;property name="age" value="18"/&gt; &lt;/bean&gt; &lt;bean class="cn.hangcc.bean.Student"&gt; &lt;property name="name" value="Jay_chou"/&gt; &lt;property name="age" value="30"/&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--对于集合容器Set 肯定也无法使用value进行直接赋值 与List类似 可在其标签内部使用标签进行赋值 作者这里是自定义的类Hobby 所以可以在标签内部使用bean或者ref进行初始化 这里还会将我们的对象进行去重 保证set的正确性 --&gt; &lt;property name="hobbies"&gt; &lt;set&gt; &lt;bean class="cn.hangcc.bean.Hobby"&gt; &lt;property name="name" value="书画"/&gt; &lt;property name="classify" value="文学素养"/&gt; &lt;property name="describe" value="陶冶情操"/&gt; &lt;/bean&gt; &lt;ref bean="hobby1"/&gt; &lt;ref bean="hobby2"/&gt; &lt;ref bean="hobby1"/&gt; &lt;/set&gt; &lt;/property&gt; &lt;!--对于集合容器Map 也是类似 可以在标签内部注册相关的key-value键值对 因为作者这里定义的都是可以直接初始化的类型即String和Integer所以可以直接利用字符串进行赋值 如果是复杂对象 则可以利用key-ref value-ref等进行赋值 --&gt; &lt;property name="score"&gt; &lt;map&gt; &lt;entry key="数学" value="110"/&gt; &lt;entry key="语文"&gt; &lt;value&gt;80&lt;/value&gt; &lt;/entry&gt; &lt;entry key="英语" value="20"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--最后就是Properties对象了 也是类似的 不过其键值都为字符串 比较简单 --&gt; &lt;property name="config"&gt; &lt;props&gt; &lt;prop key="userName"&gt;Hang_ccccc&lt;/prop&gt; &lt;prop key="password"&gt;123456&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 总结起来就是基本数据类型、基本数据类型的包装类型、String类型可以直接通过value进行赋值。如果是集合容器、数组、配置类等这样的属性，可以通过相应的标签内部进行赋值，其中基础数据类型之类的还是可以直接用value标签赋值，而自定义的类可以使用bean或者ref进行赋值。 通过构造函数进行赋值与上述的方法类似，只是上述方法是根据类的setter方法进行注入的，而我们即将要讨论得方式使用过构造函数进行注入。 我们可以通过constructor-arg标签 来根据构造函数对属性值进行注入。 其中constructor-arg标签 有5个属性可供赋值 name 表示构造函数的形参名字 value 如果是简单的数据类型 可以直接给value赋值进行注入 ref 对当前参数进行引用赋值 type 因为构造函数可能会重载 该参数用来指定当前类型 index 同上 因为构造参数可能会重载 所以该参数用来指定当前参数的下标 下标从0开始 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="teacher" class="cn.hangcc.bean.Teacher"&gt; &lt;property name="name" value="张老师"/&gt; &lt;property name="age" value="33"/&gt; &lt;property name="sex" value="男"/&gt; &lt;/bean&gt; &lt;bean id="student" class="cn.hangcc.bean.Student"&gt; &lt;!--因为name是String类型 所以可以直接对value进行赋值--&gt; &lt;constructor-arg name="name" value="李四"/&gt; &lt;!--age是Integer 可以给value合适的值 会自动做类型转化--&gt; &lt;constructor-arg name="age" value="12"/&gt; &lt;!--teacher是自定义的类 所以有两种方式进行注入 方式一 在标签内部创建类 --&gt;&lt;!-- &lt;constructor-arg name="teacher"&gt;--&gt;&lt;!-- &lt;bean class="cn.hangcc.bean.Teacher"&gt;--&gt;&lt;!-- &lt;property name="name" value="钱老师"/&gt;--&gt;&lt;!-- &lt;property name="age" value="43"/&gt;--&gt;&lt;!-- &lt;property name="sex" value="女"/&gt;--&gt;&lt;!-- &lt;/bean&gt;--&gt;&lt;!-- &lt;/constructor-arg&gt;--&gt; &lt;!--方式二 引用IOC容器中已有的类--&gt; &lt;constructor-arg name="teacher" ref="teacher"/&gt; &lt;!--对于数组 与setter方法注入类似--&gt; &lt;constructor-arg name="courses"&gt; &lt;array&gt; &lt;value&gt;abc&lt;/value&gt; &lt;value&gt;bcd&lt;/value&gt; &lt;value&gt;cde&lt;/value&gt; &lt;/array&gt; &lt;/constructor-arg&gt; &lt;!--对于容器List 也是类似--&gt; &lt;constructor-arg name="friend"&gt; &lt;list&gt; &lt;bean class="cn.hangcc.bean.Student"&gt; &lt;property name="name" value="小张"/&gt; &lt;/bean&gt; &lt;bean class="cn.hangcc.bean.Student"&gt; &lt;property name="name" value="小照"/&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;!--类似 也是标签内部进行赋值--&gt; &lt;constructor-arg name="hobbies"&gt; &lt;set&gt; &lt;bean class="cn.hangcc.bean.Hobby"&gt; &lt;property name="name" value="街舞"/&gt; &lt;/bean&gt; &lt;bean class="cn.hangcc.bean.Hobby"&gt; &lt;property name="name" value="滑板"/&gt; &lt;/bean&gt; &lt;/set&gt; &lt;/constructor-arg&gt; &lt;constructor-arg name="score"&gt; &lt;map&gt; &lt;entry key="高数" value="80"/&gt; &lt;entry key="体育" value="20"/&gt; &lt;/map&gt; &lt;/constructor-arg&gt; &lt;constructor-arg name="config"&gt; &lt;props&gt; &lt;prop key="key"&gt;nihao&lt;/prop&gt; &lt;prop key="value"&gt;admin&lt;/prop&gt; &lt;/props&gt; &lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; 总结 与setter方法类似 只是一个是通过set方法进行注入 一个是通过构造器进行注入。重点还是在对于具体的类而言，其注入的方式可能有所不同。 p命名空间和c命名空间因为对于基本数据类型、基本数据类型的包装类型、String类型可以直接通过value赋值。或者较为复杂的类型使用引用IOC容器的组件进行赋值，那么需要重复写很多标签。 所以引入了p命名空间和c命名空间。 p命名空间p就是property的首字母，代表通过属性进行注入的简写形式。使用前 我们需要在beans里面添加xmlns:p=&quot;http://www.springframework.org/schema/p&quot;来引入p命名空间其仅仅可以简化基本数据类型、基本数据类型的包装类、String类以及需要引用IOC容器中以及存在组件。对于自定义的类还需要在bean标签里面通过property标签进行注入;使用语法为: c:字段=value 或者c:字段-ref=”引用的id”进行注入。1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!--对于基本数据类型 可以直接利用p命名空间进行快速的注册--&gt; &lt;bean id="teacher" class="cn.hangcc.bean.Teacher" p:name="姚老师" p:age="18" p:sex="女"/&gt; &lt;!--对于基本数据类型 以及以及在IOC容器存在的组件 可以直接赋值或引用--&gt; &lt;bean id="stu" class="cn.hangcc.bean.Student" p:name="Hang_ccccc" p:age="23" p:teacher-ref="teacher"&gt; &lt;!--其他复杂的类型 还需要利用property标签进行注入--&gt; &lt;property name="score"&gt; &lt;map&gt; &lt;entry key="物理" value="110"/&gt; &lt;entry key="化学" value="98"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--其他复杂的类型 还需要利用property标签进行注入--&gt; &lt;property name="config"&gt; &lt;props&gt; &lt;prop key="userName"&gt;admin&lt;/prop&gt; &lt;prop key="passWord"&gt;root&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; c命名空间其中c 就是constructor的首字母，代表通过构造器进行注入。同样的，我们需要在使用之前 在beans中引入c命名空间。xmlns:c=&quot;http://www.springframework.org/schema/c&quot; 同样的，其只能简化部分基本数据类型及已存在与IOC容器的组件，对于未定义在IOC容器中的类还是需要通过constructor-arg进行指定。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:c="http://www.springframework.org/schema/c" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!--对于简单类型的属性 可以直接通过c命名空间进行注入 简化代码--&gt; &lt;bean id="teacher" class="cn.hangcc.bean.Teacher" c:name="高老师" c:age="35" c:sex="男"/&gt; &lt;!--对于简单类型的属性 也可以通过c命名空间进行注入 但是 未在IOC容器中定义的 还是需要在标签中定义--&gt; &lt;bean id="stu" class="cn.hangcc.bean.Student" c:name="Pony" c:age="22" c:teacher-ref="teacher"&gt; &lt;constructor-arg name="courses"&gt; &lt;array&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;value&gt;4&lt;/value&gt; &lt;/array&gt; &lt;/constructor-arg&gt; &lt;constructor-arg name="friend"&gt; &lt;list&gt; &lt;bean class="cn.hangcc.bean.Student"&gt; &lt;property name="name" value="张三"/&gt; &lt;/bean&gt; &lt;bean class="cn.hangcc.bean.Student"&gt; &lt;property name="name" value="李四"/&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;constructor-arg name="hobbies"&gt; &lt;set&gt; &lt;bean class="cn.hangcc.bean.Hobby"&gt; &lt;property name="name" value="篮球"/&gt; &lt;/bean&gt; &lt;bean class="cn.hangcc.bean.Hobby"&gt; &lt;property name="name" value="拍球"/&gt; &lt;/bean&gt; &lt;/set&gt; &lt;/constructor-arg&gt; &lt;constructor-arg name="config"&gt; &lt;props&gt; &lt;prop key="user"&gt;root&lt;/prop&gt; &lt;prop key="password"&gt;root&lt;/prop&gt; &lt;/props&gt; &lt;/constructor-arg&gt; &lt;constructor-arg name="score"&gt; &lt;map&gt; &lt;entry key="数学" value="98"/&gt; &lt;entry key="语文" value="77"/&gt; &lt;/map&gt; &lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; 如需注入复杂对象且IOC容器内部无组件，则还是需要在标签内部写标签进行注入 util命名空间对于自定义的类以及基本数据类型、基本数据类型的包装类型、String类型 都可以将其注册到IOC容器中，可以进行复用。 即有其他组件需要使用可以直接ref引用而无需重写一遍xml文件。 而对于集合容器而言，并不能将其封装为一个bean进行复用。所以这里引出了util这一内容。其就是用来对集合容器、Properties类型进行封装的标签。 使用前类似的需要在bean中引入，xmlns:util=&quot;http://www.springframework.org/schema/util&quot; 除此之外 还需要再xsi:schemaLocation之后添加http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd 然后就可以进行使用了。其中util后面跟着容器类型 可供选择 map list set properties 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:util="http://www.springframework.org/schema/util" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd"&gt; &lt;bean id="teacher" class="cn.hangcc.bean.Teacher" p:name="刘老师" p:age="31" p:sex="女"/&gt; &lt;util:map id="map"&gt; &lt;entry key="C++" value="99"/&gt; &lt;entry key="Java" value="80"/&gt; &lt;entry key="数据结构" value="88"/&gt; &lt;/util:map&gt; &lt;util:properties id="properties"&gt; &lt;prop key="user"&gt;admin&lt;/prop&gt; &lt;prop key="password"&gt;admin&lt;/prop&gt; &lt;/util:properties&gt; &lt;util:list id="list"&gt; &lt;bean class="cn.hangcc.bean.Student" p:name="周杰伦"/&gt; &lt;bean class="cn.hangcc.bean.Student" p:name="刘德华"/&gt; &lt;/util:list&gt; &lt;util:set id="set"&gt; &lt;bean class="cn.hangcc.bean.Hobby" p:name="唱歌"/&gt; &lt;bean class="cn.hangcc.bean.Hobby" p:name="跳舞"/&gt; &lt;/util:set&gt; &lt;util:list id="arr"&gt; &lt;value&gt;q&lt;/value&gt; &lt;value&gt;w&lt;/value&gt; &lt;value&gt;e&lt;/value&gt; &lt;/util:list&gt; &lt;bean id="stu" class="cn.hangcc.bean.Student" p:name="Hang_ccccc" p:age="21" p:teacher-ref="teacher"&gt; &lt;property name="score" ref="map"/&gt; &lt;property name="config" ref="properties"/&gt; &lt;property name="friend" ref="list"/&gt; &lt;property name="hobbies" ref="set"/&gt; &lt;property name="courses" ref="arr"/&gt; &lt;/bean&gt;&lt;/beans&gt; bean的作用域默认情况下，每一个IOC的组件都是单例的，即多次获取同一ID的组件得到的是同一个对象。在xml文件内部如果组件有引用的话，也是公用同一个对象。我们可以修改配置，可以让每次获取都是不同地对象。 scope可选值: singleton: 即默认的单例 每次获取都是同一个对象.当IOC容器被创建 则该对象也被创建 prototype: 原型模式 每次获取都会新创建对象. 当IOC容器被创建时 不会创建对象 只有被使用时才会创建 工厂方法创建bean类似于设计模式中的工厂模式，就是指给定工程具体的参数，然后工程返回一个组件给到调用者。这里的实现方式有两种，分别是静态工厂模式与实例工厂模式。 静态工厂: 就是指工厂方法是静态的，无需创建对象即可调用工厂方法。 实例工厂: 即方法属于对象而非类，所以调用工厂方法需要创建一个工厂对象，然后根据此工厂对象调用工厂方法。 静态工厂创建bean即写一个静态工厂的类，然后编写生成对象的逻辑，将生成的对象进行返回。1234567891011public class StaticFactory &#123; public static Student getStu(String name, Integer age) &#123; Student student = new Student(); student.setName(name); student.setAge(age); student.setTeacher(new Teacher("刘老师", 12, "男")); student.setCourses(new String[]&#123;"Hello", "World", "I am", "Chen"&#125;); return student; &#125;&#125; 然后在xml配置文件中使用该工厂方法创建bean即可。1&lt;bean id="stuFactory" class="cn.hangcc.bean.StaticFactory" factory-method="getStu" c:name="Hang_c" c:age="32" /&gt; 这里的id就为我们获取组件的标识，class为静态工厂的全路径类名，factory-method指定此静态工厂的获取对象的方法名。如果该方法需要参数，则我们需要通过constructor传递参数，这里我用c命名空间简写了。你也可以这样写.1234&lt;bean id="stuFactory" class="cn.hangcc.bean.StaticFactory" factory-method="getStu"&gt; &lt;constructor-arg name="name" value="Hang_c"/&gt; &lt;constructor-arg name="age" value="25"/&gt; &lt;/bean&gt; 实例工厂创建bean首先，我们还是得写一个该工厂得对象，只是此工厂方法不属于类而是属于对象。12345678910111213141516import java.util.ArrayList;public class InstanceFactory &#123; public Student getStu(String name, Integer age) &#123; Student student = new Student(); student.setName(name); student.setAge(age); ArrayList&lt;Student&gt; arr = new ArrayList&lt;&gt;(); arr.add(new Student("张三", 14, null, null, null, null, null, null)); arr.add(new Student("李四", 15, null, null, null, null, null, null)); arr.add(new Student("王五", 16, null, null, null, null, null, null)); student.setFriend(arr); student.setTeacher(new Teacher("呵呵", 54, "男")); return student; &#125;&#125; 然后我们需要在xml配置文件中使用该实例工厂去创建bean。首先因为是实例工厂创建bean，所以我们先需要在IOC容器中创建一个对象，然后根据此对象调用工厂方法&lt;bean id=&quot;instanceFactory&quot; class=&quot;cn.hangcc.bean.InstanceFactory&quot;/&gt;。然后对于我们创建得bean，需要依赖于此实例进行调用工厂方法。1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:c="http://www.springframework.org/schema/c" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="instanceFactory" class="cn.hangcc.bean.InstanceFactory"/&gt; &lt;bean id="stu" class="cn.hangcc.bean.Student" factory-bean="instanceFactory" factory-method="getStu" c:name="Hello" c:age="43"/&gt; &lt;bean id="stu1" class="cn.hangcc.bean.Student" factory-bean="instanceFactory" factory-method="getStu"&gt; &lt;constructor-arg name="name" value="喜羊羊"/&gt; &lt;constructor-arg name="age" value="1"/&gt; &lt;/bean&gt;&lt;/beans&gt; 这里的id也是我们从IOC容器获取组件得入口。class为我们实际想要创建的全限定类名。 factory-bean用来指定根据哪一个对象调用工厂方法，factory-method用来指定根据对象的哪一个方法构造对象。同样的，如果工厂方法是有参的，则需要根据constructor用来指定参数。这里可以用c命名空间指定，也可以用bean下面的标签constructor-arg指定，效果是一样的，个人感觉c命名空间更加简洁。]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习笔记第一天]]></title>
    <url>%2F2020%2F11%2F10%2FSpring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[Spring框架概述什么是Springspring是一个开源的框架，它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为J2EE应用程序开发提供集成框架。Spring的核心是控制反转(IOC)和面向切面(AOP) 简单来说，Spring是一个分层的JavaSE/EE(一站式)轻量级开源框架。 Spring的优点 方便解耦，简化开发(高内聚、低耦合)Spring就是一个大的容器，可以将所有对象创建和依赖关系维护，交给Spring管理。Spring工厂是用于生成Bean AOP编程的支持Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。 声明式事务的支持只需要通过配置就可以完成对事务的管理，而无需手动编程 方便程序的测试Spring对Junit4支持，可以通过注解方便的测试Spring程序。 方便集成各种优秀框架Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架(如: Struts、Hibernate、MyBatis、Quatz等)的直接支持。 降低JavaEE API的使用难度Spring对JavaEE开发中非常难用的一些API(JDBC、JavaMail、远程调用等)都提供了封装，是这些API应用难度大大降低 Spring的体系结构Spring框架是一个分层架构，它包含了一系列的功能要素并被分为大约20个模块。这些模块分为Core Container、Data Access/Integration、Web、AOP(Aspect Oriented Programming)、Instrumentation和测试部分、如图所示。 我们可以看到spring框架整合了包含 Test： 单元测试模块、需要导包 spring-test Core Container: 核心容器(IOC); 黑色代表这部分的功能有哪些jar包组成。要使用这部分功能就得导入当前模块的全部jar包 spring-beans spring-core spring-context spring-expression AOP + Aspects: 面向切面编程模块，需要导入的包 spring-aop spring-aspects Data Access/Integration: (数据访问/集成) spring-jdbc: 操作数据库 重点 spring-orm：对象关系映射 重点 spring-oxm: 对象与xml关系映射 spring-jms: 消息中间件 spring-tx: 数据库事务相关 重点 Web：Spring开发web应用的模块 spring-websocket: websocket spring-web: 原生web相关 spring-webmvc: 开发web项目的 spring-webmvc-portlet: 开发web的组件 用哪个模块导入那个包。 IOC和AOPIOC(Inversion of control): 控制反转控制资源获取的方式 主动获取：(要什么资源自己创建即可) 1234class Person &#123; House house = new House(); // 主动获取 通过new的方式。 但是如果此对象又包含了很多复杂的属性，则此对象的初始化较为复杂。 Car car = new Car(); // 也是通过new的方式主动获取。&#125; 被动获取: (需要什么资源由容器提供、不需要自己主动获取) 12345class Person &#123; House house; // 不需要自己创建，由容器提供 Car car; // 不需要自己创建，由容器提供&#125; 容器: 管理所有的组件(有功能的类); 容器可以自动的探查出那些组件(类)需要到另一些组件(类)；容器帮我们创建对象、添加依赖关系等 DI(dependency Injection) 依赖注入容器能知道哪个组件(类)运行的时候，需要另外一个类(组件)；容器通过反射的形式，将容器中准备好的对象进行注入(利用反射给属性进行赋值)。 只要容器管理的组件、都能使用容器提供的强大功能。 Spring入门 导包: 测试IOC容器功能，所以需要导入Core Container中的四个jar包，maven直接添加依赖即可。Spring运行的时候还需要依赖于日志包(commons-logging)。 写配置: 需要创建Spring的bean配置文件.xml123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;/beans&gt; 给容器中注册组件(类)在spring的bean配置文件中添加组件123&lt;bean id="" class=""&gt; &lt;/bean&gt; 一个bean标签对应着一个组件class为注册组件的全限定类名id为这个组件的唯一标识 使用property为对象的属性赋值123&lt;bean id="" class="cn.hangcc.bean.Person"&gt; &lt;property name="" value=""/&gt;&lt;/bean&gt; 其中id为通过容器获取组件的唯一标识。class为注册组件的全限定类名。name为setter方法后首字母小写后的剩余部分 setFirstName(String firstName) {this.fisrtName = firstName}; 在配置文件中 name=”firstName”;其他的情况如: set方法首字母小写、set方法无参数等、则配置文件不进行识别。 value为这个setter方法的传入参数 这种方式是根据全限定类名反射的方式创建对象，并根据set方法对应配置文件的property进行属性初始化的。 从容器中获取组件(类)我们可以先获取容器对象进而获取容器中的组件！ApplicationContext这个接口就代表着IOC容器；其常用的实现类有以下两个 FileSystemXmlApplicationContext是根据当前系统的文件路径指定的bean配置文件进行获取容器。 ClassPathXmlApplicationContext是根据类路径的bean配置文件进行获取容器。 我们通常将bean.xml放到资源文件路径下即可，然后使用1ApplicationContext context = new ClassPathXmlApplicationContext("bean.xml"); 进行ioc容器的获取。 获取组件的方法及其重载。 容器创建之后，容器中的所有组件都将被创建 容器中的bean，是同一个组件，多次获取地址相同，单例模式 通过唯一id标识获取对象我们可以通过ApplicationContext接口提供的getBean方法来获取对象。我们直接传入在配置文件中给定的唯一标识id即可获取到Object对象，然后强转为我们已知的对象类型即可。如果给的的id未在容器中注册，会报NoSuchBeanDefinitionException: No bean named &#39;XXXX&#39; available异常1234567public class Demo &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext("bean.xml"); Person person = (Person) context.getBean("person01"); System.out.println(person.toString()); &#125;&#125; 通过bean的类型来获取对象我们可以通过ApplicationContext接口提供的getBean方法来获取对象。我们可以将传入参数改为Class对象，则代表会根据对象的类型进行匹配。当容器中只有一个该类型或该类型的子类的组件时直接返回该组件，否则会抛出异常。 当容器中只有一个该类或者该类的子类时候 直接返回类型匹配的这个组件 1234567public class Demo &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext("bean.xml"); Person bean = context.getBean(Person.class); System.out.println(bean); &#125;&#125; 当容器中没有与该类型匹配的组件时候。NoSuchBeanDefinitionException：No qualifying bean of type &#39;xxxx.xxxx.xxxx.xxxx&#39; available 当容器中匹配的个数大于1时NoUniqueBeanDefinitionException: No qualifying bean of type &#39;xxxx.xxxx.xxxx&#39; available: expected single matching bean but found 3: person01,person02,boy01 获取Class对象的三种方式 根据Class.forName(“全限定类名”); 获取 可以通过类名.class; 获取 可以通过对象的getClass(); 方法进行获取 可以通过指定id与类型唯一确定组件我们可以通过ApplicationContext接口提供的getBean方法来获取对象。第一个参数指定为唯一标识id，第二个参数指定为类的Class对象，即可唯一确定组件，且返回值为Class对象所对应的类。不需要进行强制类型转换了。 1234567public class Demo &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext("bean.xml"); Person per = context.getBean("person01", Person.class); System.out.println(per); &#125;&#125; 当我们指定的id不存在时会抛出NoSuchBeanDefinitionException异常 代表容器中不存在指定id的Bean。当我们指定的类型与容器中不匹配时候，会抛出BeanNotOfRequiredTypeException异常，代表Bean不是我们指定类型。]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis学习笔记第三天]]></title>
    <url>%2F2020%2F11%2F07%2FRedis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%89%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[Redis事务基本概念 Redis事务的本质上就是一组命令的集合。事务支持一次执行多个命令，一个事务中的所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。 总结说,Redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。 Redis中没有隔离级别的概念 批量操作在发送EXEC命令前被放入队列缓存，并不会被实际执行。 Redis的事务不保证原子性，在Redis可以保证单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会依然执行。 Redis事务相关命令 discard 取消事务，放弃执行事务快内的所有命令 exec 执行所有事务块内的命令 multi 标记一个事务块的开始 unwatch 取消watch命令对所有key的监视 watch key [key....] 监视一个(或多个)key,如果在事务执行之前这个(或这些)key被其他命令所改动，那么事务将被打断。 正常执行案例 可以看出，当我们开启了事务之后，只是将我们键入的命令添加到待执行队列并未实际的去执行。当我们键入exec命令之后，在队列中的所有命令全部执行，并返回所执行后的返回值。 放弃事务案例 当我们开启事务之后，添加了相关命令到待执行队列，如果最后键入的命令是discard那么此时是放弃事务，该事务中的所有命令都不会被执行，此时库中的数据与执行事务前的数据一致。 事务中存在语法错误上面演示了命令都是正确情况下的例子，在这一小节我们来看一下，如果当一个事务中，有些命令是存在语法错误的。这种情况下，如果我们选择执行事务，会出现什么情况。 我们可以看到当一个事务中，如果某条命令有语法错误时，那么该事务中的所有的命令都不会被执行！！！ 事务中命令出现运行时错误上面演示了语法错误，导致一个事务中所有的命令都不会被执行。接下来，我们来看一下，当一个事务中某条命令执行错误，那么会咋样影响整个事务。 我们可以看出，当事务中某条命令没有语法错误在运行时发生错误时，仅仅是当前命令报错，而其他命令都不会受到影响！！！ watch当启用了watch监视一个或一些key之后开启事务，键入一些相关命令，当执行事务时，会判断当前监视的key是否发生过写操作，如果发生过则此次事务全部不执行，没发生过则此次事务正常执行。 且亲测不存在ABA问题，所以其应该是通过判断版本号或时间戳之类的机制来实现CAS操作。 演示watch监视key之后，key没被写操作的事务执行情况。 演示watch监视key之后，key被其他客户端进行了写操作后的事务执行情况。 客户端1进行设置money的值，并进行监视，开启事务 客户端2对money的值进行了写操作，但是最终还原为原值。 接着客户端1继续执行。并键入一些命令，代表客户端1的逻辑处理 可以发现，事务执行失败了，全部命令都没有执行，因为有其他客户端对监视的键值进行了写操作。且从这个例子中可以看出，Redis的watch是解决了ABA问题的。 一旦事务执行后，无论事务是否执行成功，watch对键的监视都将取消。所以当事务失败之后，应该重新进行监视相关键，开启新的事务操作! watch类似于乐观锁，基于比较并交换的基础概念。当发现监视中的键值没有被其他客户端进行修改时才可以执行成功，否则该事务执行失败。 Redis消息订阅可以利用Redis做客户端之间的消息订阅: 发送者(pub)发送消息，订阅者(sub)接收消息。 Redis客户端可以订购任意数量的频道这里抄了菜鸟教程的图片及文件。附原帖链接:菜鸟教程-Redis发布订阅 我们可以看到，当有客户端订阅频道后，频道通过pub消息之后，由Redis服务进行消息的分发。 我们可以在Redis客户端键入subcribe channel 或者 键入 psubscribe pattern 前者为指定订阅名而后者为通配符，符合通配符的都将被订阅。 然后其他Redis客户端可以键入命令 publish channel message向订阅当前频道的客户端发送消息！ PSUBSCRIBE pattern [pattern …] 订阅一个或多个符合给定模式的频道。 PUBSUB subcommand [argument [argument …]] 查看订阅与发布系统状态。 PUBLISH channel message 将信息发送到指定的频道。 PUNSUBSCRIBE [pattern [pattern …]] 退订所有给定模式的频道。 SUBSCRIBE channel [channel …] 订阅给定的一个或多个频道的信息。 UNSUBSCRIBE [channel [channel …]] 只退订给定的频道。 Redis主从复制基本概念虽然Redis的读写速度都非常快，但是当并发量非常大的时候，单机服务就没有办法承载了。为了分担压力，Redis支持主从复制，Redis的主从结构可以采用一主多从或级联结构，Redis主从复制可以根据是否是全量分为全量同步和增量同步。 Redis主从的结构 全量同步Redis全量复制一般发生在Slave初始化阶段，这事Slave需要将Master上的所有数据都复制一份。具体步骤如下: 从服务器连接到主服务器，发送SYNC命令 主服务器接收到SYNC命令后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令 主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续纪录被执行的写命令 从服务器收到快照文件后丢弃所有旧数据，载入收到的快照 主服务器快照发送完毕后开始向服务器发送缓冲区的写命令 从服务器完成对快照的载入，开始接受命令请求，并执行来自主服务器缓冲区的写命令。 从服务器初始化流程图上面几个步骤就是从服务器数据初始化的所有过程，从服务器此时就可以接受来自用户的读请求。 增量同步Redis的增量复制是指Slave初始化后开始正常工作时， 主服务器发生的写操作同步到从服务器的过程。增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接受并执行收到的写命令。 同步策略主从刚刚连接时，进行初始化即全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave在任何时候都可以发起全量同步。 redis的策略是，无论如何首先会尝试进行增量同步，如不成功则要求从机进行全量同步。 如果多个salve同时短线需要重启的时候，因为只要slave启动，就会发送sync请求和主机全量同步，当多个出现的时候，可能会导致master的IO剧增宕机 相关命令slaveof ip port 将自身Redis服务器设为从服务器，指定主服务器的ip和端口 如果主服务器设置了远程访问且设置了密码，则需要更改从服务器的配置文件或者键入命令config set masterauth password来完成主从]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis学习笔记第二天]]></title>
    <url>%2F2020%2F11%2F06%2FRedis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[Redis配置文件相关INCLUDES 我们知道Redis只有一个配置文件，如果多个人进行开发维护，那么就需要多个这样的配置文件，这时候多个配置文件就可以在此通过 include /path/to/local.conf 配置进来，而原本的 redis.conf 配置文件就作为一个总闸。 另外需要注意的时，如果将此配置写在redis.conf 文件的开头，那么后面的配置会覆盖引入文件的配置，如果想以引入文件的配置为主，那么需要将 include 配置写在 redis.conf 文件的末尾。 NETWORK 1.bind: 绑定redis服务器网卡IP，默认为127.0.0.1，即本地回环地址。 这样的话，访问redis服务只能通过本机的客户端进行访问，而无法通过远程连接。如果bind选项为空的话(即将bind这一行注释)，那会接受所有来自于可用网络接口的连接。 port: 指定redis的运行的端口，默认是6379。由于redis是单线程模型(redis6.0之前)，所以当单机起多个redis服务的话，就需要修改端口。 timeout: 设置客户端连接时的超时时间，单位为秒。当客户端在指定的时间内没有与服务器端进行交互，那么关闭该连接。默认为0，代表不关闭。 tcp-keepalive: 单位为秒，表示将周期性的使用SO_KEEPALIVE检测客户端是否还处于健康状态，避免服务器一直阻塞，官方给出的建议值是300s，如果设置为0则代表不进行检测。 GENERAL 1.daemonize: 设置为yes表示指定Redis以守护进程的方式启动(后台启动)，默认值为no。 2.pidfile: 配置PID文件路径，当Redis作为守护进程运行的时候，它会把pid默认写到/var/run/redis_6379.pid文件里面 loglevel: 定义日志级别。默认值为notice，有如下4种取值。 debug （纪录大量日志信息，适用于并发、测试阶段） verbose (较多日志信息) notice (适量日志信息，适用于生产环境) warning (仅有部分重要、关键信息才会被纪录) logfile: 配置log文件地址，默认打印在命令行终端的窗口上 databases: 设置数据库的数目。默认的数据库是DB 0, 可以在每个连接上使用 select 命令选择一个不同的数据库，dbid是一个介于0到databases-1之间的数值。默认值是16，也就是说默认Redis有16个库。 CLIENTS 1.maxclients: 设置客户端最大并发连接数，默认无限制。Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数-32(redis server自身会使用一些)。如果设置maxclients为0，表示不做限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息。 MEMORY MANAGEMENT 1.maxmemory: 设置Redis的最大内存，如果设置为0。表示不做限制，通常是配合下面介绍的maxmemory-policy参数一起使用。 2.maxmemory-policy: 当内存使用达到maxmemory设置的最大值时，redis使用的内存清除策略。有以下几种可以选择: 1) volatile-lru: 利用LRU算法移除设置过 过期时间的key(LRU:最近使用 Least Recently Used) 2) allkeys-lru: 利用LRU算法移除任何key 3) volatile-random: 移除设置过 过期时间的随机key 4) allkeys-random 移除随机key 5) volatile-ttl 移除即将过期的key (minor TTL) 6) noeviction 不移除任何一个key，只是返回一个写错误，默认为此选项 maxmemory-samples: LRU 和 minimal TTL 算法都不是精准的算法，但是相对精准的算法(为了节省内存)。redis默认选择3个样本进行检测，你可以通过maxmemory-samples进行设置样本数。 Redis持久化众所周知，Redis是基于内存的非关系型数据库。即断电即失，那么出现意外情况如何保证数据的安全性呢？我们可以将内存的数据持久化到硬盘上面，因为硬盘断电之后并不会丢失数据。Redis种，有两种持久化的方式，分别是RDB(Redis DataBase)和AOF(Append Only File) RDB (Redis DataBase)RDB其实就是将数据以快照的形式持久化到硬盘。你可以理解为将当前时刻的数据拍成一张照片保存下来。 RDB机制是通过把某个时刻的所有数据生成一个快照来保存，那么就应该有相关的触发方式。对于RDB来说，提供了三种机制来触发持久化: save, bgsave, 自动化。 基本概念在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是专业术语Snapshot快照，它恢复时是将快照文件直接读到内存里。 Redis会单独创建(fork)一个子进程来进行持久化，回先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失 fork学习过Linux系统编程的哥哥们应该知道这玩意，Fork的作用就是复制一个与当前进程一样的进程。 新进程的所有数据(变量、环境变量、程序计数器等)都与原进程一致，但是是一个全新的进程，而非原进程的子进程。 dump.rdb文件即通过RDB方式持久化硬盘生成的二进制文件，当redis服务器端启动时，会从该文件中读取数据加载到内存。 save触发方式当redis客户端键入命令save后，可直接阻塞当前redis服务器，让redis服务器进行数据的持久化。在此期间redis服务器不能处理其他客户端的请求，知道持久化到硬盘的动作完成才可以继续处理客户端的请求。 这种方式会阻塞其他客户端，当我们部署到生产环境的时候，这种方法显然会带来大量用户的卡顿，不建议使用。 bgsave触发方式当redis客户端执行该条命令，Redis服务器端会在后台完成持久化操作。即会通过fork函数生成一个新的进程完成数据的持久化操作，不会阻塞原进程的服务。即其他客户端可以继续请求该Redis服务。 该方式会在fork时候由于需要基于内存拷贝数据，会有短暂的拒绝服务时间，且需要再生成一份快照到内存中(现在机器应该不会在乎这点内存。 自动化触发# save &lt;seconds&gt; &lt;changes&gt;我们可以配置配置文件，当在seconds秒后 有指定条key发生改变则会持久化到硬盘上面。默认有如下三条纪录123save 900 1save 300 10save 60 10000 代表着当60秒后，若key改变的数目大于10000则直接持久化到硬盘，当300秒后有10条key发生改变则持久化硬盘。 我们可以发现，随着时间的变成 改变key的要求也越来越低，这符合我们实际的业务需求，因为当高平发的情况下，肯定在短时间内有大量的change操作。所以我们需要持久化。 当Redis服务处于空闲时 就没必要高频率的去进行持久化操作了。 取消自动化持久化操作。我们可以将所有的save指令注释，或者 save “” 。 或可以客户端执行指令 config set save &quot;&quot;来关闭Redis的持久化。 flushall当将Redis的全部数据库进行清除时，也会立即生成一份dump.rdb文件.此时dump文件为空，没意义。 其他参数 stop-writes-on-bgsave-error : 默认值为yes 其代表当启用了RDB且最后一次后台保存数据失败，Redis是否停止接受数据。这会让用户意识到数据没有正确的持久化到硬盘上，否则没有人会注意到灾难发生了。 rdbcompression：默认值是 yes。 对于存储到磁盘的快照，可以设置是否进行压缩存储。 进行压缩存储会节省硬盘空间，但同时会占用少量的cpu资源。鱼和熊掌 根据业务抉择 rdbchecksum: 默认值是yes。 在存储快照之后，我们还可以让Redis使用CRC64算法来进行数据的校验。但是这样做会增加大约10%的性能消耗。如果希望获取最大的性能提升 可以关闭此功能。 dbfilename：设置到处快照的名字 默认dump.rdb dir: 设置快照文件的存储位置。 该配置项一定是一个目录而不能是文件名。默认为当前目录下 即redis-server同级目录 save 与 bgsave比较 命令 save bgsave IO类型 同步 异步 阻塞? 是 是(短暂的fork调用) 复杂度 O(n) O (n) 优点 不会消耗额外内存 不阻塞客户端命令 缺点 阻塞客户端命令 需要fork，消耗额外内存 RDB的优点与缺点优点 RDB文件紧凑，全量备份，非常适合于进行备份和灾难恢复。 生成RDB文件的时候，Redis主进程会fork一个新的进程进行持久化操作，Redis主进程不需要进行任何磁盘IO的操作。 RDB在恢复大数据集时的速度比AOF的恢复速度要快。 缺点RDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当进行快照持久化时候，会fork一个新的进程完成持久化操作，但是此时Redis进程如果对数据进行了更新，子进程并不会立刻觉察到，所以可能会导致部分数据不一致的情况。 AOF全量备份总是耗时的，有时候我们提供一种更加高效的方式AOF，工作机制很简单，Redis会将每一个收到的写命令都通过write函数追加到文件中。通俗的理解就是日志记录。 基本概念以日志的形式来纪录每个写操作。将Redis执行过的所有写指令纪录下来(读指令不纪录),只允许追加文件但不可以改写文件，Redis启动之初会读取该文件重新构建数据，换言之，Redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。 appendonly.aof文件当客户端有写操作时，就会更新此备份文件。 当出现服务器宕机等灾难情况之后，重启Redis服务就会读取该备份文件，执行该文件的全部命令用来恢复数据。 如果同时开始了RDB和AOF两种持久化策略，则读取aof文件用来恢复！且不会读取dump.rdb文件 亲测 redis-check-rdb 与 redis-check-aofredis-check-rdb file 可以检测file文件是否为一个正确的dump文件 redis-check-aof --fix file可以检测文件是否是一个正确的aof文件，如果不正确，可以键入命令y令其修改为正确的格式。 AOF的触发方式我们可以修改配置文件，选择一种AOF持久化到硬盘的方式。Redis提供了三种AOF触发策略。 appendfsync always(每次修改进行持久化) 这种方式为同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好 appendfsync everysec(每秒钟进行一次持久化) 异步操作，每秒记录 如果一秒内宕机，有数据丢失 appendfsync no(不同步) 默认为每秒进行持久化 对比 命令 always everysec no 优点 不丢失数据 每秒一次fsync丢1秒数据 不用管 缺点 IO开销较大，一般的stat盘只有几百TPS 丢1秒的数据 不可控 Rewrite因为AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令bgrewriteaofAOF文件的持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，遍历新进程的内存中数据，每条记录有一条set语句。 重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写一个新的aof文件，这点与快照类似。 Redis会纪录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64MB时触发 相关配置 appendonly：是否启动AOF 默认为no 启动改为yes appendfilename: 持久化到硬盘的名字，默认为”appendonly.aof” no-appendfsync-on-rewrite：重写时 是否启用Appendfsync，用默认的no即可，保证数据的安全性 auto-aof-rewrite-percentage： 设置重写百分比 默认为100 代表文件大小需要为上次的2倍 auto-aof-rewrite-min-size： 设置重写阈值 当大于等于该值才进行重写 AOF方式的优缺点 优点 AOF由于纪录了每条写操作，可以更好的保护数据的安全性，默认情况下最多会丢失一秒的数据。 AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易出现损坏。 AOF日志文件即使过大的情况，出现后台重写操作，也不会影响客户端的读写。 AOF日志文件的命令通过非常可读的方式进行纪录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令，清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立刻拷贝AOF文件，将最后一条flushall命令给删除，然后通过恢复机制即可恢复所有的数据。 缺点 AOF文件保证了可读性及纪录了每一条写操作，所以日志文件通常比RDB文件更大 AOF开启后，支持的写QPS比RDB支持的写QPS低。因为AOF一般会配置成每秒fsync一次日志文件，所以有一定的性能损耗。 以前AOF发生过BUG，就是通过AOF纪录的日志，进行数据恢复的时候，没有恢复出一模一样的数据 RDB与AOF对比 命令 RDB AOF 启动优先级 低 高 日志体积 小 大 恢复速度 快 慢 数据安全性 丢数据 根据策略决定 轻重 重 轻]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis学习笔记第一天]]></title>
    <url>%2F2020%2F11%2F04%2FRedis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[关系型数据与非关系型数据库关系型数据库概念关系型数据库就是指采用了关系模型来组织、存储数据的数据库。可以理解为二维的表格。每一行对应着一条纪录，而每一列代表着不同的属性。 主流的关系型数据库管理软件有: MySql、SqlServer、Oracle 优点(1) 容易理解，二维表格的结构与人类思维符合。(2) 使用方便，因为大多数关系型数据库都遵循sql标准，当你熟悉了某一种sql语法后，可以迅速学会另一套数据库管理软件的sql语法。(3) 易于维护，数据库的ACID(原子性、一致性、隔离性、持久性)属性，大大降低了数据数据冗余和数据不一致的概率。 瓶颈(1) 海量数据的读写效率对于网站的并发量高，往往打到每秒上万次的请求，对于传统的关系型数据库来说，磁盘的IO是一个很大的挑战(2) 高扩展性和可用性在基于Web的结构中，数据库是最难以横向拓展的(对数据添加列)，当一个应用系统的用户量和访问量与日俱增的时候，数据库没有办法像Web Server那样简单的通过添加更多的硬件和服务节点来拓展性能和复杂能力。 从关系型到非关系型关系型数据库的最大优点就是事务的一致性，这个特性，使得关系型数据库中可以适用于一切要求一致性比较高的系统中。 比如: 银行系统。 但是在网页应用中，对这种一致性的要求不是那么的严格，允许有一定的时间间隔，所以关系型数据库这个特点不是那么的重要了。相反，关系型数据库为了维护一致性所付出的巨大代价就是读写性能比较差。而像微博、facebook这类应用，对于并发读写能力要求极高，关系型数据库已经无法应付。所以必须要用一种新的数据结构存储来代替关系型数据库。所以非关系型数据库应用而生。 非关系型数据库概念NoSQL(Not Only Sql) 非关系型数据库，主要是指非关系型、分布式的且一般不保证ACID的数据存储系统，主要代表有MongoDB、Redis等 NoSQL提出了另一种概念、以键值来存储数据、且结构不稳定，每一个元组都可以有不一样的字段，这种就不会局限于固定的结构，可以减少一些时间和空间的开销。使用这种方式，为了获取用户的不同信息，不需要像关系型数据库中，需要进行多表查询。仅仅需要根据key来取出对应的value即可。 分类非关系型数据库大部分是开源的，实现比较简单，大都是针对一些特性的应用需求出现的。可以根据结构化方法和应用场景的不同，分为以下几类。(1) 面向高性能并发读写的key-value数据库主要特点是具有极高的并发读写能力，例如Redis，Tokyo Cabint等。(2) 面向海量数据访问的面向文档数据库特点是，可以在海量的数据库中快速的查询数据。例如MongoDB、CouchDB(3) 面向可拓展的分布式数据库解决的主要问题是传统数据库的扩展性上的缺陷。 缺点由于Nosql约束少，所以不能像sql那样提供where字段属性的查询。因此适合存储较为简单的数据。有一些不能够持久化数据，所以需要和关系型数据库结合。 对比存储上关系型数据库以数据库表的形式存储数据。NoSql采用key-value的形式存储 事务在关系型数据库中，可以通过开启事务一次执行多条sql语句，要么同时成功要么同时失败，可以保证数据的一致性。 而在NoSql中，没有事务这一个概念，每一个数据集都是原子级别的。 数据表和数据集关系型数据库是表格型的，存储在数据表的行和列中。彼此关联，容易提取。 而非关系型数据库是大块存储在一起。 预定义结构与动态结构在关系型数据库中，必须先定义好字段和表结构之后，才能进行数据的增删改查。而在 非关系型数据库中，可以在任何时候任何地方进行添加，无需语线定义表结构。 常用的命令未连接服务器端连接Redis服务器端 redis-cli -h host -p port -a password默认的配置文件中没有开启远程访问，我们需要修改配置文件。 将bind 绑定ip改为 0.0.0.0 将proteched-mode 改为 no 将requirepass 开启， 后面的value就是你要设置的密码 重启redis服务即可。 在redis中，默认有16个库，我们可以通过修改配置文件进行修改此配置。即 databases 后面的value值 然后重启redis服务即可。我们可以在客户端使用 config get databases命令获取当前有多少个库以供使用。 已连接服务器端 使用select index进行库的切换 使用 keys * 查询所有的键 使用 flushdb清空当前库 使用flushall 清空所有库 使用 dbsize查看当前库的键数量 使用 move key index 移动当前键值对到其他库 返回1代表成功 返回0代表失败(其他库存在同名键则失败 使用 exists key来判断某一个key值是否存在。 返回1代表存在 返回0代表不存在 使用 expire key seconds 对键值key设置过期时间 单位是秒 使用 persist key 解除key的过期时间 使得key持久保持 使用 ttl key 查看当前key还有多少秒过期。 -1为永不过期 -2 不存在或已过期 使用 type key 查看key值的类型 使用 del key [ke....] 用于删除键. 返回成功删除的键的个数 使用 rename key newkey 用于修改key的名称 使用 renamenx key newkey 当newkey不存在时 才将key改为newkey Redis五种基本数据类型String String类型是redis最基本的类型，一个key对应着一个value。 String类型是二进制安全的。意思是redis的string可以包含任何数据类型，比如jpg图片或者序列化的对象等 在redis中，一个string最多可以是512M 常用命令 set key value 设置key的值为value 当key已存在于当前表 则更新 get key 获取key所对应的value值 append key value 如果key是一个已经存在并且为字符串，则在尾部追加value值。 如果key不存在 则创建 且值为value strlen key 返回字符串key对应的value值的长度。 incr key 对string类型的值 + 1, 如果key是string类型但不是数字则失败、key不是string类型也会失败、对于不存在的key，则会创建并通过+1操作其value变为1 decr key 对string类型的值 - 1, 如果key是string类型但不是数字则失败、key不是string类型也会失败、对于不存在的key，则会创建并通过-1操作其value变为 -1 incrby key increment 对string类型的值 + increment, 如果key是string类型但不是数字则失败、key不是string类型也会失败、 对于不存在的key，则会创建并通过+ increment操作其value变为increment decrby key decrement 对string类型的值 - decrement, 如果key是string类型但不是数字则失败、key不是string类型也会失败、对于不存在的key，则会创建并通过+ decrement操作其value变为decrement getrange key start end 获取string类型从start 到 end的值，包含start与end，下标从0开始。 setrange key offset value 从offset位置起，用value替换原串内容。 setex key seconds value 设置key的过期时间及value。 类似与expire 不过setex可以在创建时直接设定好过期时间。 setnx key value 当key值不存在时候，才可以创建到内存，如果key已存在则不生效。 mset key value [key value ....] 即一次操作可以设置多个key value键值对。 若语句失败、则都不生效。 mget key [key....] 即一次可以获取多个key所对应的value值。 msetnx key value [key value.......] 当key不存在时才生效。 若某一个key存在，则失败全部不生效。 List 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部(左边，或者尾部(右边。其底层是一个双向链表 常用命令 lpush key value [value....] 从列表的左侧插入 rpush key value [value....] 从列表的右侧插入 lrange key start stop 从list中取出从start到end的值 lpop key 将key对应的列表最左侧的元素移除 rpop key 将key对应的列表最右侧的元素移除 lindex key index 获取列表的第index位置的值，下标从0开始。 llen key 获取列表的长度 lrem key count value 从列表中删除count个指定的value值，返回值为成功删除的个数。从左侧开始删除。 lrange key start stop 从列表中截取从start到stop的值。 包含start与stop。 rpoplpush source destination 从source列表中取出最右边的元素 添加到destination列表的左侧 lset key index value 根据下标设置列表中的值。 linsert key before | after pivot value 将某个值插入到给定的pivot之前或之后 Hash hash是一个键值对集合 一个键值对应着这个键值对。类似于 HashMap]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Leetcode_SQL】196.删除重复的电子邮箱]]></title>
    <url>%2F2020%2F11%2F02%2F%E3%80%90Leetcode_SQL%E3%80%91196.%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[题目链接：196.删除重复的电子邮箱题目描述：编写一个 SQL 查询，来删除 Person 表中所有重复的电子邮箱，重复的邮箱里只保留 Id 最小 的那个。 Id Email 1 john@example.com 2 bob@example.com 3 john@example.com Id 是这个表的主键。例如，在运行你的查询语句之后，上面的 Person 表应返回以下几行: Id Email 1 john@example.com 2 bob@example.com 思路先理清思路，我们需要删除Email信息重复的数据且保留的是id最小的那条记录行。delete语句的基本语法为delete from 表名 where 条件那么这里的条件显然就是 Email重复且id不为最小值的情况需要删除。所以我们可以根据Email进行分组，会得到一个关于Email的虚拟表，然后利用聚合函数min找到最小的id，那么需要删除的id没在这个返回集就可以被删除。 画图以明确一下。对于分组之后的结果，我们用聚合函数min可以取到每组的最小id(为保留id)所以不难写出sql 1234delete from Personwhere id not in (select min(id) from Person group by Email) 但是这样写会报错，是因为MySQL不允许同时对一张表进行查询和删除操作（这个和并发概念不同，这是指不允许一条sql中同时出现删除与查询。 所以我们需要将子查询封装为一张临时表以供使用 参考解法1234delete from Personwhere id not in (select id from (select min(id) as id from Person group by Email) tmp) 菜鸡Hang_c犯的错误对于子查询哪里 不可以 select id from Person group by Email having id = min(id)因为这样，having后面条件 等于号之前的id始终为虚拟表中的第一行 而 min(id) 确实为最小id。 如果首行不为最小id 这样写就会出现错误。 所以应该为select min(id) from Person group by Email]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>MySql</tag>
        <tag>sql刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Leetcode_SQL】1179.重新格式化部门表]]></title>
    <url>%2F2020%2F11%2F01%2F%E3%80%90Leetcode_SQL%E3%80%911179.%E9%87%8D%E6%96%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E9%83%A8%E9%97%A8%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目链接：1179.重新格式化部门表题目描述：部门表 Department： Column Name Type id int revenue int month varchar (id, month) 是表的联合主键。这个表格有关于每个部门每月收入的信息。月份（month）可以取下列值 [“Jan”,”Feb”,”Mar”,”Apr”,”May”,”Jun”,”Jul”,”Aug”,”Sep”,”Oct”,”Nov”,”Dec”]。 编写一个 SQL 查询来重新格式化表，使得新的表中有一个部门 id 列和一些对应 每个月 的收入（revenue）列。查询结果格式如下面的示例所示： Department 表： id revenue month 1 8000 Jan 2 9000 Jan 3 10000 Feb 1 7000 Feb 1 6000 Mar 查询得到的结果表： id Jan_Revenue Feb_Revenue Mar_Revenue … Dec_Revenue 1 8000 7000 6000 … null 2 9000 null null … null 3 null 10000 null … null 注意，结果表有 13 列 (1个部门 id 列 + 12个月份的收入列)。 思路菜鸡落泪、并不会这道题。但其是经典的行转列问题，所以有必要深入探究一下！首先我们不难想到要查出每一个id的每个月的工资，那么则需要根据id进行分组，即我们需要用到group by进行分组。这里由于作者很菜，所以对group by进行一个较为详细的分析。 group by语句group by语句的作用就是根据一个或者多个列对结果集进行分组。然后我们可以根据分组的结果进行聚合函数的过滤或者通过聚合函数进行查询。 举个例子:123456789101112131415161718192021# 建表sqlCREATE TABLE IF NOT EXISTS stu ( NAME VARCHAR(20) NOT NULL, class VARCHAR(20) NOT NULL, score INT(11) NOT NULL DEFAULT 0)ENGINE=INNODB DEFAULT CHARSET=utf8;# 插入数据INSERT INTO stu VALUES ('张三', '数学', 90), ('张三', '语文', 50), ('张三', '英语', 80), ('李四', '数学', 50), ('李四', '语文', 50), ('李四', '英语', 40), ('王五', '数学', 90), ('王五', '语文', 80), ('王五', '英语', 90), ('赵六', '数学', 40), ('赵六', '语文', 60), ('赵六', '英语', 80) 接下来我说几个需求，你可以尝试一下自己能否写出 需求一: 查询该表中各个科目的名称及对应的的平均成绩 查看参考答案: select class, avg(score) from stu group by class; 需求二: 查询出该表各个科目不及格的人数分别是多少 查看参考答案: select class, sum(score < 60) from stu group by class; 注意 此处定不能使用count来统计，因为count统计的是非空的个数，而score < 60返回值只可能是0或1，所以就会统计出学生的个数。我们用sum进行统计。 需求三: 查询出所有科目都及格的学生姓名。 查看参考答案: select name from stu group by name having min(score) >= 60; 以第三个需求举例，通过group by之后，会产生一个不存在的虚表，如图所示我们可以看到，会根据我们group by后面的字段进行分组，那么就会出现同一个字段对应多个记录行，然后我们可以对这些纪录行的字段做聚合函数操作，进而进行筛选或者提取数据。 case when语句简单函数语法: CASE [col_name] WHEN [value1] THEN [result1]…ELSE [default] END就是类似于编程语言的switch() case语句。 枚举字段的可能值，如果满足则输出then之后的值，否则以else后面的值进行填充，如果没有else子句，则以null填充。 注意: 简单的case 只能做等值判断以stu表举例子: 我们判断学生的成绩是否为50分12# 此为包含else的情况 所以所有字段都会有值进行填充SELECT *, (CASE score WHEN 50 THEN '是' ELSE '不是' END) AS '50分男孩？' FROM stu; 12# 我们把else去掉之后，当score不为50时，其以null进行填充SELECT *, (CASE score WHEN 50 THEN '是' END) AS '50分男孩？' FROM stu; 搜索函数语法: CASE WHEN [expr] THEN [result1]…ELSE [default] END搜索函数可以写判断，并且搜索函数只会返回第一个符合条件的值，其他case被忽略搜索函数可以写判断，如 &lt;、&gt;、 != 等进行判断以stu表举例子:我们判断学生的成绩是否及格 1select *, (case when score &lt; 60 then '不及格' else '及格' end) as '及格否' from stu; 同样 当没有else做默认值的话，以null进行填充。 思路指导了这两点之后，我们便可以搞行专列这个操作了。首先，我们的数据存储在纪录行中，要获取到给定id的所有其他数据 则应该根据id对数据进行分组，即group by id。 画一个图帮助大家理解。 以样例为例子我们可以看到，对于同一个id，其所有的数据已经放到一个组里面了，然后我们可以根据case when语句对所需数据进行提取，如 我要第一个月的收入，我可以将when的条件设置为 month = ‘Jan’ then的结果为 revenue即可。select id, case month when &#39;Jan&#39; then revenue end from Department group by id但是这里需要考虑，group by 返回的默认是第一行的数据，即你写这样case只会判断第一行的数据是否满足。 你可以执行一下下面的代码帮助你的理解123456789101112131415161718192021CREATE TABLE IF NOT EXISTS Department ( id INT(11), revenue INT(11), `month` VARCHAR(20))DEFAULT CHARSET = utf8;INSERT INTO Department VALUES (1, 8000, 'Jan'),(2, 9000, 'Jan'),(3, 10000, 'Feb'),(1, 7000, 'Feb'),(1, 6000, 'Mar')SELECT id, CASE `month` WHEN 'Jan' THEN revenue END 一月, CASE `month` WHEN 'Feb' THEN revenue END 二月, CASE `month` WHEN 'Mar' THEN revenue END 三月FROM Department GROUP BY id; 我们可以看到，对于id = 1的二月，三月都无法获取到正确的数据，原因就是因为分组之后的数据，没通过聚合函数操作的话，其只返回第一行，所以我们的二月 ‘Feb’ 三月 ‘Mar’无法与第一行数据匹配，导致收入为null.具体看下图，图片黄色背景为与case进行匹配的记录行。考虑到了这里，我们就不难想到，我们需要一个聚合函数，让每个分组的所有数据都通过case校验并返回值。所以这里我们选取max函数或者sum函数均可。 参考程序12345678910111213141516171819select d.id, max(case d.month when 'Jan' then d.revenue end) Jan_Revenue, max(case d.month when 'Feb' then d.revenue end) Feb_Revenue, max(case d.month when 'Mar' then d.revenue end) Mar_Revenue, max(case d.month when 'Apr' then d.revenue end) Apr_Revenue, max(case d.month when 'May' then d.revenue end) May_Revenue, max(case d.month when 'Jun' then d.revenue end) Jun_Revenue, max(case d.month when 'Jul' then d.revenue end) Jul_Revenue, max(case d.month when 'Aug' then d.revenue end) Aug_Revenue, max(case d.month when 'Sep' then d.revenue end) Sep_Revenue, max(case d.month when 'Oct' then d.revenue end) Oct_Revenue, max(case d.month when 'Nov' then d.revenue end) Nov_Revenue, max(case d.month when 'Dec' then d.revenue end) Dec_Revenuefrom Department dgroup by d.id]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>MySql</tag>
        <tag>sql刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于String的笔记【Java基础】]]></title>
    <url>%2F2020%2F11%2F01%2F%E5%85%B3%E4%BA%8EString%E7%9A%84%E7%AC%94%E8%AE%B0%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%2F</url>
    <content type="text"><![CDATA[本文对Java中的常用类String做一个阶段性的总结，其中包括String的底层实现、String的常用方法、关于字符串常量池中的面试题等内容。 文章不做特殊说明，默认是JDK8的情况下的结论！！！ 基本概念概述String并属于基本数据，而是一种常用类。String被声明为final，所以其不可被继承。 题外话面试可能会问到的题目: final可以修饰那些东西？修饰之后有什么作用?答: 1) 可以修饰类 修饰之后此类不可被继承。 2） 可以修饰方法 修饰之后该方法不能被子类重写 3）可以修饰变量 修饰之后改变量只能被赋值一次 4） 不能修饰抽象类或者接口 因为修饰了代表类不能被继承 接口不能被实现 那么该抽象类或者接口就没有了意义。 final，finally，finalize有什么区别。答: 1) final回答就是第一个问题 就说可以修饰啥 修饰之后的效果 2)finally 是与try代码块 或 try catch代码块一起使用的 主要作用是在finally代码块中的代码一定会执行，常用于资源的释放，防止try代码块出现异常导致某些资源无法释放。 3）finalize是Object类中的方法，当子类重写该方法，可以在GC得时候获得一次免除被GC的机会（例如在代码块中使得其他在GC ROOTS中的引用指向this即可） 此方法只能被指向一次 且优先级较低 已经不建议被使用。 在 JDK1.8及之前，String底层使用char数组用来存储数据。12345public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence&#123; /** The value is used for character storage. */ private final char value[]; 在JDK1.9之后，String底层使用byte数组存储字符串，同时使用coder来标识使用了那种编码 1234567891011121314151617181920212223242526272829public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** * The value is used for character storage. * * @implNote This field is trusted by the VM, and is a subject to * constant folding if String instance is constant. Overwriting this * field after construction will cause problems. * * Additionally, it is marked with &#123;@link Stable&#125; to trust the contents * of the array. No other facility in JDK provides this functionality (yet). * &#123;@link Stable&#125; is safe here, because value is never null. */ @Stable private final byte[] value; /** * The identifier of the encoding used to encode the bytes in * &#123;@code value&#125;. The supported values in this implementation are * * LATIN1 * UTF16 * * @implNote This field is trusted by the VM, and is a subject to * constant folding if String instance is constant. Overwriting this * field after construction will cause problems. */ private final byte coder; value数组被声明为final，所以就是说当数组初始化之后，就不能引用其他数组。并且String内部并没有改变value数组的方法，因此可以保证String的不可变。 不可变的好处可以缓存hash值因为String的hash值经常被使用，不可变的特性可以使得hash值也不可变，因此只需要计算一次hash值即可String存在成员变量hash默认值为0，String的hashCode方法如下123456789101112public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h;&#125; 可以看出，当其hash值为0时且串不为空时才会计算hash值，否则会返回默认的0值或者已经计算过的hash值。我们也可以看出，只有当实际调用hashCode方法时才会计算，否则默认为0，算是一个懒加载 字符串常量池的需要因为我们知道运行时数据区会有一会内存区域用来存储字符串常量池(jdk6及之前在方法区，jdk7及之后在堆空间)，如果String不是final的，那么其就是可变对象，如果修改了内容则其hashCode值就会改变, 在字符串常量池则可能无法获取正确引用地址或者字符串常量池会存储重复的数据。 例如: 假设String可变，我们知道字符串常量池的底层结构是Hashtable，即数组+链表的方式实现。 那么假设字符串String str = “abc” 打在了 index = 1的位置，然后str改变成了”123”，那么此时如果有新的字符串”123”试图添加进常量池，且其经过Hash运算打到的下标是2，那么此时常量池就会存储两份”123”。 所以为了保证常量池的数据唯一性，获得正确的引用地址，只有String是不可变的才可以使用字符串常量池。 安全性由于String的不可变性，所以我们可以在多线程环境下使用String而不必考虑线程安全问题。 常用方法String.length() 作用: 返回当前字符串的长度 注意事项: 调用length()方法返回的是字符串的长度，即 不论是字母、数字、标点符号、汉字都是一个字符。 例如 &quot;12345&quot;.length()的返回结果是5. &quot;你好呀&quot;.length()的返回结果是3. String.isEmpty() 作用: 用于判断当前字符串是否为空串，为空串返回true， 非空返回false 注意事项: 此方法使用的前提是str有具体的指向，为null会报空指针异常。 String.charAt(int index) 作用: 获取下标index处的char值。 下标的起始位置为0 String.indexOf() 四种重载形式 indexOf(int) , indexOf(int, int), indexOf(String), indexOf(String, int) 其中，若给定一个参数，则其会调用两个参数的方法，且第二个参数给定为0 第一个参数为要查找的ASCII码或者String字符串，第二个参数为开始查找的下标 作用: 返回要查找值的首次出现位置的下标，没有找到则返回-1； String.lastIndexOf() 作用: 重载方式与indexOf()一直，只是当前方法返回的是指定内容出现的最后位置，没找到返回-1 注意事项： indexOf()是从前往后找，而lastIndexOf是从后往前找。 所以当我们指定起始位置fromIndex时，indexOf()是找从fromIndex到str.length()中首次出现的下标。而lastIndexOf是找从0到fromIndex中最后一次出现的下标位置。 String.subString() 两种重载方式 subString(int beginIndex), subString(int beginIndex, int endIndex) 作用：第一种方式返回从指定下标的字符串结尾的字串，第二种方式返回从begin开始到endIndex的字串(包含begin但不包含end) String.concat(String str) 作用: 返回当前字符串拼接给定参数str后的结果。当我们只是少量的拼接操作，则不需要通过StringBuilder或者StringBuffer进行拼接，使用此方法即可进行拼接。 String.replace(char oldChar, char newChar) 作用: 将该字符串中所有的字符oldChar替换为newChar并返回。 String.replaceFirst(String regex, String replacement) 作用: 第一个参数为正则表达式，第二个参数为满足正则表达式之后的替换值。只替换首次满足的位置 String.replaceAll(String regex, String replacement) 作用: 第一个参数为正则表达式，第二个参数为满足正则表达式之后的替换值。替换所有满足正则的位置 字符串常量池在运行时数据区的位置在jdk6及之前，是存储在方法区的，即永久代。而从jdk7开始，其迁移到堆空间。 什么数据回存储在常量池？ 源码中显式的字面值常量举例子String str = &quot;Hello World&quot;比如这里的”Hello World”就会添加在常量池里，这点我们可以通过反编译生成的字节码文件，在字节码文件中就会存储字面值常量的符号引用，通过类加载机制会将其添加到字符串常量池中。 通过显式调用String的intern方法，会尝试加入常量池(已存在不会添加显示的调用intern方法也会将String尝试添加到字符串常量池中。这里有个不同地问题，在jdk6及之前采用的是复制，即复制一份String到常量池中，而jdk7及之后采用的是复制为引用，不会重新造一份String。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM垃圾回收器笔记]]></title>
    <url>%2F2020%2F10%2F21%2FJVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[垃圾收集器的组合方式 Serial收集器工作原理Serial收集器是最基础、历史最悠久的收集器。这个收集器是单线程工作的收集器，其单线程的意义不仅仅是说其只会使用一个处理器或者一条线程去完成垃圾收集工作，更重要的是指其在进行垃圾收集的过程中必须暂停其他所有的工作线程，直到它收集完成。其收集过程如下图所示.我们可以看到Serial垃圾收集器在进行垃圾回收的时候必须暂停用户线程，即STW，会导致用户出现短期的卡顿现象。且其在新生代采取标记-复制算法进行回收，在老年代采用标记-整理算法进行垃圾收集 工作区域Serial作用于新生代Serial Old 作用域老年代 搭配使用 Serial 回收新生代 + Serial Old 回收老年代 应用场景 其是客户端模式下的默认新生代垃圾收集器。 对于单核处理器或处理器核心数较少时，Serial是不错的选择 优缺点优点 实现简单且高效 适用于单核处理器或处理器核心较少时 额外内存消耗最小(相比于CMS、G1等需要内存担保策略的垃圾收集器缺点 在多核心机器上不能发挥多核的优势 如果STW时间过长可能影响用户体验 ParNew收集器工作原理ParNew收集器实质上是Serial收集器的多线程并行版本。作用于新生代，采用标记-复制算法进行垃圾回收，在回收的时候会产生STW ParNew收集器除了支持多线程并行收集之外、其他与Serial收集器相比并没有太多创新之处，但他却是不少运行在服务端模式下的HotSpot虚拟机。尤其是JDK7之前的遗留系统中首选的新生代收集器，其中有一个与功能、性能无关但其实很重要的原因是: 除了Serial收集器外、目前只有它能与CMS收集器配合工作 工作区域作用域新生代，并发收集，需要STW。 搭配使用 ParNew 收集新生代 + CMS收集老年代(备用Serial Old) 应用场景 在单核心处理器的环境中ParNew收集器的效果绝对不会比Serial效果好 在多核心处理器的环境中，ParNew收集器进行垃圾收集时，可以对系统资源高效利用还是很有好处的。 默认开启的收集线程数与处理器核心数量相同。 优缺点优点 相较于Serial对于新生代的收集 启用了多线程收集，在多核心处理器环境下，更能对系统资源充分利用，降低STW时间 配合CMS收集器搭配使用 缺点 在单核心处理器或处理器核心较少时，效率不如Serial高效 Parallel Scavenge收集器工作原理Parallel Scavenge收集器是一款新生代收集器，基于标记-复制算法实现的垃圾收集器。也是能够并行收集的多线程收集器。Parallel Scavenge收集器看似与ParNew非常相似，但其与ParNew的关注点并不同。 Parallel Scavenge收集器的目标是达到一个可控制的吞吐量。所谓吞吐量就是指运行用户代码与处理器总消耗时间的比值。即 吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 运行垃圾收集时间)举个例子：虚拟机完成某个任务，用户代码加上垃圾回收总共花费了100分钟，其中垃圾回收花费了1分钟，那么吞吐量就是99%。停顿时间越短就越适合需要与用户交互或者保证服务响应质量的程序，良好的响应时间能提升用户体验 Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量 控制最大垃圾收集停顿时间 -XX:MaxGCPauseMillis 设置吞吐量大小: -XX:GCTimeRatio 由于与吞吐量关系密切，Parallel Scavenge收集器也经常被称作“吞吐量优先收集器”。除了上述两个参数之外，Parallel Scavenge收集器还有一个参数: -XX:+UseAdaptiveSizePolicy值得我们关注。这是一个开关参数，当这个参数被激活后，就不需要人工指定新生代的大小(-Xmn)、Eden与Survior区的比例(-XX:SurviorRatio )、晋升老年代对象大小(-XX:PretenureSizeThreshold)等细节参数。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大吞吐量。这种调节方式称为垃圾收集的自适应的调整策略 工作区域作用域新生代，采用标记-复制算法进行垃圾收集，会有STW，多线程并行进行垃圾回收 搭配使用 Parallel Scavenge 回收新生代 + Parallel Old 回收老年代 Parallel Scavenge 回收新生代 + Serial Old 回收老年代 应用场景 用于用户交互或需要保证服务响应质量的程序 Serial Old 收集器工作原理Serial Old收集器是Serial收集器的老年代版本，它同样是一个单线程收集器，采用的是标记-整理算法。这个收集器的主要意义也是共客户端模式下的HotSpot虚拟机使用。在服务端模式下，其可能有两种用途 在JDK5以及之前的版本中与Parallel Scavenge收集器搭配使用 作为CMS收集器发生失败时的后备预案。 工作区域作用于老年代，采用标记整理算法，会出现STW，单线程收集。 搭配使用 Serial回收新生代 + Serial Old 收集老年代 ParNew回收新生代 + Serial Old 收集老年代 Parallel Scavenge 回收新生代 + Serial Old 收集老年代 作为CMS回收失败的后备方案。 Parallel Old收集器工作原理Parallel Old是Parallel Scavenge收集器的老年代收集版本，支持多线程并发收集，基于标记-整理算法实现。这个收集器是直到JDK6时才开始提供。 工作区域作用于老年代，采用标记-整理算法，会出现STW，多线程并行收集。 搭配使用 Parallel Scavenge 回收新生代 + Parallel Old 收集老年代 CMS收集器工作原理CMS收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网网站或者基于B/S系统的服务端上，这类应用通常都会较为关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来良好的交互体验。 其是基于标记-清除算法实现的，运作过程分为四个步骤: 初始标记 并发标记 重新标记 并发清除 其中初始标记、重新标记这两个步骤依然需要STW，初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快。 并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发执行。重新标记阶段是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一点，但也远比并发标记阶段的时间短。最后是并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。 由于整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器都可以与用户线程一起工作，所以总体来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。 工作区域作用域老年代，并发收集，标记清除算法，会有短暂的STW 搭配使用 ParNew回收新生代 + CMS收集老年代(Serial Old收集器作为备用) Serial回收新生代 + CMS收集老年代(Serial Old收集器作为备用) 【JDK9取消这一组合 应用场景 关注响应速度的互联网服务 优缺点优点 并发收集、低停顿缺点 CMS收集器对处理器资源非常敏感。在并发阶段，他虽然不会导致用户线程停顿，但却会因为占用了一部分处理器的计算能力而导致应用程序变慢，降低总吞吐量。CMS默认启动的回收线程数是(处理器核心数量 + 3) / 4。如果处理器核心数在四个及以上，并发回收时垃圾收集线程只占用不超过25%的处理器运算资源，并且会随着核心数量的增加而下降。但是当处理器核心数量不足四个时，CMS对用户程序的影响就可能变得很大。 无法处理“浮动垃圾”，有可能出现“Con-current Mode Failure”失败进而导致另一次完全的STW的Full GC产生。在CMS的并发标记和并发清理阶段，用户线程还在继续运行，自然就会有新的垃圾对象产生，但这一部分垃圾在当次收集中无法处理，只好留在下一次垃圾收集时清理。这部分垃圾称为“浮动垃圾” 同样是因为在垃圾收集阶段用户线程还需要继续运行，那就还需要预留足够的内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待到老年代几乎被填满再进行收集，需要预留一部分空间供并发收集时的程序运作使用。可以通过参数-XX:CMSInitiatingOccu-pancyFraction的值来设置CMS的触发百分比。当此参数较低时，虽然可以保证并发阶段新对象的内存分配，但是增加了老年代的回收频率。当此参数较高时，虽然降低了回收频率，但是如果当用户线程无法分配内存时，就是暂停用户线程，启用备用方案即Serial Old收集器进行垃圾收集。所以此参数得根据自己的使用场景进行均衡。 CMS是基于标记-清除算法来实现的。那么就会产生内存碎片，当内存碎片过多时，对于分配大对象的场景就会带来麻烦，往往老年代的空闲空间足够分配，但由于内存不是连续的导致无法分配大对象，从而导致不得不触发一次Full GC为了解决这个问题，CMS提供了-XX:+UseCMS-CompactAtFullCollection开关参数，用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程，由于内存整理的过程必须移动存活对象是无法并发的。这样空间碎片的问题是解决了，但停顿时间又会变长。因此虚拟机的设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction。这个参数作用是要求CMS收集器在执行若干次不整理空间的Full GC之后，下一次进入Full GC前后会先进行碎片整理。 Garbage Firse（G1）收集器工作原理G1是一款主要面向服务端的垃圾收集器。作为CMS收集器的替代者和继承人，设计者们希望做出一款能够建立起“停顿时间模型”的收集器，停顿时间模型的意思是能够支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标 G1可以面向堆内存任何部分组成会收集（Collection Set 一般简称为Cset）进行回收，衡量标准不再是它属于那个分代，而是那块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式 G1开创的基于Region的堆内存布局是它能够实现这个目标的关键。虽然G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异。G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域(Region)，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活一段时间、熬过多次收集的旧对象都能获取很好的收集效果。 Region中还有一类特殊的Humongous区域，专门用来存储大对象，G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数-XX:G1HeapRegionSize设定，取值范围为1MB~32MB,且应为2的N次幂。对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous之中，G1的大多数行为都把Humongous Region作为老年代的一部分来看待。 虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，他们都是一系列区域(不需要连续)的动态集合。G1收集器之所以能建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划的避免在整个Java堆中进行全区域的垃圾收集。更具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的”价值“大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间，优先处理回收价值收益最大的Region。这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。 需要解决的问题： 将堆分成多个独立的Region之后，Region里面存在的跨Region引用对象如何解决？，解决的思路是利用:记忆集避免全堆作为GC Roots扫描，但在G1收集器上记忆集的应用实际要复杂很多。每个Region都维护有自己的记忆集，这些记忆集会纪录下别的Region指向自己的指针，并标记这些指针分别在那些卡页的范围之内。G1的记忆集在存储结构的本质是一种哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号。这种“双向”的卡表结构(卡表是我指向谁，这种结构还纪录了谁指向我) 比原来的卡表实现起来更复杂，同时由于Region数量比传统收集器的分代数量明显要多得多，因此G1收集器要比其他的传统垃圾收集器有着更高的内存占用负担。根据经验，G1至少要耗费大约相当于Java堆容量的10%-20%的额外内存来维持收集器的工作 在并发标记阶段如何保证收集线程与用户线程互不干扰运行？ 。这里首先要解决的是用户线程改变的对象引用关系时，必须保证其不能打破原本的对象图结构，导致标记结果出现错误。CMS收集器采用增量更新算法实现，而G1收集器则是通过原始快照(SATB)算法来实现的。]]></content>
      <tags>
        <tag>面试 - JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[千万级MySQL数据测试]]></title>
    <url>%2F2020%2F10%2F02%2F%E5%8D%83%E4%B8%87%E7%BA%A7MySQL%E6%95%B0%E6%8D%AE%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[千万级数据生成插入测试建表123456CREATE TABLE boy( `id` INT(11) PRIMARY KEY AUTO_INCREMENT, -- 用户id 主键 唯一且不为空 自增 `name` VARCHAR(20) NOT NULL, -- 用户姓名 非空 `phone` VARCHAR(20) NOT NULL UNIQUE, -- 用户手机号 非空且唯一 `girl_friendId` INT(11) -- 男用户的女朋友id )ENGINE = INNODB DEFAULT CHARSET = utf8; -- 存储引擎为innodb 且 默认编码为u8 通过JDBC进行添加数据构造姓名通过姓氏、名字、的随机组合，随机出姓名;1234567891011121314private static String FIRST_NAME="赵钱孙李周吴郑王冯陈褚卫蒋沈韩杨朱秦尤许何吕施张孔曹严华金魏陶姜戚谢邹喻柏水窦章云苏潘葛奚范彭郎鲁韦昌马苗凤花方俞任袁柳酆鲍史唐费廉岑薛雷贺倪汤滕殷罗毕郝邬安常乐于时傅皮卞齐康伍余元卜顾孟平黄和穆萧尹姚邵湛汪祁毛禹狄米贝明臧计伏成戴谈宋茅庞熊纪舒屈项祝董梁杜阮蓝闵席季麻强贾路娄危江童颜郭梅盛林刁钟徐邱骆高夏蔡田樊胡凌霍虞万支柯咎管卢莫经房裘缪干解应宗宣丁贲邓郁单杭洪包诸左石崔吉钮龚程嵇邢滑裴陆荣翁荀羊於惠甄魏加封芮羿储靳汲邴糜松井段富巫乌焦巴弓牧隗山谷车侯宓蓬全郗班仰秋仲伊宫宁仇栾暴甘钭厉戎祖武符刘姜詹束龙叶幸司韶郜黎蓟薄印宿白怀蒲台从鄂索咸籍赖卓蔺屠蒙池乔阴郁胥能苍双闻莘党翟谭贡劳逄姬申扶堵冉宰郦雍却璩桑桂濮牛寿通边扈燕冀郏浦尚农温别庄晏柴瞿阎充慕连茹习宦艾鱼容向古易慎戈廖庚终暨居衡步都耿满弘匡国文寇广禄阙东殴殳沃利蔚越夔隆师巩厍聂晁勾敖融冷訾辛阚那简饶空曾毋沙乜养鞠须丰巢关蒯相查后江红游竺权逯盖益桓公万俟司马上官欧阳夏侯诸葛闻人东方赫连皇甫尉迟公羊澹台公冶宗政濮阳淳于仲孙太叔申屠公孙乐正轩辕令狐钟离闾丘长孙慕容鲜于宇文司徒司空亓官司寇仉督子车颛孙端木巫马公西漆雕乐正壤驷公良拓拔夹谷宰父谷粱晋楚阎法汝鄢涂钦段干百里东郭南门呼延归海羊舌微生岳帅缑亢况后有琴梁丘左丘东门西门商牟佘佴伯赏南宫墨哈谯笪年爱阳佟第五言福百家姓续";private static String BOY = "伟刚勇毅俊峰强军平保东文辉力明永健世广志义兴良海山仁波宁贵福生龙元全国胜学祥才发武新利清飞彬富顺信子杰涛昌成康星光天达安岩中茂进林有坚和彪博诚先敬震振壮会思群豪心邦承乐绍功松善厚庆磊民友裕河哲江超浩亮政谦亨奇固之轮翰朗伯宏言若鸣朋斌梁栋维启克伦翔旭鹏泽晨辰士以建家致树炎德行时泰盛雄琛钧冠策腾楠榕风航弘";public static String getOneBoyName()&#123; char firstName = FIRST_NAME.charAt(random.nextInt(FIRST_NAME.length())); // 取出姓氏 if(random.nextInt(2) == 0)&#123; // 随机名字为两个字或者三个字 String lastName = BOY.charAt(random.nextInt(BOY.length())) + "" + BOY.charAt(random.nextInt(BOY.length())); // 取出两个字 return firstName + lastName; &#125; else &#123; char lastName = BOY.charAt(random.nextInt(BOY.length())); // 取出一个字 return firstName + "" + lastName; &#125; &#125; 构造手机号与上同理，通过已有的手机号前缀，随机出手机号，但手机号唯一，用一个set去维护不冲突。12345678910111213141516171819202122private static String[] TEL_FIRST = ("133, 153, 177, 180,181, 189, 134, 135, 136, 137, 138, 139, 150, 151, 152, 157, 158, 159," + "178, 182, 183, 184, 187, 188, 130, 131, 132, 155, 156, 176, 185, 186," + "145, 147, 170").split(",");private static Set&lt;String&gt; phoneSet = new HashSet&lt;&gt;();public static String getOneBoyPhone()&#123; String phone; do&#123; String pre = TEL_FIRST[random.nextInt(TEL_FIRST.length)].trim(); // 取出一个随机前缀 String last = String.valueOf(random.nextInt(100000000)); // 随机一个后8为位 if(last.length() &lt; 8)&#123; // 如果当前随机值不足8为 则前置位补0 StringBuilder sb = new StringBuilder(); for(int i = 0; i &lt; 8 - last.length(); i++)&#123; sb.append("0"); &#125; sb.append(last); last = sb.toString(); &#125; phone = pre + last; &#125; while(phoneSet.contains(phone)); // 如果set集合已存在 则继续生成 phoneSet.add(phone); // 添加到set集合 保证不重复 return phone; &#125; 测试效率通过JDBC进行操作数据库，进行插入数据操作。12345678910111213141516public static void addBoyUser(int n) throws ClassNotFoundException, SQLException &#123; Class.forName("com.mysql.jdbc.Driver"); Connection connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/study?characterEncoding=utf-8", "root", "root"); PreparedStatement statement = connection.prepareStatement("insert into boy values(?, ?, ?, ?)"); for(int i = 1; i &lt;= n; i++)&#123; statement.setString(1, null); statement.setString(2, getOneBoyName()); String oneBoyPhone = getOneBoyPhone(); while(phoneSet.contains(oneBoyPhone))&#123; oneBoyPhone = getOneBoyPhone(); &#125; statement.setString(3, getOneBoyPhone()); statement.setString(4, String.valueOf( (random.nextInt(100000000)) % 13 != 0 ? random.nextInt(10000000) : 0)); &#125; &#125; 我们先插入1万条数据测试一下时间我们可以看到需要15s左右，但是这里可能有小伙伴会怀疑存在set判重，生成数据等消耗的时间。我们可以测一下，只生成数据，不进行execute的时间。我们可以看到，生成数据的时间不超过1s，所以大部分时间是花在操作数据库上面。 1万条数据就需要15秒左右，那千万级数据简单算一下就需要4个小时左右，我们显然不能接受 千万数据快速插入优化一次插入多个value值我们都知道可以一次插入多条纪录就像这样:insert into table values (字段1, 字段2, 字段3, ...), (字段1, 字段2, 字段3, ...), (字段1, 字段2, 字段3, ...);我们可以更改方法，使得一次插入多条数据，进而测试是否可以提高我们的插入效率总共1万条纪录这里分别测试拼接1条、10条、100条、1000条的插入完成时间 每次拼接的value条数 执行完成的时间 1条 15.482秒 10条 2.839秒 100条 0.966秒 1000条 0.865秒 我们可以看到，效果是非常明显的，但是显然我们的sql语句是有限制的，其长度不能过长。我们可以执行sql语句show VARIABLES WHERE Variable_name LIKE &#39;max_allowed_packet&#39;;来查看自己机器目前所允许的sql最大字节数. 可以在my.ini配置文件中进行修改 如: max_allowed_packet = 8M 除此之外，我们知道mysql是默认自动提交的。我们可以显式的开启事务，然后执行完毕之后进行commit，也可以增加我们插入的效率.总共1万条纪录这里分别测试拼接1条、10条、100条、1000条的插入完成时间(手动开启事务，执行完毕后统一提交事务) 每次拼接的value条数 执行完成的时间 1条 2.195秒 10条 1.004秒 100条 0.895秒 1000条 0.76秒 观察结果我们可以发现，当一次插入一条纪录时，每次都是自动commit事务，导致效率的低下。我们手动commit之后，对于大量sql语句的执行有显著的效果。 将insert into语句改为 insert delayed into语句innodb存储引擎不支持这样的语句 遂未测试 最终插入了1000万条数据，用时四分钟左右。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package mysql;import java.sql.*;import java.util.HashSet;import java.util.Random;import java.util.Set;public class addUserBoy &#123; private static String FIRST_NAME="赵钱孙李周吴郑王冯陈褚卫蒋沈韩杨朱秦尤许何吕施张孔曹严华金魏陶姜戚谢邹喻柏水窦章云苏潘葛奚范彭郎鲁韦昌马苗凤花方俞任袁柳酆鲍史唐费廉岑薛雷贺倪汤滕殷罗毕郝邬安常乐于时傅皮卞齐康伍余元卜顾孟平黄和穆萧尹姚邵湛汪祁毛禹狄米贝明臧计伏成戴谈宋茅庞熊纪舒屈项祝董梁杜阮蓝闵席季麻强贾路娄危江童颜郭梅盛林刁钟徐邱骆高夏蔡田樊胡凌霍虞万支柯咎管卢莫经房裘缪干解应宗宣丁贲邓郁单杭洪包诸左石崔吉钮龚程嵇邢滑裴陆荣翁荀羊於惠甄魏加封芮羿储靳汲邴糜松井段富巫乌焦巴弓牧隗山谷车侯宓蓬全郗班仰秋仲伊宫宁仇栾暴甘钭厉戎祖武符刘姜詹束龙叶幸司韶郜黎蓟薄印宿白怀蒲台从鄂索咸籍赖卓蔺屠蒙池乔阴郁胥能苍双闻莘党翟谭贡劳逄姬申扶堵冉宰郦雍却璩桑桂濮牛寿通边扈燕冀郏浦尚农温别庄晏柴瞿阎充慕连茹习宦艾鱼容向古易慎戈廖庚终暨居衡步都耿满弘匡国文寇广禄阙东殴殳沃利蔚越夔隆师巩厍聂晁勾敖融冷訾辛阚那简饶空曾毋沙乜养鞠须丰巢关蒯相查后江红游竺权逯盖益桓公万俟司马上官欧阳夏侯诸葛闻人东方赫连皇甫尉迟公羊澹台公冶宗政濮阳淳于仲孙太叔申屠公孙乐正轩辕令狐钟离闾丘长孙慕容鲜于宇文司徒司空亓官司寇仉督子车颛孙端木巫马公西漆雕乐正壤驷公良拓拔夹谷宰父谷粱晋楚阎法汝鄢涂钦段干百里东郭南门呼延归海羊舌微生岳帅缑亢况后有琴梁丘左丘东门西门商牟佘佴伯赏南宫墨哈谯笪年爱阳佟第五言福百家姓续"; private static String BOY = "伟刚勇毅俊峰强军平保东文辉力明永健世广志义兴良海山仁波宁贵福生龙元全国胜学祥才发武新利清飞彬富顺信子杰涛昌成康星光天达安岩中茂进林有坚和彪博诚先敬震振壮会思群豪心邦承乐绍功松善厚庆磊民友裕河哲江超浩亮政谦亨奇固之轮翰朗伯宏言若鸣朋斌梁栋维启克伦翔旭鹏泽晨辰士以建家致树炎德行时泰盛雄琛钧冠策腾楠榕风航弘"; private static String[] TEL_FIRST = ("133, 153, 177, 180,181, 189, 134, 135, 136, 137, 138, 139, 150, 151, 152, 157, 158, 159," + "178, 182, 183, 184, 187, 188, 130, 131, 132, 155, 156, 176, 185, 186," + "145, 147, 170").split(","); private static final int Max = 10000000; private static Random random = new Random(); private static Set&lt;String&gt; phoneSet = new HashSet&lt;&gt;(); public static void main(String[] args) throws SQLException, ClassNotFoundException &#123; long start = System.currentTimeMillis(); addBoyUser2(10000000, 1000); long end = System.currentTimeMillis(); System.out.println("耗时: " + (end - start) / 1000.0 + "秒"); &#125; public static void addBoyUser(int n) throws ClassNotFoundException, SQLException &#123; Class.forName("com.mysql.jdbc.Driver"); Connection connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/study?characterEncoding=utf-8", "root", "root"); PreparedStatement statement = connection.prepareStatement("insert into boy values(?, ?, ?, ?)"); for(int i = 1; i &lt;= n; i++)&#123; statement.setString(1, null); statement.setString(2, getOneBoyName()); statement.setString(3, getOneBoyPhone()); statement.setString(4, String.valueOf( (random.nextInt(100000000)) % 13 != 0 ? random.nextInt(10000000) : 0)); statement.executeUpdate(); &#125; &#125; public static void addBoyUser2(int n, int m) throws ClassNotFoundException, SQLException &#123; Class.forName("com.mysql.jdbc.Driver"); Connection connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/study?characterEncoding=utf-8", "root", "root"); connection.setAutoCommit(false); Statement statement = connection.createStatement(); String sql = "insert into boy values"; StringBuilder sb = new StringBuilder(sql); boolean flag = true; for(int i = 1; i &lt;= n; i++)&#123; if(flag)&#123; // 代表第一条数据 sb.append("(null, '" + getOneBoyName() + "', '" + getOneBoyPhone() + "', '" + getGirlFriendId() + "')"); &#125; else &#123; sb.append(", (null, '" + getOneBoyName() + "', '" + getOneBoyPhone() + "', '" + getGirlFriendId() + "')"); &#125; flag = false; if(i % m == 0)&#123; flag = true; statement.execute(sb.toString()); sb.delete(0, sb.length()); sb.append(sql); &#125; &#125; connection.commit(); &#125; public static String getOneBoyName()&#123; char firstName = FIRST_NAME.charAt(random.nextInt(FIRST_NAME.length())); // 取出姓氏 if(random.nextInt(2) == 0)&#123; // 随机名字为两个字或者三个字 String lastName = BOY.charAt(random.nextInt(BOY.length())) + "" + BOY.charAt(random.nextInt(BOY.length())); // 取出两个字 return firstName + lastName; &#125; else &#123; char lastName = BOY.charAt(random.nextInt(BOY.length())); // 取出一个字 return firstName + "" + lastName; &#125; &#125; public static String getOneBoyPhone()&#123; String phone; do&#123; String pre = TEL_FIRST[random.nextInt(TEL_FIRST.length)].trim(); // 取出一个随机前缀 String last = String.valueOf(random.nextInt(100000000)); // 随机一个后8为位 if(last.length() &lt; 8)&#123; // 如果当前随机值不足8为 则前置位补0 StringBuilder sb = new StringBuilder(); for(int i = 0; i &lt; 8 - last.length(); i++)&#123; sb.append("0"); &#125; sb.append(last); last = sb.toString(); &#125; phone = pre + last; &#125; while(phoneSet.contains(phone)); // 如果set集合已存在 则继续生成 phoneSet.add(phone); // 添加到set集合 保证不重复 return phone; &#125; public static String getGirlFriendId()&#123; int val = random.nextInt(10000000); return String.valueOf((val % 13 == 0) ? 0 : val); &#125;&#125; Explain查看执行计划概述使用Explain命令可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。 通过explain我们可以获得以下信息： 表的读取顺序 数据读取操作的操作类型 那些索引可能被使用 那些索引确实被使用了 表之间的引用 每张表有多少行被优化器查询使用方式:explain sql语句 具体字段及含义 idselect的标识符。其值越大、则优先级越高、越先读取、加载 当所有id相同时，读取顺序从上到下一次读取； 当所有的id都不同时，id值越大则越靠前读取。(子查询括号最里面的最先读取) 当出现即有相同又有不同时。id大的组先按从上到下的顺序读取，id下的组后按从上到下的顺序读取。 select_type该字段是表示查询的类型可能出现的值。 SIMPLE 表示简单的查询，没有使用union或者子查询 PRIMARY sql语句中有子查询，那么最外层的查询语句会被标记为primary SUBQUERY 不依赖于外部查询 例如 select a.* , (select id from b where id = 1) from a当前子查询只是将结果集填充一列，且子查询返回结果为一行 DEPENDENT SUBQUERY 依赖于外部查询 例如 select * from a where id in (select id from b)当前子查询依赖于a表，也就是说得到结果 得全表扫描a表 然后匹配结果集是否满足。a表有多少条纪录，急需要执行多少次子查询。 DERIVED 表示临时表数据，即部分子查询被标记为衍生(DERIVED) UNION 若第二个SELECT出现在UNION之后，则被标记为UNION； UNION RESULT 从UNION表获取结果的SELECT table显示这一行数据是关于哪一个表的 typetype显示的是访问类型，是较为重要的一个指标，结果值从最好到最坏依次是：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL需要记忆的system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL一般来说，得保证查询至少达到range级别，最好能达到ref。 system 表只有一行纪录(等于系统表) const的特例 理解: 别人查出来的东西 只有一行 你继续查select * from (select * from table where id = 1) a;这种情况就会出现system const 表示通过一次索引即可获得数据 即主键索引或者唯一索引理解: 指定索引类型为主键索引或者是唯一索引时 查询会出现const eq_ref 唯一性索引扫描 对于每个索引键 表中只有唯一一条纪录与之匹配当多表连接查询时，连接条件都是主键索引或唯一索引时出现，即唯一 连接 唯一 会出现eq_ref ref 非唯一性索引扫描 返回匹配某个单独值得所有行当条件符合单列索引或者联合索引的最左字段时，此时type类型为ref range 只检索给定范围的行 一般是where条件出现非等值条件 如 in between and &gt; &lt;等当查询条件为索引列 且其是范围查询 则此时为type类型为range index当所查询的列，为主键 + 某一个索引的子集列， 那么就会走index，可以直接从索引中拿到所有数据 All需要扫描全表才能拿到所有的数据。 possible_key和key possible_keys: 可能使用的key，但不一定会被使用 Key: 实际使用的索引。如果为NULL，则没有使用索引。查询中若使用了覆盖索引，则此时key为使用到的索引而possible_key为null。若当前索引中的字段+主键 覆盖了所需要查询的字段，则走索引就可以查出，无需扫描全表。 key_lenKey_len表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的 key_len表示索引使用的字节数，根据这个值，就可以判断索引使用情况，特别是在组合索引的时候，判断所有的索引字段是否都被查询用到char和varchar跟字符编码也有密切的联系,latin1占用1个字节，gbk占用2个字节，utf8占用3个字节。（不同字符编码占用的存储空间不同）↓重点↓char 不为null 时候: Keylen=char(n) = n*(utf8=3,gbk=2,latin1=1)； char 允许为null 时候: Keylen=char(n)+允许Null=n*(utf8=3,gbk=2,latin1=1)+1 varchar 不为null 时候: Keylen=varchar(n)变长字段+不允许Null=n*(utf8=3,gbk=2,latin1=1)+2 varchar 允许为null 时候: Keylen=varchar(n)变长字段+允许Null=n(utf8=3,gbk=2,latin1=1)+1+2*↑重点↑ ref显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值 rows根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数 Extra包含不适合在其他列中显示但十分重要的额外信息。 Using filesort 会对数据使用一个外部的索引排序，无法利用索引完成排序。 Using temporary 使用了临时表保存了中间结果，MySql在对排序结果排序时 使用了临时表 Using index。 表示使用了覆盖索引。如果同时出现了 using where 表示索引被用来执行索引键值的查找，如果没出现 则表示索引用来读取数据，而非进行查找。 单表测试多表测试索引优化测试]]></content>
      <tags>
        <tag>面试 - MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql知识整理]]></title>
    <url>%2F2020%2F09%2F30%2FMysql%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[MySql的逻辑架构 Mysql的逻辑分层分为三层。 插件式的存储引擎架构将查询处理和其他的系统任务以及数据的存储提取相分离1、最上层为客户端层，并非MySQL所独有，诸如：连接处理、授权认证、安全等功能均在这一层处理。2、MySQL大多数核心服务均在中间这一层，包括查询解析、分析、优化、缓存、内置函数(比如：时间、数学、加密等函数)。所有的跨存储引擎的功能也在这一层实现：存储过程、触发器、视图等。3、最下层为存储引擎，其负责MySQL中的数据存储和提取。和Linux下的文件系统类似，每种存储引擎都有其优势和劣势。中间的服务层通过API与存储引擎通信，这些API接口屏蔽了不同存储引擎间的差异。不同引擎只会简单的响应上层服务器的请求，而不会相互通信。 1、连接层 最上层是一些客户端和连接服务，包含本地socket通信和大多数基于客服端/服务端工具实现的类似于TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了连接池的概念，为通过认证安全接入的客户端提供连接。同样在该层上可以实现基于SSL的安全连接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。 2、服务层 第二层架构主要完成大多数的核心服务功能，如SQL接口并完成缓存的查询，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定查询表的顺序，是否利用索引等。最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。 3、存储引擎层 存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己实际的业务需求来进行存储引擎的选取。 4、存储层 数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。 SQL语句的执行顺序设有如下sql1234567891011121314select distinct &lt;select_list&gt;from &lt;left_table&gt; &lt;join_type&gt; join &lt;right_table&gt; on &lt;join_condition&gt;where &lt;where_condition&gt;group by &lt;group_by_list&gt;having &lt;having_condition&gt;order by &lt;order_by_condition&gt;limit &lt;limit_number&gt; 其具体执行的顺序应为: 12345678910from &lt;left_table&gt;on &lt;join_condition&gt;&lt;join_type&gt; join &lt;right_table&gt;where &lt;where_condition&gt;group by &lt;group_by_list&gt;having &lt;having_condition&gt;selectdistinct &lt;select_list&gt;order by &lt;order_by_condition&gt;limit &lt;limit_number&gt; Mysql存储引擎Mysql 5.6支持的存储引擎我看可以看到comment中InnoDB是支持事务、行锁、以及外键的 且其实默认的存储引擎 InnoDB与MyISAM的区别 对比项 MyISAM InnoDB 外键 不支持 支持 事务 不支持 支持 行标锁 支持是表锁,即使操作一条纪录也会锁住整张表，不适合高并发场景 支持行锁,操作时只锁定某一行，不对其他行有影响，适合高并发的操作 缓存 只缓存索引、不缓存真实数据 不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响 表空间 小 大 关注点 性能 事务 默认安装 是 是 表的具体行数 保存表的具体行数，如执行select count(*) from table。会直接取到行数 没有保存具体行数，执行select count(*) from table会扫描全表。 索引索引类型 索引有很多种类型，可以为不同的场景提供更好的性能。在Mysql中，索引是在存储引擎层而不是服务器层实现的。所以并没有统一的索引标准：不同存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。 B-Tree索引 B-Tree索引的底层是使用B+Tree这个数据结构来储存数据的(即每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历)。大多数的MySQL存储引擎都支持这种索引。 对如下类型的查询有效 全值匹配。(是指和索引中所有的列进行匹配) 匹配最左前缀。(即只使用索引的第一列) 匹配列前缀。（只匹配某一列的值的开头部分。） 匹配范围值。 精确匹配某一列并范围匹配另外一列 只访问索引的查询 因为索引树中的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的order by操作(按顺序查找)。一般来说，如果B-Tree可以按照某种方式查找到值，那么也可以按照这种方式用于排序。所以，如果order by字句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求。下面是一些关于B-Tree索引的限制: 如果不是按按照索引的最左列开始查找，则无法使用索引。 不能跳过索引中的列。 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。 哈希索引 哈希索引是基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存只想每个数据行的指针。 空间数据索引 MyISAM表支持空间索引，可以用作地理数据存储。和B-Tree索引不同，这类索引无需前缀查询。空间索引会从所有维度来索引数据。查询时，可以有效地使用任意维度来组合查询。必须使用MySQL的GIS相关函数如MBRCONTAINS()等来维护数据。MySQL的GIS支持并不完善，所以大部分人都不会使用这个特性。开源关系数据库系统中对GIS的解决方案做的比较好的是PostgreSQL的PostGIS。 全文索引 全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。全文搜索和其他几类索引的匹配方式完全不一样。它有许多需要注意的细节，如停用词、词干和复数、布尔搜索等。全文索引更类似于搜索引擎做的事情，而不是简单的where条件匹配。 在相同的列上同时创建全文索引和基于值得B-Tree索引不会有冲突，全文索引适用于Match against操作，而不是普通得where条件操作。 其他索引类别 还有很多第三方的存储引擎使用不同类型得数据结构来存储索引。例如TokuDB使用分形树索引，这是一类较新开发的数据结构，既有B-tree得很多优点，也避免了B-Tree的一些缺点。 基本命令索引分类 主键索引：自动为主键创建的索引。 普通索引：使用字段创建的索引，包括单列索引和联合索引 唯一索引：字段的数据是唯一的且字段内容不能为null，允许存在多条唯一索引 全文索引：MyISAM支持全文索引 创建索引 单例索引 方式一:create index 索引名 on 表名(字段名); 方式二:alter table 表名 add index 索引名(字段名); 唯一索引 方式一:create unique index 索引名 on 表名(字段名); 方式二:alter table 表名 add index unique index 索引名(字段名); 组合索引 方式一:create index 索引名 on 表名(字段名1, 字段名2, 字段名3 .... ); 方式二:alter table 表名 add index 索引名((字段名1, 字段名2, 字段名3 .... ); 查看索引show index from 表名 删除索引drop index on 表名 索引的优点 索引可以让服务器快速地定位到表的指定位置。但这并不是索引的唯一作用，最常见的如B-Tree索引，按照顺序存储数据，所以MySQL可以用来做 order by 和 group by操作。因为数据是有序的，所以B-Tree也就会将相关的列值都存储在一起，如果待查询的列包含在索引中，则只需要走索引即可得到所查找的数据，无需回表进行查询。 索引大大减少了服务器需要扫描的数据量 索引可以帮助服务器避免排序和产生临时表 索引可以将随机IO变为顺序IO 索引选取的原则独立的列 如果不正确的使用索引，那么可能会造成索引失效。“独立的列”是指索引不能是表达式的一部分，也不能是函数的参数。例如select id from actor where id + 1 = 4;凭肉眼很容易看出where中的表达式等价于id = 4，但是MySQL无法自动解析这个方程式。这完全是用户行为，我们应该养成简化where条件的习惯，始终将索引列单独放在比较符号的一侧。下面是另一个常见的错误，会导致索引失效:select ... where to_days(current_date) - to_days(date_col) &lt;= 10; 前缀索引和索引选择性 索引的选择性是指: 不重复的索引值和数据表的纪录总数的比值，范围从1/n到1。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。 多列索引选择合适的索引列顺序]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中关于volatile的理解]]></title>
    <url>%2F2020%2F09%2F29%2FJava%E4%B8%AD%E5%85%B3%E4%BA%8Evolatile%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[基本概念 由于计算机的存储设备与运算速度之间有着几个数量级的差距，所以现在的计算机系统都会加入一层或多层的高速缓存(Cache)来作为内存与处理器之间的缓冲。将运算使用的数据复制到高速缓存中，尽可能让处理器处于计算运行状态，而不在等待io、网络等其他资源上。当运算结束后再将缓存同步到内存中，这样处理器就不需要等待缓慢的内存读写了。 基于高速缓存的存储交互很好的解决了处理器与内存速度之间的差距。但同时也引入了一个新的问题：缓存一致性。在多核心处理器系统中，每个处理器都有自己的高速缓存，而他们又共享着内存。在这种系统中，当多个处理器的运算任务都涉及从高速缓存写入共享内存操作时，那么究竟该以哪一个处理器为准呢？ 为了解决一致性的问题，处理器访问缓存时都遵循一些协议，在读写时要根据协议来操作，这类协议有MSI，MESI,MOSI等。 除此之外，为了使得处理器内部的运算单元尽可能被充分利用，处理器可能会对输入代码进行乱序执行优化，处理器会在计算之后将乱执行的结果重组，保证结果与顺序执行的结果是一致的，但并不保证程序中的各个语句计算的先后顺序与输入代码中的顺序一致，因此如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有指令重排序优化 Java内存模型（JMM 定义Java内存模型是为了屏蔽各种硬件与操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。 Java内存模型主要是定义程序中变量的访问规则，即在虚拟机中将变量存储到主内存或者将变量从主内存取出等这样的底层细节。这里的变量是指实例字段、静态字段、构成数组对象的元素，但不包括局部变量和方法参数等。可以简单地认为对于Java虚拟机而言，堆空间是共享的，所以在堆空间上存储的变量可能会涉及到多线程并行操作，而Java虚拟机栈是线程私有的，里面存储的变量就不会涉及到共享访问。 主内存 Java内存模型规定了所有的变量都存储在主内存中（物理上还是虚拟机内存的一部分），可以简单的认为其就是堆区。 工作内存 每条线程还有自己的工作内存（类比上文提到的高速缓存），线程的工作内存中保存了该线程使用的变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者之间的交互关系如图所示 与Java内存区域的区别 这里所说的主内存、工作内存与Java内存区域中的Java堆、栈、方法区等并不是一个层次的划分。这两者基本上是没有任何关系的。如果一定要勉强对应起来，那么从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。 内存间交互操作 关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存这一类的实现细节，Java内存模型中定义了以下8种操作来完成。Java虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的 lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。 unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。 load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。 assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。 write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中 如果要把一个变量从主内存拷贝到工作内存，那就要按顺序执行read和load操作，如果要把变量从工作内存同步回主内存，就要按顺序执行store和write操作。注意，Java内存模型只要求上述两个操作必须按顺序执行，但不要求是连续执行。也就是说read与load之间、store与write之间是可插入其他指令的，如对主内存中的变量a、b进行访问时，一种可能出现的顺序是read a、read b、load b、load a。除此之外，Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则： 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现。 不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use、store操作之前，必须先执行assign和load操作。 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作以初始化变量的值。 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。 volatile volatile关键字是Java虚拟机提供的最轻量级的同步机制。 当一个变量被定义为volatile之后，其将具备两个特性 保证此变量对所有的线程的可见性。 具体是指当一条线程修改了这个变量，新值对于其他线程来说是可以立即得知的。而普通的变量并不能做到这一点，普通变量的值在线程间传递时需要通过主内存来完成。比如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再对主内存进行读取操作，新变量值才会对线程B可见。但是并不是说加volatile关键字就可以保证原子性 由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized、java.util.concurrent中的锁或原子类）来保证原子性： 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。 变量不需要与其他的状态变量共同参与不变约束。 禁止指令重排序优化 普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。 volatile修饰的变量，会在指令层面添加内存屏障。]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Object类的内容整理]]></title>
    <url>%2F2020%2F09%2F26%2F%E5%85%B3%E4%BA%8EObject%E7%B1%BB%E7%9A%84%E5%86%85%E5%AE%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Object类经常实现的接口Comparable 和 Comparator 比较这两个接口都是常见的接口，但是具体的区别一直没有考虑过.两者之间的差异也没有考虑过。今天来学习一下 Comparable接口Comparable 是排序接口。若一个类实现了Comparable接口，就意味着“该类支持排序”。 即然实现Comparable接口的类支持排序，假设现在存在“实现Comparable接口的类的对象的List列表(或数组)”，则该List列表(或数组)可以通过 Collections.sort（或 Arrays.sort）进行排序。此外，“实现Comparable接口的类的对象”可以用作“有序映射(如TreeMap)”中的键或“有序集合(TreeSet)”中的元素，而不需要指定比较器。123public interface Comparable&lt;T&gt; &#123; public int compareTo(T o);&#125; 其需要实现CompaerTo方法 返回一个int值，假设我们通过x.compareTo(y) 返回 负数 则代表x &lt; y 返回 0 则代表 x = y 返回 正数 则 代表 x &gt; y Comparator接口Comparator 是比较器接口。我们若需要控制某个类的次序，而该类本身不支持排序(即没有实现Comparable接口)；那么，我们可以建立一个“该类的比较器”来进行排序。这个“比较器”只需要实现Comparator接口即可。也就是说，我们可以通过“实现Comparator类来新建一个比较器”，然后通过该比较器对类进行排序。123456public interface Comparator&lt;T&gt; &#123; int compare(T o1, T o2); boolean equals(Object obj);&#125; 其需要实现Compaer方法 返回一个int值，假设我们通过x.compare(y) 返回 负数 则代表x &lt; y 返回 0 则代表 x = y 返回 正数 则 代表 x &gt; y 比较Comparable是排序接口；若一个类实现了Comparable接口，就意味着“该类支持排序”。而Comparator是比较器；我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。我们不难发现：Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于面试的HashMap总结]]></title>
    <url>%2F2020%2F09%2F26%2F%E5%85%B3%E4%BA%8E%E9%9D%A2%E8%AF%95%E7%9A%84HashMap%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[HashMap的原理HashMap底层的数据结构1.8之前的实现方式主要参数 initialCapacity 初始数组长度 默认为16 loadFactor 负载因子 用来确定扩容阈值 默认为0.75 threshold 扩容阈值 当当前map中的节点数大于等于阈值时 可能会发生扩容操作 size 存储当前有多少个节点 modCount 与Fail-Fast 机制相关在jdk1.8之前是由数组+链表来实现。每一个键值对为一个Entry节点。通过对键的hash运算并于数组长度按位与之后得到该节点存储的下标位置并进行插入操作 采用的是头插法，其认为最新加进来的值可能会被使用，增加get的效率。其内部维护了size记录着当前节点数，如果大于阈值且当前下标位置不为空则会进行resize操作，数组的长度会变为原来的二倍。 1.8的实现方式主要参数 initialCapacity 初始数组长度 默认为16 loadFactor 负载因子 用来确定扩容阈值 默认为0.75 threshold 扩容阈值 当当前map中的节点数大于等于阈值时 可能会发生扩容操作 size 存储当前有多少个节点 modCount 与Fail-Fast 机制相关 TREEIFY_THRESHOLD 链表变红黑树的阈值 默认为8 UNTREEIFY_THRESHOLD 红黑树变链表的阈值 默认为6 在jdk1.8中是由数组+链表+红黑树来实现。每一个键值对为一个Node或者TreeNode节点。通过对键的hash运算并于数组长度按位与之后得到该节点存储的下标位置并进行插入操作 采用的是尾插法，其内部维护了size记录着当前节点数，如果大于阈值且当前下标位置不为空则会进行resize操作，数组的长度会变为原来的二倍。且当put的时候，如果当前下标位置还是链表的话，会判断当前链表长度是否 大于8 来判断是否需要进行树化，当table为空 或者 数组长度 &lt; 64 则会进行扩容操作， 其他情况才会进行树化操作。 Hash冲突的解决办法开放地址法 开放地址法 线性探测 在原有的基础上向后移一个单位，直到不冲突即可 再平方法 在原来值的基础上先加1的平方个单位，若仍然冲突则减1的平方个单位。随之是2的平方，3的平方等等。直至不发生哈希冲突。 链地址法 对于相同的值，使用链表进行连接。使用数组存储每一个链表。 再哈希法 对于冲突的哈希值再次进行哈希处理，直至没有哈希冲突。 用LinkedList代替数组结构可以吗？是可以的，但是由于LinkedList并不支持随机访问，所以即使我们可以通过hash确定下标，但也需要O(n)的时间去找到存储的位置，与HashMap的高效查找不符。 TreeMapTreeMap底层不同与HashMap，其底层是由红黑树来实现的，其默认是以键值升序存储的。他的get,put,remove等操作都是O(logn)的复杂度 相对而言不如哈希表高效。 LinkedHashMap其保证了插入与取出的顺序是一致的。 CurrentHashMapp我们知道 HashMap TreeMap LinkedHashMap都是线程不安全的，当其应用于多线程并发的场景 会出现数据丢失，数据错误等情况。 我们可以使用HashTable、CurrentHashMapp等线程安全的集合容器。HashTable是底层的get、put、remove等方法添加了Synchronized，保证多线程并发情况下只有一个线程操作。而CurrentHashMapp是使用分段锁机制来保证线程安全的 HashMap的resize条件扩容条件扩容发生在put方法中，当table为空或长度为0时 会发生resize，节点数大于threshold也会触发扩容操作 为什么扩容是原容量的2倍因为HashMap确定某个键值对的下标是通过hash(key)与length-1做按位与操作，2的幂可以保证lenth-1低位都为1，所以决定位置只与hash(key)的值有关，可以使得分布更加均匀。 HashMap的put与get过程put的过程 会调用内部的putVal 方法 判断当前table是否为空或者长度是否为0 如果是则 resize 根据hash(key) &amp; (length - 1)得出下标，如果table[index] == null 则直接将table[index] = new Node() 接着判断 当前已存在的元素的hash值与key的hash值与地址值或equals判断是否相对 来判断是否是同一键值 判断当前节点所在结构是否是红黑树结构 如果是红黑树结构则调用红黑树的putTreeVal方法 跑以下链表 判断当前是否是最后一个节点 如果是 则将当前的next指针赋为new Node。并判断当前链表的长度是否大于树化阈值，如果大于 则进行树化操作(当然 不一定会树化 如果table == null || length &lt; 64 则进行resize操作 判断当前节点是否与key相等，相等则保存旧的Node节点 跳出循环 判断当前的key值是否被存储过，如果存储过，则将value替换 返回旧的value 否则就是添加新值 modCount++, size++， 并判断size是否大于阈值 大于则会进行resize操作 返回旧的value get的过程 会调用内部的getNode方法参数为hash(key)和key 判断当前table是否为空 或者 长度是否为0 或者 hash(key) &amp; (lenth -1 ) == null 如果有一条满足 则返回null 首先判断数组中的节点与key的关系 如果地址值相同或者equals方法判断相等 则直接返回 判断当前节点是否有下一项节点 如果没有 则返回null 如果有 则判断当前下标存储的节点结构是不是红黑树 如果是 则调用getTreeNode方法在红黑树中进行查找 否则 则会跑当前链表判断是否有相同的key值 找到返回 没找到返回null HashMap 1.7与1.8的不同 1.7底层是由数组+链表实现 1.8是由数组+链表+红黑树实现 1.7使用的是头插法 1.8使用的是尾插法 HashMap的并发问题HashMap在并发环境下，1.7和1.8分别可能出现什么问题？1.7 数据丢失 死循环等问题由于1.7使用的是头插法。当两个线程都处于resize阶段，都会new 一个newTable出来，当转移数据transfer时可能会出现链表成环的情况，导致下一次get一个未存储在map中的key时可能会死循环。且resize过程和transfer过程返回的是最后一个线程对table的赋值 会出现数据丢失的问题 1.8 数据覆盖1.8采用尾插法，可以解决链表成环的问题。但依然不是线程安全的，当并发情况下，可能会存在多个线程同时对table赋值，出现线程不安全的情况。 线程安全的map类HashMap的键值可以为null吗 TreeMap、HashTable、LinkedHashMap呢HashMap 键和值都允许为null，当键为null时 其hash(key) = 0 存放位置为table[0]的位置 TreeMap 构造参数没有给定Comparator接口的实现对象是 不支持空的键 但支持空值因为其底层是通过红黑树来实现的，需要由构造函数给定Comparator的实现才可以进行比较；默认的比较器是null，给进来的key会判断当前比较器是否是空，如果为空的话，则进行调用key.compareTo()方法。此时key为空就会出现空指针异常。如果制定了比较器，则调用比较器的compare方法比较 即使给定了比较器 没有对键为 null值做特殊处理也会报空指针异常 LinkedHashMap 键值都可以为null]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[秋招网易Java开发凉经(2020年9月25日]]></title>
    <url>%2F2020%2F09%2F25%2F%E7%A7%8B%E6%8B%9B%E7%BD%91%E6%98%93Java%E5%BC%80%E5%8F%91%E5%87%89%E7%BB%8F(2020%E5%B9%B49%E6%9C%8825%E6%97%A5%2F</url>
    <content type="text"><![CDATA[一面自我介绍面试官: 你先做个简单的自我介绍吧我:简单的介绍了学校，专业，在校期间参与的比赛与项目.(我说了大学期间主要打比赛，项目比较薄弱. 项目介绍面试官: 介绍一下你的项目及其背景吧我: 巴拉巴拉面试官: 你这个项目的难点是什么我: 我做的东西比较简单，主要是解决了自己的实际需求以及练手了一下实际的JavaWeb项目的开发流程.面试官: 好的,了解了，那我们先做两道题吧。我: 好 手写算法链表反转面试官: 写一个链表反转吧我:12345678910111213public Node reverse(Node head) &#123; if(head == null) return head; Node now = head; Node pre = null; while(now != null)&#123; Node tmp = now.next; now.next = pre; pre = now; now = tmp; &#125; return pre; &#125; 面试官: 你解释一下你的代码吧我: 逐行给他解释了一下， 就不断的改变当前节点的next指针的指向，直到当前节点为空节点为止。面试官: 好的 二叉树的最大深度面试官: 二叉树的最大深度 你先说一下思路吧我: 这个我们可以递归做 递归出口就是当前到达了空节点 返回0 否则 返回1 + 左右子树深度的较大值即可面试官: 你写一下吧我:12345public static int dfs(TreeNode root)&#123; if(root == null) return 0; return 1 + Math.max(dfs(root.left), dfs(root.right)); &#125; 面试官: 你解释一下吧我: 就是当前到达空节点， 返回0 否则返回当前层 + 左右子树的较大深度。 二分查找面试官：你说一下二分查找吧我: 二分查找一般应用于某一条件可以将数据分为两部分，如大于，小于等条件。 一般二分查找作用于有序的数组中，我们可以根据targer于arr[mid]的关系，将数据分为两部分，进而加速我们查找的过程。朴素的遍历需要o(n)的复杂度，而二分可以降到O(logn)的级别。大概就是这样，需不需要我手写一下？面试官: 不用了，二分查找比较简单，我们接下来说一下Java基础吧.我: 好的 Java基础for循环遍历和迭代器遍历有啥区别面试官: 我们遍历List集合，用for和 冒号for 有啥区别我: 我没太理解您意思，您能举个例子吗? (确实是我菜面试官: 就比如123 for(int i = 0; i &lt; list.size(); i++)和 for(Object o : list) 这两种方式有什么区别我: 这个我不太知道. 我只知道用定义i这种底层也是调用get方式进行返回并输出，冒号for这种实现了Iterator接口. （这里应该是实现了Iterable接口, 重写了Iterator方法面试官: 你后期可以去了解一下 后期补充答案 foreach适用于只是进行集合或数组遍历，for则在较复杂的循环中效率更高。 foreach不能对数组或集合进行修改（添加删除操作），如果想要修改就要用for循环。 说一下HashMap中put一个值的具体过程面试官: 你说一下HashMap中put一个值的具体过程我: 好的，HashMap put的时候会根据key值计算其HashCode，并通过按位与length-1确定下标.因为底层是数组+链表或者数组+红黑树来实现的。如果所加到的index没有元素则直接插入，否则会判断当前有没有这个key，有的话覆盖，没有的话插入。( 完全是瞎说… 后期补充答案 以下内容针对jdk8 put(key, value)中直接调用了内部的putVal方法，并且先对key进行了hash操作； putVal方法中，先检查HashMap数据结构中的索引数组表是否位空，如果是的话则进行一次resize操作； 以HashMap索引数组表的长度减一与key的hash值进行与运算，得出在数组中的索引，如果索引指定的位置值为空，则新建一个k-v的新节点； 如果不满足的3的条件，则说明索引指定的数组位置的已经存在内容，这个时候称之碰撞出现； 在上面判断流程走完之后，计算HashMap全局的modCount值，以便对外部并发的迭代操作提供修改的Fail-fast判断提供依据，于此同时增加map中的记录数，并判断记录数是否触及容量扩充的阈值，触及则进行一轮resize操作； 在步骤4中出现碰撞情况时，从步骤7开始展开新一轮逻辑判断和处理； 判断key索引到的节点（暂且称作被碰撞节点）的hash、key是否和当前待插入节点（新节点）的一致，如果是一致的话，则先保存记录下该节点；如果新旧节点的内容不一致时，则再看被碰撞节点是否是树（TreeNode）类型，如果是树类型的话，则按照树的操作去追加新节点内容；如果被碰撞节点不是树类型，则说明当前发生的碰撞在链表中（此时链表尚未转为红黑树），此时进入一轮循环处理逻辑中； 循环中，先判断被碰撞节点的后继节点是否为空，为空则将新节点作为后继节点，作为后继节点之后并判断当前链表长度是否超过最大允许链表长度8，如果大于的话，需要进行一轮是否转树的操作；如果在一开始后继节点不为空，则先判断后继节点是否与新节点相同，相同的话就记录并跳出循环；如果两个条件判断都满足则继续循环，直至进入某一个条件判断然后跳出循环； 步骤8中转树的操作treeifyBin，如果map的索引表为空或者当前索引表长度还小于64（最大转红黑树的索引数组表长度），那么进行resize操作就行了；否则，如果被碰撞节点不为空，那么就顺着被碰撞节点这条树往后新增该新节点； 最后，回到那个被记住的被碰撞节点，如果它不为空，默认情况下，新节点的值将会替换被碰撞节点的值，同时返回被碰撞节点的值（V）。 面试官: 那我们put可变对象会不会出现问题？我: 我没太理解您意思，你能举一个例子吗?面试官: 就比如我put一个学生之后，这个学生的姓名改变了，会出现问题吗？我: 这个… 我猜他的HashCode值变了，可能无法get到已put过的key值了面试官: 这个你后期去了解一下吧 后期补充答案HashMap而言，其get和put会依赖于对象的HashCode和equals方法。若是可变对象，我们修改了某些属性，那么对于其的HashCode必然会发生改变。此时会出现 get不到已经put过的value，因为HashMap会根据hash(key) &amp; length - 1，确定下标位置，HashCode的改变致使桶的下标位置不同，从而找不到已经put的value值其实这样也是可以接受的，毕竟对象重新设置了某些字段的值，其就算是一个新的对象了，如果这样考虑的话，那么还会出现一种情况 没有put过的对象，可以获取到value，试想 当重新设置了字段的值之后，当新的HashCode与原来的HashCode值相等，那么 就会满足 HashCode相等而且 key也是同一块地址。 致使原来put进去的值被返回. 面试官: (他可能感觉到我的水平太差了，) 说那你并发编程这块和锁这块cas之类的也不熟悉是吧我: 并发只在本机测试过一些机制，没在项目中使用过.面试官: 好的,了解了 看我Java基础太菜了 又问了一道Linux的问题 你熟悉的Linux命令有哪些面试官: 你在Linux环境下会那些操作我: 主要是 安装 卸载软件, 已经vi的编程。 因为学生机是单核的，会测试一些在并发编程下与本机的区别面试官: 那你说一下 我要在某个目录下搜索文件 命令应该是咋样写的?我: ….. 就只记得是find 后面的参数忘了面试官: 好的 后期补充答案 查找目录：find /（查找范围） -name ‘查找关键字’ -type d 查找文件：find /（查找范围） -name 查找关键字 -print 是在太菜了 就有让我写了两道题 手写算法给定两棵树，询问一棵树是否完全可以覆盖另一颗树面试官：你先说一下思路吧我: 跑一下a树的所有节点，然后判断当前跑的这个节点是否和b树是相同的面试官: 那你实现一下吧我:123456789101112131415161718192021222324public static boolean fun(TreeNode a, TreeNode b)&#123; if(a == null &amp;&amp; b == null)&#123; return true; &#125; else if(a == null &amp;&amp; b != null)&#123; return true; &#125; else if(a != null &amp;&amp; b == null)&#123; return false; &#125; else &#123; return check (a, b) || fun(a.left, b) || fun(a.right, b); &#125; &#125; public static boolean check(TreeNode root1, TreeNode root2)&#123; if(root1 == null &amp;&amp; root2 == null)&#123; return true; &#125; else if(root1 != null &amp;&amp; root2 != null)&#123; if(root1.val == root2.val)&#123; return check(root1.left, root2.left) &amp;&amp; check(root1.right, root2.right); &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; 面试官: 解释一下吧我: 大概解释了一下，中途出现了某些问题 然后改了一下， 面试官是 嗯 可以了 应该不会有大的问题 可能有些特殊情况还是有问题. 一道dp面试官: 最后写一个题吧， 可能对你就比较容易了。有一个三角形a,b,c三个点， 初始在a点，走一步只能到b点或者c点。走两步可以回到a点，即a-&gt;b-&gt;a或者a-&gt;c-&gt;a。 然后询问走100步有多少种办法回到a点, 我: 我想一下啊 这肯定是要用dp来写， 然后大概推了下 dp[i][j] 表示第i步走到j点的方案数.0代表a点,1代表b点，2代表c点;那么 a点 c点 c点 dp[1][0] = 1 dp[1][1] = 1 dp[1][2] = 1 dp[2][0] = dp[1][1] + dp[1][2] = 2 dp[2][1] = dp[1][0] + dp[1][2] = 1 dp[2][2] = dp[1][0] + dp[1][1] = 1 所以转移方程就是 dp[i][j] = sum(dp[i - 1][!j])；初始条件就是 dp[0][0] = 1. 然后转移即可面试官: 好了 可以了 你有什么想问我的 反问面试官: 好了 可以了 你有什么想问我的我: 我确实太菜了 可能还是要春招了 您对我复习有什么建议吗? 面试官: 作为校招生 你要加强基础知识，如刚才问你的for和冒号for的区别。如果是社招的话直接卡，但是校招的话 我们还是考虑你的潜力，在集合 并发 以及锁这块要深入的理解 多看底层源码 框架方面的话 如Spring 有经验的话更好，但是相对而言还是把计算机基础打扎实了更好。 我: 好的，谢谢你面试官: 那我们今天就到这里 一面总结经历了好几场面试的一轮游，网易甚至不想面了。面试官是一个很好的面试官，问到不会的也就不会深挖了，挑我熟悉的算法题去做。最后的反问环节给了我很多建议，也讲了并不是面试造火箭，入职拧螺丝。确实是不能做api调用者，有时候我们必须要修改源码 或者 自己造轮子。我们必要要拥有这个能力。 确实感受到自己的实力不足，好好学习，备战春招 二面自我介绍面试官: 你先做个简单的自我介绍吧我:简单的介绍了学校，专业，在校期间参与的比赛与项目.(我说了大学期间主要打比赛，项目比较薄弱. 为什么从C++转Java？ 你感觉C++和Java的区别？ 为什么不考研项目面试官：大文件如何在不同主机间传输？ 效率、文件的完整性面试官：Http缓存 比如图片它是如果确定是要重新获取还是加载缓存？面试官：不同主机如何传输目录 保证接收端的目录结构面试官：给定一个字符串 只有加减运算 考虑所有异常 返回结果二面总结真的被网易的面试官圈粉了，一个个都太强了。最后建议加强基础知识，以及劝我考研。面试官很年轻啊，感觉30不到，但是真的太强了。除了太强了无话可说。]]></content>
      <tags>
        <tag>-面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程池的基本用法(2020年9月21日]]></title>
    <url>%2F2020%2F09%2F21%2FJava%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95(2020%E5%B9%B49%E6%9C%8821%E6%97%A5%2F</url>
    <content type="text"><![CDATA[基本使用Executors创建线程池 通常使用线程池是应用jdk所提供的Executors类中的静态方法即可获取ExecutorService对象应用相关方法调度线程进行工作; 方法名 功能 具体情况 Executors.newCachedThreadPool() 创建一个带缓存的线程池 若已创建出来的线程可供使用则复用，否则会新建线程来提供服务，没有线程创建的上限。 Executors.newFixedThreadPool(10) 创建一个指定线程数量的线程池 核心线程数和最大线程数皆为指定参数，当没有线程可供提供服务则进入阻塞队列，当阻塞队列满后会触发相关的拒绝策略 Executors.newSingleThreadExecutor() 创建只有一个线程的线程池 线程空闲则服务，否则进入无界阻塞队列进行顺序执行 自定义参数创建线程池Executors中创建的线程池的办法，其底层实现还是调用了ThreadPoolExecutor的构造方法,而定时任务线程池中调用的是newScheduledThreadPool的构造方法.,该类的全参构造函数如下jdk1.8123456789101112131415161718192021222324public ThreadPoolExecutor(int corePoolSize, // 核心线程数 即使空闲 也不会被回收 int maximumPoolSize, // 最大线程数量 long keepAliveTime, // 超过corePoolSize的线程空闲回收时长 超过这个值 将会被回收 TimeUnit unit, // 回收时长的单位 BlockingQueue&lt;Runnable&gt; workQueue, // 任务的等待队列 ThreadFactory threadFactory, // 新线程的创建方式 可选 RejectedExecutionHandler handler) &#123; // 拒绝策略 if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125; 一般自定义的线程池主要看中的参数有: corePoolSize 核心线程数量 maximumPoolSize 最大线程数量 workQueue 任务的等待队列 handler 拒绝策略 线程池的工作顺序当一个新任务添加到线程池中,首先会判断当前使用的线程数与核心线程数的大小关系，若有核心线程空闲，则核心线程提供服务。 当所有核心线程均有任务时，此时会优先将任务添加到等待队列。当等待队列也满的时候，则会创建新的线程提供服务。当现在运行线程已到达最大线程数且等待队列也是满的情况，则应用相关的拒绝策略对当前任务进行拒绝。 图片描述]]></content>
      <tags>
        <tag>-Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019ACM西安邀请赛总结]]></title>
    <url>%2F2019%2F05%2F21%2F2019acm%E8%A5%BF%E5%AE%89%E9%82%80%E8%AF%B7%E8%B5%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[第二次打西安邀请赛了，可能去年锅比较多然后强队比较少，我竟然抱着拿银的期望去打；希望自己在这场中可以赢(银)。 然鹅实力限制了我，拿铜滚粗了； 热身赛第一天的热身赛还是很愉快的，热身A题属于基础题，丢给了Euphoria拆成两个三角形做，然后我和yyc去看B题，读题就浪费了很久的时间，看了他的样例，我直接感觉输出“Yes”即为答案；Euphoria的A题写完后交了一发wa掉了。立刻想到有没有点重合的可能，然后就询问yyc，回答：可能重合。于是Euphoria用set去重，然后判断set.size(), 当4个点时，两个三角形求和，3个点时，直接求面积，小于等于2个点时，输出0.0. 然后又想到可能是凹的四边形或者凸的四边形。 让他同时连接ac与bd， 计算四个三角形面积。然后求和取min即可；交上去还是wa了。 他下机，我去上写了全都输出“Yes”的B， 很开心的wa了。 然后我改他的代码，他写了 ios::sync_with_stdio(false); 但是读入测试用例N的时候是用scanf读入的，其他东西用cin读入的。 我改了改交了， yes； （！！！ 关了流同步， 千万别混用scanf和cin， printf和cout）； 然后一起看B题，手推了一下； 我竟然觉得当n == 1时，只有 val == 4 || val == 2400 || val == 567 || val == 24才输出Yes，其他都是No。 当n等于其他值时，都是Yes， 这样交了一发， 还是wa； 无奈，开c题， Euphoria推出了中缀表达式， 最后需要解决的就是中缀表达式的计算。 但是没带板子，手打又不会。。。 这时，隔壁队已经ak准备走了，我上去讨教了一下b的做法，只有n == 1 &amp;&amp; （val == 0 || val == 1 || val == 2）时输出No，其他都是Yes； 我们真是菜呀，这都没推出来； 因为只有2！ = 2， 3！ &gt; 3， 所以大于等于3的一定可以更大，然后操作符又那么多，所以一定可以生成24. 当n &gt;= 2时，完全可以一个除以100，另一个在除以前面那个除过100的数变得更大，然后哦也可以进行操作了；我们是弟弟呀； 热身赛打完看绑，我们铜牌都没得； 要被打爆了；C题大佬们是用Python交的， 太强了； 正赛正赛我们带了一堆板子，最后也没用上；正赛偷偷看了准备气球的地方，发现橘色可能是签到(最后发现意义不大)； 然后开赛前10min左右就开始公布账户名和密码， 然后当然是建项目写头文件呀；A题我看了下题，直接给他们说我写， 然后就上去写了， 火速写完后，准备交的时候，对面说了句”Wa了”， 我当时就有点慌，怕题目有坑，或者题目不简单。 赶紧刷了下榜，已经是一片绿了； 不怂，直接交了，然后过了；过了之后一边其他题目一边在刷榜，直到第10min，有队伍过了M， 还有很多队伍交L， 理解了一下题意，和Euphoria交流，觉得这个铁定是规律题，我给他说，我打一下表， 当时可能有点紧张，这么简单的模拟我竟然写出了bug，大概调了20min左右，期间wxh和我要机位，我说大哥你等等我，求你了。 哈哈哈哈，他也无奈，终于打出了表，我看了看规律，发现这规律不好找啊， 只有4的倍数是4， 其他的有的是2倍有的还不是； wor， 然后直接笨蛋测了几组样例，发现跑得速度还可以(热身赛测的评测鸡可以跑5e9)。我就给Euphoria说，我想莽一发，答:10000的范围，你咋莽。 我给他测了两组， 我说：咋不能莽；然后开启莽夫行为， 直接暴力交了； 你猜结果咋样？ 1A了， woc，当时还是很激动的，刷了下榜Rank50呀，当时就觉得银有希望； 这时候wxh和yyc已经大概推出了c题（样例有锅），然后Euphoria上去写了； 大概30min左右就调好了， 测了样例都没错，就交了； 返回Wa。 然后看了看公告，说是有问题，继续改，交， 又Wa。 然后他又改了改， 我当时想，这发不过就打印代码吧。 然后交了就过了！ 囍， 此时Rank好像是78左右的样子； 银牌还是有的； 我们觉得手速把M开了就稳了呀！ 然鹅，看着榜上100+队伍过了M，我们却不知道M是啥子意思； 哎，自闭三小时，期间我准备开D， 发现实力不够呀，不知道如何处理冲突，还是菜呀； 期间甚至不想打acm了， 当时200多队过了M，我们却不会，自闭的要死； 三题终….万幸罚时好一点，铜牌倒数第四溜了； 只能说运气好， 省赛加油吧；]]></content>
      <categories>
        <category>比赛总结</category>
      </categories>
      <tags>
        <tag>-第44届ACM亚洲区域赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[均分纸牌(线性、环形、二维)]]></title>
    <url>%2F2019%2F05%2F06%2F%E5%9D%87%E5%88%86%E7%BA%B8%E7%89%8C%2F</url>
    <content type="text"><![CDATA[感觉好久没写博客了…. 题目描述有N堆纸牌，编号分别为1,2,…,N。每堆上有若干张，但纸牌总数必为N的倍数。可以在任一堆上取若干张纸牌，然后移动。 移牌规则为：在编号为1堆上取的纸牌，只能移到编号为2的堆上；在编号为N的堆上取的纸牌，只能移到编号为N-1的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。 现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。 例如N=4，4堆纸牌数分别为：①9 ②8 ③17 ④6移动3次可达到目的：从 ③ 取4张牌放到 ④ （9,8,13,10）从 ③ 取3张牌放到 ②（9,11,10,10）从 ② 取1张牌放到①（10,10,10,10）。 思路这一题还是比较容易的，考虑到第一堆只能给第二堆若干张或者由第二堆给第一堆若干张。所以当确定了第一堆的状态后，第二堆就变成了新的第一堆。按照上面的思想依次考虑即可; 所以代码也不难写，只需要从第一堆开始判断拥有的牌数是不是平均值，如果是均值则跳过，如果不是则需要的移动次数加1; 时间复杂度为O(n)；点此交题：均分纸牌 参考代码12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n, ans = 0, ave, cnt = 0; cin &gt;&gt; n; vector&lt;int&gt; a(n + 1), sum(n + 1); for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; cnt += a[i]; &#125; ave = cnt / n; sum[0] = 0; for(int i = 1; i &lt;= n; i++) &#123; sum[i] = sum[i - 1] + a[i] - ave; if(sum[i]) ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; PS:稍微偏偏题；这样的思路可以很快的的解决一些区间类的问题。例如：说实话，这题我思考了好久都没有好的做法(可能是太蠢了…正解是你考虑最左边的元素只能选取(1 ~ k)这一段进行减操作，所以对1进行的减操作就是a[1]次，然后依次考虑第2位、第3位是否满足 &lt;=0, 若满足则跳过 不满足则对区间 (i ~ i + k)进行 减 a[i]操作即可；也是O(n)的复杂度;代码就大家自己实现一下吧; OK,回到正题，上面我们所说的就是简单的线性的均分纸牌问题；接下来我们说说环形的均分纸牌问题； 题目描述还是刚才的问题，只不过是刚才是线性的，现在变成了一个环； 即第一个人可以将自己的牌给最后一个人，也可以从最后一个人哪里拿牌； 最后一个人同理； 询问这个时候需要的最小代价； PS：稍稍有点不同是上面那题询问的是最少的操作次数，这道题问的是最小的代价(挪动一张牌的代价为1); 若刚才那题改为求最小代价的话，思路还是一样的，因为第一堆只能由第二堆（获得或给予）得到均值； 考虑一下如果是环形改为求最小移动次数又该咋样做呢？ 思路OK,我们如何解决这道看似很难得题目呢？我们在做环形的题目时候有种经常使用的解法是将环形拆分为线形；(如：环形的石子合并，环形的打家劫舍…)此题当然也可以将环形拆分为线形； 有一个结论是 在均分纸牌的过程中，肯定有一个人是不参与的(躺赢Orz 因为当其他n - 1都处于均值是，则第n个人必定处于均值； 至于为啥？ 你可以问问神奇的海螺(逃. OK,那我们可以枚举一下那一项不进行参与，然后从这个点将环断开；(这里不理解的，可以考虑上一题最后一个人就是躺赢的，他啥都没做就满足条件了)。然后O(n)扫出此时的最小代价； 然后维护一个最小代价即可;时间复杂度是O(n*n)的； 然鹅 这题的数据范围是1000000,时限是1000ms。 n方复杂度肯定会超时的；那我们如何优化呢？我们可以先对每一堆牌减去均值。 然后求出一个前缀和；试想，假如sum[i] = 0, 那是不是代表着 前 i - 1项可以通过某种方式使得前i - 1项都处于均值呢？ 答案是肯定的。 所以 我们最后只需要得到 所有前缀和绝对值的和即可; 我们先来看看线性的均分纸牌，让我们对这个有个比较直观的认识;假设 A数组存储的是减去均值后的纸牌个数。 S数组储存的是前缀和(减去均值的前缀和) A[1] S[1]A2 S2A[3] S[3]… …A[n] S[n] 我们可以显然得到，当某个 S[i]不等于0时，那代表我 前 i - 1项肯定不能自给自足，还需要第i给贡献或者拿走一部分； 所以我们求出这样的一个前缀和， 然后对这个前缀和数组进行求绝对值的和就是线性的最小代价； 要求最小移动次数就是 S[i]不为0 则需要移动； 我们假设我们的断开点是k点那么减去均值和得到的前缀和数组就是 A[k + 1] S[k + 1] - S[k]A[k + 2] S[k + 2] - S[k]A[k + 3] S[k + 3] - S[k]… …A[n] S[n] - S[k]A[1] S1 + S[n] - S[k]A2 S2 + S[n] - S[k]… …A[k] S[k] + S[n] - S[k] 考虑到最后一项 即现在的k是躺赢的人， 所以肯定有 S[k] + S[n] - S[k] = 0;所以 S[n] = 0;将式子中的S[n]替换为0，原式可以改写为: A[k + 1] S[k + 1] - S[k]A[k + 2] S[k + 2] - S[k]A[k + 3] S[k + 3] - S[k]… …A[n] S[n] - S[k]A[1] S1 - S[k]A2 S2 - S[k]… …A[k] S[k] - S[k] 显然，这题变成了， 求一个数组中的点， 使得到达其他所有点的距离和最小的问题；(显然是中位数，至于为啥。假设我们选择的点 左边有 a个点 右边有 b个点 a &gt; b, 那么我们每向左移动一个单位，则距离和减少 a - b；当a &lt; b 也是同理；所以我们只有把选择的点选取为中位数的时候可以保证答案最优; 这道题也是一样的， 我们求出来的前缀和数组可以看做是上面的数组； 我们选取一个前缀和的中位数， 然后求一下当前点到其他点绝对值的和就是答案啦； 交题点此: 环形均分纸牌 参考代码12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX_N 1000010int a[MAX_N], sum[MAX_N];int main()&#123; int n; cin &gt;&gt; n; sum[0] = 0; long cnt = 0; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; cnt += a[i]; &#125; int age = cnt / n; for(int i = 1; i &lt;= n; i++) &#123; a[i] -= age; sum[i] = sum[i - 1] + a[i]; &#125; sort(sum + 1, sum + 1 + n); int mid = (n + 1) &gt;&gt; 1; long long ans = 0; for(int i = 1; i &lt;= n; i++) &#123; ans += abs(sum[i] - sum[mid]); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 二维均分纸牌有人看的话我在更新…]]></content>
      <categories>
        <category>算法竞赛进阶指南</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>中位数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下的进程浅谈（二）]]></title>
    <url>%2F2019%2F04%2F05%2Ffork1%2F</url>
    <content type="text"><![CDATA[进程共享父子进程之间在fork后。有哪些相同，那些相异之处呢？刚fork之后：父子相同处: 全局变量、.data、.text、栈、堆、环境变量、用户ID、宿主目录、进程工作目录、信号处理方式… 父子不同处: 1.进程ID 2.fork返回值 3.父进程ID 4.进程运行时间 5.闹钟(定时器) 6.未决信号集 子进程复制了父进程0-3G用户空间内容，以及父进程的PCB，但pid不同。真的每fork一个子进程都要将父进程的0-3G地址空间完全拷贝一份，然后在映射至物理内存吗？当然不是!父子进程间遵循读时共享写时复制的原则。这样设计，无论子进程执行父进程的逻辑还是执行自己的逻辑都能节省内存开销。 验证父子进程是否共享全局变量和局部变量12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int a = 0; // a 为全局变量 测试 全局变量父子进程是否共享int main()&#123; pid_t pid; // 定义返回值类型接受fork返回值 int b = 0;// b为局部变量 测试局部变量父子进程是否共享 pid = fork(); if(pid == -1)// fork失败返回-1 &#123; perror("fork error:"); &#125; else if(pid == 0)// 子进程 &#123; a += 1; b += 2; printf("我是子进程 a = %d, b = %d\n", a, b); &#125; else// 父进程 &#123; sleep(2);// 让父进程睡2s 保证子进程先结束 a += 3; b += 4; printf("我是父进程 a = %d, b = %d\n", a, b); &#125; return 0;&#125; 由实验结果不难发现，父子进程既不共用全局变量也不共用局部变量; exec函数族fork创建子进程后执行的是和父进程相同的程序（但有可能执行不同的代码分支），子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用exec并不创建新进程，所以调用exec前后该进程的id并未改变。将当前进程的.text、.data替换为所要加载的程序的.text、.data，然后让进程从新的.text第一条指令开始执行，但进程ID不变，换核不换壳。其实有六种以exec开头的函数，统称exec函数：123456int execl(const char *path, const char *arg, ...);int execlp(const char *file, const char *arg, ...);int execle(const char *path, const char *arg, ..., char *const envp[]);int execv(const char *path, char *const argv[]);int execvp(const char *file, char *const argv[]);int execve(const char *path, char *const argv[], char *const envp[]); execlp函数加载一个进程，借助PATH环境变量1int execlp(const char *file, const char *arg, ...); 成功：无返回；失败：-1 参数1：要加载的程序的名字。该函数需要配合PATH环境变量来使用，当PATH中所有目录搜索后没有参数1则出错返回。 该函数通常用来调用系统程序。如：ls、date、cp、cat等命令。execlp函数示例12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main()&#123; pid_t pid; // 定义返回值类型接受fork返回值 pid = fork(); if(pid == -1)// fork失败返回-1 &#123; perror("fork error:"); &#125; else if(pid == 0)// 子进程 &#123; execlp("ls", "ls","-l", "-a", NULL); &#125; else// 父进程 &#123; sleep(2);// 保证子进程先结束 printf("我是父进程\n"); &#125; printf("6666\n"); return 0;&#125; 运行结果 我们可以发现，子进程确实执行了ls -l -a 这条命令，而且pintf(“6666\n”)这条语句只执行了一次，说明调用了exec函数后，里面的代码段全部更换了; execl函数加载一个进程， 通过 路径+程序名 来加载。1int execl(const char *path, const char *arg, ...); 成功：无返回；失败：-1 对比execlp，如加载”ls”命令带有-l，-F参数execlp(“ls”, “ls”, “-l”, “-F”, NULL);使用程序名在PATH中搜索。execl(“/bin/ls”, “ls”, “-l”, “-F”, NULL); 使用参数1给出的绝对路径搜索。也就是说execlp更换的一般都是系统的程序，而execl更换的是用户自己写的程序；参数1用来指定程序的路径，绝对路径和相对路径都是可以的; hello.c1234567#include&lt;stdio.h&gt;int main()&#123; printf("Hello World!\n"); return 0;&#125; fork.c123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main()&#123; pid_t pid; // 定义返回值类型接受fork返回值 pid = fork(); if(pid == -1)// fork失败返回-1 &#123; perror("fork error:"); &#125; else if(pid == 0)// 子进程 &#123; execl("hello", "hello", NULL); &#125; else// 父进程 &#123; sleep(1); printf("我是父进程\n"); &#125; return 0;&#125; 我们将hello.c编译一下 gcc hello.c -o hello 然后编译fork.c并运行 运行的结果 exec函数族一般规律exec函数一旦调用成功即执行新的程序，不返回。只有失败才返回，错误值-1。所以通常我们直接在exec函数调用后直接调用perror()和exit()，无需if判断。 l (list) 命令行参数列表p (path) 搜素file时使用path变量v (vector) 使用命令行参数数组e (environment) 使用环境变量数组,不使用进程原有的环境变量，设置新加载程序运行的环境变量 孤儿进程与僵尸进程孤儿进程孤儿进程: 父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为init进程，称为init进程领养孤儿进程。 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main()&#123; pid_t pid; // 定义返回值类型接受fork返回值 pid = fork(); if(pid == -1)// fork失败返回-1 &#123; perror("fork error:"); &#125; else if(pid == 0)// 子进程 &#123; while(1) &#123; sleep(1); printf("我是子进程 我的PID = %d, 我父亲的PID = %d\n", getpid(), getppid()); &#125; &#125; else// 父进程 &#123; sleep(5); printf("我是父进程, 我要去死了23333333\n"); &#125; return 0;&#125; 程序运行结果 僵尸进程僵尸进程: 进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main()&#123; pid_t pid; // 定义返回值类型接受fork返回值 pid = fork(); if(pid == -1)// fork失败返回-1 &#123; perror("fork error:"); &#125; else if(pid == 0)// 子进程 &#123; printf("我是子进程, 我的PID = %d, 我要去死了233333333333\n", getpid()); &#125; else// 父进程 &#123; while(1) &#123; sleep(1); printf("我是父进程, 我很忙\n"); &#125; &#125; return 0;&#125; 程序是想要子进程结束后，父进程一直在忙，没时间回收子进程的PCB，所以子进程就变成了僵尸态;我们可以使用 ps aux 命令来查看当前运行的程序的状态 S 代表运行 Z代表僵尸态 wait函数一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。 这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。我们知道一个进程的退出状态可以在Shell中用特殊变量$?查看，因为Shell是它的父进程，当它终止时Shell调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。 父进程调用wait函数可以回收子进程终止信息。该函数有三个功能： ① 阻塞等待子进程退出② 回收子进程残留资源③ 获取子进程结束状态(退出原因)。1pid_t wait(int *status); //成功：清理掉的子进程ID；失败：-1 (没有子进程) 当进程终止时，操作系统的隐式回收机制会：1.关闭所有文件描述符 2. 释放用户空间分配的内存。内核的PCB仍存在。其中保存该进程的退出状态。(正常终止→退出值；异常终止→终止信号)可使用wait函数传出参数status来保存进程的退出状态。借助宏函数来进一步判断进程终止的具体原因。宏函数可分为如下三组： WIFEXITED(status) 为非0 → 进程正常结束WEXITSTATUS(status) 如上宏为真，使用此宏 → 获取进程退出状态 (exit的参数) WIFSIGNALED(status) 为非0 → 进程异常终止WTERMSIG(status) 如上宏为真，使用此宏 → 取得使进程终止的那个信号的编号。 WIFSTOPPED(status) 为非0 → 进程处于暂停状态WSTOPSIG(status) 如上宏为真，使用此宏 → 取得使进程暂停的那个信号的编号。WIFCONTINUED(status) 为真 → 进程暂停后已经继续运行 waitpid函数作用同wait，但可指定pid进程清理，可以不阻塞。pid_t waitpid(pid_t pid, int *status, in options); 成功：返回清理掉的子进程ID；失败：-1(无子进程)特殊参数和返回情况：参数pid： > 0 回收指定ID的子进程-1 回收任意子进程（相当于wait）0 回收和当前调用waitpid一个组的所有子进程&lt; -1 回收指定进程组内的任意子进程 返回0：参3为WNOHANG，且子进程正在运行。 注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。]]></content>
      <categories>
        <category>Linux系统编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>系统编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下的进程浅谈（一）]]></title>
    <url>%2F2019%2F04%2F05%2Ffork%2F</url>
    <content type="text"><![CDATA[进程相关概念程序和进程程序，是指编译好的二进制文件，在磁盘上，不占用系统资源(cpu、内存、打开的文件、设备、锁….)进程，是一个抽象的概念，与操作系统原理联系紧密。进程是活跃的程序，占用系统资源。在内存中执行。(程序运行起来，产生一个进程)程序 → 剧本(纸) 进程 → 戏(舞台、演员、灯光、道具…)同一个剧本可以在多个舞台同时上演。同样，同一个程序也可以加载为不同的进程(彼此之间互不影响)如：同时开两个终端。各自都有一个bash但彼此ID不同。 并发并发，在操作系统中，一个时间段中有多个进程都处于已启动运行到运行完毕之间的状态。但，任一个时刻点上仍只有一个进程在运行。例如，当下，我们使用计算机时可以边听音乐边聊天边上网。 若笼统的将他们均看做一个进程的话，为什么可以同时运行呢，因为并发。cpu会分成很多的时间时间碎片，以供所有的程序都可以分到一定得cpu时间，使得大家都可以占用一定时间的cpu；cpu数着纳秒过日子的，所以在微观上程序还是一个一个进行运算；但在宏观上，他们是并发的，在用户层面感觉他是同时运行的; 进程控制块PCB基本概念我们知道，每个进程在内核中都有一个进程控制块（PCB）来维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。/usr/src/linux-headers-3.16.0-30/include/linux/sched.h文件中可以查看struct task_struct 结构体定义。其内部成员有很多，我们重点掌握以下部分即可： 进程id。系统中每个进程有唯一的id，在C语言中用pid_t类型表示，其实就是一个非负整数。 进程的状态，有就绪、运行、挂起、停止等状态。 进程切换时需要保存和恢复的一些CPU寄存器。 描述虚拟地址空间的信息。 描述控制终端的信息。 当前工作目录（Current Working Directory）。 umask掩码。 文件描述符表，包含很多指向file结构体的指针。 和信号相关的信息。 用户id和组id。 会话（Session）和进程组。 进程可以使用的资源上限（Resource Limit）。进程状态进程基本的状态有5种。分别为初始态，就绪态，运行态，挂起态与终止态。其中初始态为进程准备阶段，常与就绪态结合来看。 进程控制fork函数创建一个子进程。函数原型 pid_t fork(void); 头文件 #include 失败返回-1；成功返回：① 父进程返回子进程的ID(非负) ②子进程返回 0pid_t类型表示进程ID，但为了表示-1，它是有符号整型。(0不是有效进程ID，init最小，为1) 注意返回值，不是fork函数能返回两个值，而是fork后，fork函数变为两个，父子需【各自】返回一个。 测试代码1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main()&#123; pid_t pid; // 定义返回值类型接受fork返回值 printf("我是第一句话\n"); pid = fork(); if(pid == -1)// fork失败 返回值是-1 &#123; perror("fork error:"); &#125; else if(pid == 0)// 返回值为0代表是子进程 &#123; printf("我是子进程\n"); &#125; else//其他情况就是父进程 父进程返回的PID 就是子进程的PID &#123; printf("我是父进程\n"); &#125; printf("我是第二句话\n"); return 0;&#125; 运行结果 这个运行结果有很多需要解释的地方，我们来一点一点解释; 1.父进程与子进程运行顺序的关系 从我们的程序来看，是先打印了父进程，然后打印了子进程；那是不是父进程一定先运行呢？答案是否定的，在组成原理中表示。任意不同的进程都是争夺资源，谁抢到谁先运行。所以可见，这个程序中，父进程和子进程也是竞争关系。谁先得到cpu谁先运行;(虽然理论是这样的，但是有人尝试了很多次在不加限制的情况下，运行了很多次这样的程序，发现有98%的概率父进程先运行); 2.创建子进程之后，子进程是从main函数下面执行呢？还是当前到哪里就从哪里执行呢？ 因为在我们在fork之前添加了一条打印(“我是第一句话”),所以，如果子进程也是在来一遍的话，显然这句话应该被打印两遍，但是现在只打印了一遍。而后面的那句””我是第二句话”打印了两遍；所以我们可以知道；子进程是在哪里fork之后开始执行后面的代码； 3.为啥显示这么奇怪呢？ 这个是因为shell监听的是主进程，然后此程序主进程先运行完毕，所以当主进程运行完毕之后，shell切换到前台，所以子进程打印的消息就在终端提示之后了; 循环创建多个子进程我们先写一个假的循环创建多个子进程的程序; 循环创建3个子进程1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main()&#123; pid_t pid; // 定义返回值类型接受fork返回值 int i; for(i = 0; i &lt; 3; i++) &#123; pid = fork(); if(pid == -1)// fork失败 &#123; perror("fork error:"); &#125; else if(pid == 0)// 子进程 &#123; printf("我是第%d个子进程\n", i + 1); &#125; else &#123; printf("我是父进程\n"); &#125; &#125; return 0;&#125; 运行结果 是不是和我们的预期不太一样? 为什么呢？ 其实仔细想想也不难理解；因为子进程还在for循环中，他也会作为父进程创建子进程，所以会打印这么多的我是父进程和我是第几个子进程;我们稍微画一下这个过程我只画了i到1， 其实我们的程序还有一层。我们可以发现，一共生成了2的n次方-1个子进程。那么我们如何避免这个尴尬呢？其实也不难； 循环创建多个子进程123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main()&#123; pid_t pid; // 定义返回值类型接受fork返回值 int i; for(i = 0; i &lt; 3; i++) &#123; pid = fork(); if(pid == -1)// fork失败 &#123; perror("fork error:"); &#125; else if(pid == 0)// 子进程 &#123; break;// 子进程直接跳出循环 &#125; else &#123; //父进程啥都不做 只创建子进程 &#125; &#125; if(i &lt; 3)// 代表这是子进程跳出循环后 &#123; printf("我是第%d个子进程\n", i + 1); &#125; if(i == 3)// for循环终止后 i = 3 此时这个是父进程 &#123; printf("我是父进程\n"); &#125; return 0;&#125; 运行结果 我们可以看到，此时程序就是正确的了； 进程常用函数getpid函数 获取当前进程ID pid_t getpid(void); getppid函数 获取当前进程的父进程ID pid_t getppid(void); getuid函数 获取当前进程实际用户ID uid_t getuid(void);获取当前进程有效用户ID uid_t geteuid(void); getgid函数 获取当前进程使用用户组ID gid_t getgid(void);获取当前进程有效用户组ID gid_t getegid(void);]]></content>
      <categories>
        <category>Linux系统编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>系统编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Makefile使用总结]]></title>
    <url>%2F2019%2F04%2F03%2FMakefile%2F</url>
    <content type="text"><![CDATA[Makefile简介我们为什么要学习Makefile呢？因为他可以帮助我们节省时间，提升我们的工作效率.而且很多大型项目的编译都是通过 Makefile 来组织的, 如果没有 Makefile, 那很多项目中各种库和代码之间的依赖关系不知会多复杂. Makefile的编写Makefile的命名方式:1.Makefile2.makefile这两者的区别就在于第一个字母是否大写，我们一般命名为Makefile； Makefile的一般规则Makefile的最核心的内容有三部分；1.生成目标2.依赖文件3.命令如图所示，就是一个简单的Makefile；我们举一个例子来体会一下； main.c123456789101112#include &lt;stdio.h&gt;#include "head.h"int main()&#123; printf("%d + %d = %d\n", 1, 2, add(1, 2)); printf("%d - %d = %d\n", 3, 4, sub(3, 4)); printf("%d * %d = %d\n", 5, 6, mul(5, 6)); printf("%d / %d = %d\n", 6, 3, div(6, 3)); return 0;&#125; add.c12345#include &lt;stdio.h&gt;int add(int a, int b)&#123; return a + b;&#125; sub.c12345#include &lt;stdio.h&gt;int sub(int a, int b)&#123; return a - b;&#125; mul.c12345#include &lt;stdio.h&gt;int mul(int a, int b)&#123; return a * b;&#125; div.c12345#include &lt;stdio.h&gt;int div(int a, int b)&#123; return a / b;&#125; 这个程序的功能就是简单的实现以下加减乘除；我们用命令 gcc main.c add.c sub.c mul.c div.c -o mycalc 编译一下我们可以看到，编译成功并且程序运行结果也是正确的，那么我们把这个写成Makefile； Makefile12mycalc: main.c add.c sub.c mul.c div.c gcc main.c add.c sub.c mul.c div.c -o mycalc 然后我们重新试试能不能生成可执行程序;我们可以看到，我们在终端输入了make之后，就会自动的键入我们所指定的命令来完成编译；那么我们分析一下这个Makefile文件; mycalc: main.c add.c sub.c mul.c div.c gcc main.c add.c sub.c mul.c div.c -o mycalcmycalc就是目标文件，代表我这个Makefile就是要生成这个文件的; mycalc: main.c add.c sub.c mul.c div.c gcc main.c add.c sub.c mul.c div.c -o mycalc这些.c文件是我生成目标文件的依赖项；mycalc: main.c add.c sub.c mul.c div.c gcc main.c add.c sub.c mul.c div.c -o mycalc第二行是一个Tab缩进加一条命令，代表我生成目标所要执行的命令; Makefile执行命令的依据那么Makefile如何判断自己啥时候执行命令呢？比如当我make了一次就是已经生成mycalc文件了，这时候我继续输入make，他还会重新编译嘛？答案是不会的。那么他是如何判定的呢？ 他是根据目标文件和依赖文件，最后修改时间来判定的；比如，mycalc是在 12:00生成的，而几个依赖文件都是11:58创建的。此时我make，那么很显然，依赖文件并没有更新，则我的目标文件也就不需要更新了；反过来，只要我有一个依赖文件在12:00之后修改过，那么代表我程序的部分内容需要修改，此时就需要重新编译了; Makefile的优化还是以上面的例子为例；当我们需要对某些函数进行修改时，如果还是刚才那样写Makefile的话，其他不需要修改的文件也需要进行重新编译，这无疑带来了很多没必要花费的时间，那我们如何解决这个问题呢？其实仔细想想也不难解决，我们只重新编译那些修改的文件，对于没有进行更新的文件我们不更新他；我们重写一下Makefile;123456789101112mycalc: main.o add.o sub.o mul.o div.o gcc main.o add.o sub.o mul.o div.o -o mycalcmain.o: main.c gcc main.c -cadd.o: add.c gcc add.c -csub.o: sub.c gcc sub.c -cmul.o: mul.c gcc mul.c -cdiv.o: div.c gcc div.c -c 然后我们重新make一下；此时我们可以看到程序先将所有的.c编译分别为.o然后进行链接操作；我们修改一下add.c然后重新make一下，看看他会不会只编译add.c我们修改add，加了一条输出语句;然后make一下;我们可以看到，只是重新编译了add.c而其他的所有文件都没有进行重新编译：]]></content>
      <categories>
        <category>Linux系统编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>系统编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多进程并发服务器浅谈]]></title>
    <url>%2F2019%2F04%2F02%2F%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B5%85%E8%B0%88%2F</url>
    <content type="text"><![CDATA[引入上一篇博客我们只说了对于一个客户端进行处理数据，但是在实际开发中，我们肯定是并发的对多个客户端进行服务；实现并发服务器的方式有很多种，我们今天讲讲最简单实现的，就是利用多进程进行实现； 思路分析在上一篇博客中，我们提到Socket编程的基本流程图；我们可以看到，在创建好套接字之后，服务器端就阻塞在accept函数上，等待客户端的链接；那么我们就可以在客户端建立连接之后创建一个子进程来处理这个客户端，而我们的父进程继续监听等待其他客户端来链接；简单来说就是 每当有客户端要和服务器连接，那么我们就创建一个子进程来处理这个客户端； 所以我们不难写出代码;注意事项1.由于父子进程会共享一些局部变量(写时拷贝),所以我们需要在子进程中关闭负责监听的文件描述符，在父进程关闭连接到服务器的文件描述符;2.由于子进程只有其父进程可以进行回收，所以这个顺序不能反过来；即不可以子进程进行监听而父进程进行处理; 服务器端代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/types.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;ctype.h&gt;#include &lt;stdlib.h&gt;#define IP "127.0.0.1"#define PORT 6666int main()&#123; int lfd, cfd, i, n, opt; struct sockaddr_in server_addr, client_addr; socklen_t client_len; pid_t pid; char buf[BUFSIZ], str[BUFSIZ]; // buf用来接收发送数据 str记录客户端ip // 创建socket套接字 ipv4 TCP协议传输 lfd = socket(AF_INET, SOCK_STREAM, 0); // server_addr 初始化 bzero(&amp;server_addr, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_port = htons(PORT); // 本地字节序转为网络字节序 inet_pton(lfd, IP, &amp;server_addr.sin_addr.s_addr);// 点分十进制转为网络字节序 //设置端口复用 setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt)); //绑定 套接字与IP和端口 bind(lfd, (struct sockaddr *)&amp;server_addr, sizeof(server_addr)); //设置同时连接的上限 listen(lfd, 128); while(1) // 循环等待连接 &#123; //阻塞等待客户端连接 client_len = sizeof(client_addr); cfd = accept(lfd, (struct sockaddr *)&amp;client_addr, &amp;client_len); //有客户端进行连接 则创建一个进程进行处理 pid = fork(); if(pid == 0)//子进程 子进程进行处理客户端 &#123; close(lfd); // 关闭父进程用来监听的文件描述符 防止错误 // 打印客户端的IP和端口 printf("====IP:%s,PORT:%d\n", inet_ntop(AF_INET, &amp;client_addr.sin_addr.s_addr, str, sizeof(str)), ntohs(client_addr.sin_port)); //从套接字中读取数据 n = read(cfd, buf, sizeof(buf)); if(n &lt;= 0) // 异常退出 exit(0); printf("data is : %s\n", buf);//将数据输出一下 //对数据进行处理 for(i = 0; i &lt; n; i++) buf[i] = toupper(buf[i]); //写会客户端 write(cfd, buf, n); exit(0); // 记得结束子进程 否则会死循环 &#125; else //父进程 &#123; close(cfd); // 关闭客户端新连接文件描述符 &#125; &#125; close(lfd); close(cfd); return 0;&#125; 复制代码并命名为fork.c然后在终端输入 gcc fork.c -o fork -w 可以看到 就生成了一个可执行程序; ./fork 运行程序 运行程序之后，我们新开两个终端进行测试；我们可以用nc命令进行连接 nc 127.0.0.1 6666 然后我们输入数据，可以发现客户端可以回复我们想要的数据; 对上面的代码一些问题进行解释; setsockopt这个函数是端口复用函数，为啥要用这个呢？ 比如我们的程序是6666端口，然后我们进行测试的时候发现某个地方需要更改，当我们改完代码编译并运行，发现nc并不能连到当前服务器；如果你了解过TCP的状态转换你可能就明白；简单来说就是TCP主动断开连接的一方需要等待2MLS的时间(Linux下一般为1min)，在这段时间内这个端口是被占用的，所以我们的客户端连不到此服务器；而端口复用则可以解决这一个问题； ———好饿啊———吃完饭写———- 客户端端代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/types.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define IP "127.0.0.1"#define PORT 6666int main()&#123; int cfd, i, n; struct sockaddr_in client_addr; char buf[BUFSIZ], str[BUFSIZ]; // 创建套接字 cfd = socket(AF_INET, SOCK_STREAM, 0); // 客户端不需要关心自己IP和端口 操作系统会自动分配 当然 也可以自己指定 // 套接字初始化 client_addr.sin_family = AF_INET; client_addr.sin_port = htons(PORT); inet_pton(cfd, IP, &amp;client_addr.sin_addr.s_addr); // 与服务器进行连接 connect(cfd, (struct sockaddr *)&amp;client_addr, sizeof(client_addr)); while(1) &#123; // 客户端通过键盘 写数据到buf fgets(buf, sizeof(buf), stdin); // 通过套接字写数据到服务器端 write(cfd, buf, strlen(buf)); //读取服务器写会的数据 n = read(cfd, buf, sizeof(buf)); printf("%s\n", buf); &#125; close(cfd); return 0;&#125;]]></content>
      <categories>
        <category>Linux网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Socket编程浅谈]]></title>
    <url>%2F2019%2F04%2F01%2FSocket%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[套接字的基本概念在TCP/IP协议中，“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程。“IP地址+端口号”就对应一个socket。欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用Socket来描述网络连接的一对一关系。套接字通信原理如下图所示： 一个sfd(servert_fd)代表服务器端的文件描述符一个cfd（client_fd）代表客户端的文件描述符与常规的文件描述符不同，Socket中的文件描述符读取和写入并不是对同一个文件进行操作，而是指向两个不同的缓冲区; socket模型创建流程图通过此图我们可以得出，在写服务器端的时候这几个步骤是： 1. 创建Socket套接字socket()打开一个网络通讯端口，如果成功的话，就像open()一样返回一个文件描述符，应用程序可以像读写文件一样用read/write在网络上收发数据，如果socket()调用出错则返回-1。对于IPv4，domain参数指定为AF_INET。对于TCP协议，type参数指定为SOCK_STREAM，表示面向流的传输协议。如果是UDP协议，则type参数指定为SOCK_DGRAM，表示面向数据报的传输协议。protocol参数的介绍从略，指定为0即可。Linux下函数原型是：int socket(int domain, int type, int protocol);第一个参数domain一般写AF_INET，代表使用IPV4地址传输；第二个参数type一般写SOCK_STREAM或者SOCK_DGRAM;分别代表有连接的可靠的流式传输和无连接不可靠的报式传输;第一个最常见的就是TCP协议，第二个最常见的就是UDP；第三个参数一般写0；代表使用默认的type协议；SOCK_STREAM默认协议是TCPSOCK_DGRAM默认协议时UDP返回值： 成功：返回指向新创建的socket的文件描述符，失败：返回-1，设置errno头文件:12#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt; 2. 绑定IP和端口绑定程序的IP和端口服务器程序所监听的网络地址和端口号通常是固定不变的，客户端程序得知服务器程序的地址和端口号后就可以向服务器发起连接，因此服务器需要调用bind绑定一个固定的网络地址和端口号。int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); sockfd： socket文件描述符addr: 构造出IP地址加端口号addrlen: sizeof(addr)长度返回值： 成功返回0，失败返回-1, 设置errno头文件:12#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt; PS：这里需要注意一点是:由于Socket发展过程中，有些东西的不统一，所以我们得手动让他们兼容;现在的构造Socket结构体的类型是 struct sockaddr_in而之前我们的前辈在写一些函数时写的类型是strut sockaddr *，所以我们得手动让他们兼容；简单来说，A发明了socket 其结构体是 struct sockaddr, A将很多函数都写好了，函数的参数类型也是 struct sockaddr；后来B发现struct sockaddr有缺陷 就对其进行升级改造为struct sockaddr_in,但是B并没有对函数进行重写，所以我们得将struct sockaddr_in这种类型转为struct sockaddr这种类型，以便其可以在A写的函数中使用;Socket中需要进行类型转换的函数有三个，分别是:bind()accept()connect() 3. listen函数 设置等待上限listen函数原型:int listen(int sockfd, int backlog); sockfd: socket文件描述符 backlog: 排队建立3次握手队列和刚刚建立3次握手队列的链接数和这个解释一下，这个函数并不是设置监听客户端的上限。而是设置等待建立连接的最大客服端的个数；比如服务器现在很繁忙，没有时间与客户端建立连接，那么客户端进入等待队列，这里设置的就是最大允许等待的个数，大于这个个数则直接忽略他的请求，不进如等待队列;头文件:12#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt; 4.accept函数 阻塞函数，等待客户端的连接函数原型:int accept(int sockfd, struct sockaddr addr, socklen_t addrlen);sockdf: socket文件描述符addr: 传出参数，返回链接客户端地址信息，含IP地址和端口号addrlen: 传入传出参数（值-结果）,传入sizeof(addr)大小，函数返回时返回真正接收到地址结构体的大小返回值： 成功返回一个新的socket文件描述符，用于和客户端通信，失败返回-1，设置errno三方握手完成后，服务器调用accept()接受连接，如果服务器调用accept()时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来。addr是一个传出参数，accept()返回时传出客户端的地址和端口号。addrlen参数是一个传入传出参数（value-result argument），传入的是调用者提供的缓冲区addr的长度以避免缓冲区溢出问题，传出的是客户端地址结构体的实际长度（有可能没有占满调用者提供的缓冲区）。如果给addr参数传NULL，表示不关心客户端的地址。头文件:12#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt; 服务器端重要的过程就是这四步 代码示例:我们先写一个简单的服务器端的程序，对这个过程加深一下了解；服务端的功能很简单，等待客户端输入一串字母，将字母的小写转为大写并写会客户端；12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#define IP "127.0.0.1"#define PORT 6666int main()&#123; char buf[1024]; int server_fd, client_fd, n, i; struct sockaddr_in server_addr, client_addr; socklen_t client_len; // 第一步 建立socket套接字 server_fd = socket(AF_INET, SOCK_STREAM, 0); // AF_INET 代表使用IPV4传输 SOCK_STREAM代表使用流式传输 0代表默认协议 即TCP协议 if(server_fd == -1) // 代表创建失败 &#123; perror("socket error:"); exit(1); // 结束程序 &#125; // 第二步 绑定端口和IP地址 server_addr.sin_family = AF_INET;//补全套接字的传输方式 IPV4 server_addr.sin_port = htons(PORT);// 设置套接字的端口 inet_pton(server_fd, IP, &amp;server_addr.sin_addr.s_addr);//设置套接字的IP bind(server_fd, (struct sockaddr*)&amp;server_addr, sizeof(server_addr)); //第三步 设置服务端等待上限 listen(server_fd, 128); //第四步 阻塞等待客户端连接 client_len = sizeof(client_addr); client_fd = accept(server_fd, (struct sockaddr *)&amp;client_addr, &amp;client_len); // 处理数据 n = read(client_fd, buf, sizeof(buf)); for(i = 0; i &lt; n; i++) buf[i] = toupper(buf[i]); write(client_fd, buf, n); close(server_fd); close(client_fd); return 0;&#125; 你可以复制一下代码保存为socket.c然后在终端输入 gcc socket.c -o socket -w 然后可以看到在当前目录地下生成了一个socket的可执行程序 ./socket 运行此程序，然后在开一个终端 输入 nc 127.0.0.1 6666 然后输入一串字母 然后会发现服务器给你返回一串转为大写的字符串; 这样我们就建立了一个比较简单的web服务器了，当然，这里用的IP是本地IP。如果你有服务器也可以将IP设置为你的公网IP，这样其他的主机也可以进行访问你的程序；（记得将你的端口放行，否则会被安全组拦截） 其他内容你可能也发现了，在函数中，我们写了并未在文章中提到的函数 比如 htons() inet_pton()之类的函数，那么我们在这里再说说这些东西; 网络字节序我们已经知道，内存中的多字节数据相对于内存地址有大端和小端之分，磁盘文件中的多字节数据相对于文件中的偏移地址也有大端小端之分。网络数据流同样有大端小端之分，那么如何定义网络数据流的地址呢？发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发出，接收主机把从网络上接到的字节依次保存在接收缓冲区中，也是按内存地址从低到高的顺序保存，因此，网络数据流的地址应这样规定：先发出的数据是低地址，后发出的数据是高地址。TCP/IP协议规定，网络数据流应采用大端字节序，即低地址高字节。例如UDP段格式，地址0-1是16位的源端口号，如果这个端口号是1000（0x3e8），则地址0是0x03，地址1是0xe8，也就是先发0x03，再发0xe8，这16位在发送主机的缓冲区中也应该是低地址存0x03，高地址存0xe8。但是，如果发送主机是小端字节序的，这16位被解释成0xe803，而不是1000。因此，发送主机把1000填到发送缓冲区之前需要做字节序的转换。同样地，接收主机如果是小端字节序的，接到16位的源端口号也要做字节序的转换。如果主机是大端字节序的，发送和接收都不需要做转换。同理，32位的IP地址也要考虑网络字节序和主机字节序的问题。为使网络程序具有可移植性，使同样的C代码在大端和小端计算机上编译后都能正常运行，可以调用以下库函数做网络字节序和主机字节序的转换。 端口网络字节序和本地字节序直接的转化1234567#include &lt;arpa/inet.h&gt;// h表示host，n表示network，l表示32位长整数，s表示16位短整数。uint32_t htonl(uint32_t hostlong); uint16_t htons(uint16_t hostshort);uint32_t ntohl(uint32_t netlong);uint16_t ntohs(uint16_t netshort); IP地址的网络字节序和本地字节序的转化123456#include &lt;arpa/inet.h&gt;//p to n 代表本地的IP字符串转为网络的IP地址int inet_pton(int af, const char *src, void *dst);// n to p 代表网络的IP地址 转为本地的IP字符串const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);]]></content>
      <categories>
        <category>Linux网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速幂与快速乘小结]]></title>
    <url>%2F2019%2F03%2F10%2F%E5%BF%AB%E9%80%9F%E5%B9%82%E4%B8%8E%E5%BF%AB%E9%80%9F%E4%B9%98%2F</url>
    <content type="text"><![CDATA[题目链接：牛客网小白月赛12-B题题目描述：链接：https://ac.nowcoder.com/acm/contest/392/B来源：牛客网找到了心仪的小姐姐月月后，华华很高兴的和她聊着天。然而月月的作业很多，不能继续陪华华聊天了。华华为了尽快和月月继续聊天，就提出帮她做一部分作业。月月的其中一项作业是：给定正整数A、B、P，求$A^{B}modP$的值。华华觉得这实在是毫无意义，所以决定写一个程序来做。但是华华并不会写程序，所以这个任务就交给你了。因为月月的作业很多，所以有T组询问。输入描述:第一行一个正整数T表示测试数据组数。接下来T行，每行三个正整数A、B、P，含义如上文。输出描述:输出T行，每行一个非负整数表示答案。示例1输入22 5 1057284938291657 827493857294857 384729583748273输出218924650048745 快速幂:此题同时用到了快速幂和快速乘，所以在此总结一下； 首先是快速幂是用于快速求解$A^{B}modP$这类问题对于 $A^{B}modP$ 这类问题，朴素的做法是123int tmp = 1;for(int i = 0; i &lt; B; i++) tmp = (tmp * A) % MOD; 按照题意要求模拟$A^{B}$过程中每次取余即可；这样做，虽然结果是对的，但是效率不够高.时间复杂度为O(B);那这个过程能不能加速呢？ 是可以的，就是我们今天要说的这个快速幂；那他的原理是咋样的呢？如果B是偶数 那么有 $A^{B}modP$ 等价于 $A^{2^{\frac{B}{2}}}modP$如果B是奇数 那么有 $A^{B}modP$ 等价于 $A * A^{2^{\frac{B-1}{2}}}modP$ 举个例子$3^{5}mod4$第一步:初始化最终结果tmp = 1我们发现5是奇数 所以可以将其拆分为 $3 \times 3^{2^{\frac{5-1}{2}}}modP$显然 我们可以计算出tmp = tmp $\times$ A, A = A $\times$ A 然后对B进行右移操作，即除以2然后向下取整，此时A = 9, B = 2, tmp = 3,对剩下的部分继续快速幂第二步:我们发现没算的那个2是偶数 所以可以得出 $3^{2^{\frac{2}{2}}}modP$显然 我们可以计算出 A = A $\times$ A,然后对B进行右移操作，即除以2然后向下取整，此时A = 81, B = 1, tmp = 3,对剩下的部分继续快速幂第三步:我们发现没算的那个1是奇数 所以可以得出 $3^{2^{\frac{1-1}{2}}}modP$显然 我们可以计算出 tmp = tmp $\times$ A, A = A $\times$ A然后对B进行右移操作，即除以2然后向下取整，此时A = 729, B = 0, tmp = 243; 第四步:此时B为0，我们终止循环，返回tmp % mod即可；显然，我们只是当B为奇数时把结果乘到tmp中，B为偶数时，我们只将A改变为其的平方即可；这样就可以加速运算；我自己的pow_mod12345678910111213#define long long longlong pow_mod(long a, long b, long mod)&#123; long tmp = 1; while(b) &#123; if(b &amp; 1) tmp = ( (tmp % mod) * (a % mod) ) % mod; a = ( (a % mod) * (a % mod) ) % mod; b &gt;&gt;= 1; &#125; return tmp;&#125; 快速乘考虑到在做快速幂的时候 a $\times$ a可能会爆long long. 如果你说你要用Java或Python的大整数，那也可以，不过还是建议学一下快速乘； 举个例子:20 $\times$ 11=20 $\times$ (1011)=20 $\times$ $2^{3}$ $\times$ 1 + 20 $\times$ $2^{2}$ $\times$ 0 + 20 $\times$ $2^{1}$ $\times$ 1 + 20 $\times$ $2^{0}$ $\times$ 1 = 160 + 40 + 20 = 220我们可以看到，每次可以给a乘以2，若当前位为1则代表有贡献，对答案进行更新，否则就是没有贡献，跳过即可；这样我们每次做的都是 + 操作，所以不必担心爆long long；时间复杂度是O(logb) 12345678910111213#define long long longlong mul(long a, long b, long mod)&#123; long tmp = 0; while(b) &#123; if(b &amp; 1) tmp = (tmp + a) % mod; a = (a + a) % mod; b &gt;&gt;= 1; &#125; return tmp % mod;&#125; 题目代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;#define long long long#define INF 0x3f3f3f3f#define MOD 1000000007#define MAX_N 200010long mul(long a, long b, long mod)&#123; long tmp = 0; while(b) &#123; if(b &amp; 1) tmp = (tmp + a) % mod; a = (a + a) % mod; b &gt;&gt;= 1; &#125; return tmp % mod;&#125;long pow_mod(long a, long b, long mod)&#123; long tmp = 1; while(b) &#123; if(b &amp; 1) tmp = mul(tmp, a, mod); a = mul(a, a, mod); b &gt;&gt;= 1; &#125; return tmp;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t; cin &gt;&gt; t; while(t--) &#123; long a, b, mod; cin &gt;&gt; a &gt;&gt; b &gt;&gt; mod; cout &lt;&lt; pow_mod(a, b, mod) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>玄学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最少拦截系统【基础DP】]]></title>
    <url>%2F2019%2F02%2F27%2FHDU-1257%2F</url>
    <content type="text"><![CDATA[题目链接：HDU-1257kuangbin带你飞【专题十二 基础DP1 】&lt;/br&gt; 题目描述：某国为了防御敌国的导弹袭击,发展出一种导弹拦截系统.但是这种导弹拦截系统有一个缺陷:虽然它的第一发炮弹能够到达任意的高度,但是以后每一发炮弹都不能超过前一发的高度.某天,雷达捕捉到敌国的导弹来袭.由于该系统还在试用阶段,所以只有一套系统,因此有可能不能拦截所有的导弹.怎么办呢?多搞几套系统呗!你说说倒蛮容易,成本呢?成本是个大问题啊.所以俺就到这里来求救了,请帮助计算一下最少需要多少套拦截系统. &lt;/br&gt; 思路:此题数学证明引用聚聚原话:原文出自:洛谷的导弹拦截这题聚聚的地址:点击访问然后我们就要求一个最长上升子序列的长度即可；朴素的算法的时间复杂度是n^2的，我们可以用2分优化到nlogn。这里用到了STL的lower_bound 返回第一个 &gt;= 指定元素的地址； 代码:123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;#define long long long#define INF 0x3f3f3f3f#define MAX_N 1000010int dp[MAX_N], a[MAX_N];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n; while(cin &gt;&gt; n) &#123; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; int len = 1; dp[len] = a[1]; for(int i = 2; i &lt;= n; i++) &#123; if(a[i] &gt; dp[len]) &#123; dp[++len] = a[i]; &#125; else &#123; int pos = lower_bound(dp, dp + len, a[i]) - dp; dp[pos] = a[i]; &#125; &#125; cout &lt;&lt; len &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞【专题十二】 基础DP1</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[免费馅饼【基础DP】]]></title>
    <url>%2F2019%2F02%2F27%2FHDU-1176%2F</url>
    <content type="text"><![CDATA[题目链接：HDU-1176kuangbin带你飞【专题十二 基础DP1 】&lt;/br&gt; 题目描述：都说天上不会掉馅饼，但有一天gameboy正走在回家的小径上，忽然天上掉下大把大把的馅饼。说来gameboy的人品实在是太好了，这馅饼别处都不掉，就掉落在他身旁的10米范围内。馅饼如果掉在了地上当然就不能吃了，所以gameboy马上卸下身上的背包去接。但由于小径两侧都不能站人，所以他只能在小径上接。由于gameboy平时老呆在房间里玩游戏，虽然在游戏中是个身手敏捷的高手，但在现实中运动神经特别迟钝，每秒种只有在移动不超过一米的范围内接住坠落的馅饼。现在给这条小径如图标上坐标： 为了使问题简化，假设在接下来的一段时间里，馅饼都掉落在0-10这11个位置。开始时gameboy站在5这个位置，因此在第一秒，他只能接到4,5,6这三个位置中其中一个位置上的馅饼。问gameboy最多可能接到多少个馅饼？（假设他的背包可以容纳无穷多个馅饼） &lt;/br&gt; 思路:按照动态规划的常规套路分为4步； 1.确定状态显然，我们需要确定第k秒 在第i个位置的收益我们发现第k秒在第i个点的收益等于前k - 1秒在(i - 1, i , i + 1)【假设三个值都处于0 - 10】三个值中取其中的一个 + 当前点的收益；所以我们设 dp[i][j]表示第i秒当前位置在j点的最大收益它的子问题就是在i - 1秒 与 j点相连的两个点的最大收益；显然这满足最优子结构和无后效性2.转移方程因为dp[i][j]这个点 只能由 dp[i - 1][j - 1], dp[i - 1][j]和 dp[i - 1][j + 1]这三个点转移过来；所以我们在外层循环枚举每个时间，内层枚举每个点。然后转移是由上一层的j - 1, j , j + 1取一个最优点即可;即 dp[i][j] = max(dp[i - 1][j - 1], dp[i - 1][j], dp[i - 1][j + 1]) + val[i][j]3.边界情况与初始化只需将0秒时，所有位置的收益初始化为0即可；4.计算顺序显然，我们需要dp[i][j]就需要上一层的dp[i - 1][j - 1] dp[i - 1][j] dp[i - 1][j + 1]，所以我们从前往后转移即可; PS:由于题目给出初始点在5这个点，所以dp[1][4] = val[1][4], dp[1][5] = val[1][5], dp[1][6] = val[1][6].其他秒按顺序转移即可; 我的代码记录的最大的时间和点，算是一种常数优化吧; 代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;#define long long long#define INF 0x3f3f3f3f#define MAX_N 100010int a[MAX_N], dp[MAX_N][20], val[MAX_N][20];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n; while(cin &gt;&gt; n, n) &#123; memset(dp, 0, sizeof(dp)); memset(val, 0, sizeof(val)); int tmp_val, tmp_time, max_time = 0, max_val = 0, MAX = 0; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; tmp_val &gt;&gt; tmp_time; max_time = max(max_time, tmp_time); max_val = max(max_val, tmp_val); val[tmp_time][tmp_val]++; &#125; for(int i = 1; i &lt;= max_time; i++) &#123; if(i == 1) &#123; dp[i][5] = val[i][5]; dp[i][6] = val[i][6]; dp[i][4] = val[i][4]; &#125; else &#123; for(int j = 0; j &lt;= max_val; j++) &#123; int tmp_max = 0; if(j - 1 &gt;= 0) tmp_max = max(tmp_max, dp[i - 1][j - 1]); if(j + 1 &lt;= max_val) tmp_max = max(tmp_max, dp[i - 1][j + 1]); tmp_max = max(tmp_max, dp[i - 1][j]); dp[i][j] = tmp_max + val[i][j]; MAX = max(MAX, dp[i][j]); &#125; &#125; &#125; cout &lt;&lt; MAX &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞【专题十二】 基础DP1</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Super Jumping! Jumping! Jumping!【基础DP】]]></title>
    <url>%2F2019%2F02%2F27%2FHDU-1087%2F</url>
    <content type="text"><![CDATA[题目链接：HDU-1087kuangbin带你飞【专题十二 基础DP1 】&lt;/br&gt; 题目描述：Nowadays, a kind of chess game called “Super Jumping! Jumping! Jumping!” is very popular in HDU. Maybe you are a good boy, and know little about this game, so I introduce it to you now. The game can be played by two or more than two players. It consists of a chessboard（棋盘）and some chessmen（棋子）, and all chessmen are marked by a positive integer or “start” or “end”. The player starts from start-point and must jumps into end-point finally. In the course of jumping, the player will visit the chessmen in the path, but everyone must jumps from one chessman to another absolutely bigger (you can assume start-point is a minimum and end-point is a maximum.). And all players cannot go backwards. One jumping can go from a chessman to next, also can go across many chessmen, and even you can straightly get to end-point from start-point. Of course you get zero point in this situation. A player is a winner if and only if he can get a bigger score according to his jumping solution. Note that your score comes from the sum of value on the chessmen in you jumping path.Your task is to output the maximum value according to the given chessmen list. &lt;/br&gt; 思路:按照动态规划的常规套路分为4步； 1.确定状态我们发现第k步的贡献等于前k - 1步的贡献 + 当前的权值；所以我们设 dp[i]表示到达i点的最大权值它的子问题就是到达dp[i - p]点的最大权值。显然这满足最优子结构和无后效性2.转移方程因为a[i]这个点 只能由 a[j] (j &lt; i &amp;&amp; a[j] &lt; a[i])这种点转移过来，所以我们可以枚举所有在i前面的点 判断它是否 &lt; a[i]即可；如果a[j] &lt; a[i] &amp;&amp; j &lt; i 则 dp[i] = min(dp[i], dp[j] + a[i])；3.边界情况与初始化只需要在计算每个点的时候，将其dp[i] 赋值为 a[i]即可 代表其最小贡献就是自己的权值;4.计算顺序显然，我们需要dp[i],就需要dp[i - k] (k &lt; i),所以我们先计算前面的点，然后转移到后面的点即可；&lt;/br&gt; 代码:1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;#define long long long#define INF 0x3f3f3f3f#define MAX_N 10010int a[MAX_N], dp[MAX_N];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n; while(cin &gt;&gt; n, n) &#123; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; int MAX = 0; for(int i = 1; i &lt;= n; i++) &#123; dp[i] = a[i]; for(int j = 1; j &lt; i; j++) &#123; if(a[i] &gt; a[j]) dp[i] = max(dp[i], dp[j] + a[i]); &#125; MAX = max(MAX, dp[i]); &#125; cout &lt;&lt; MAX &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞【专题十二】 基础DP1</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ignatius and the Princess IV【基础DP】]]></title>
    <url>%2F2019%2F02%2F26%2FHDU-1029%2F</url>
    <content type="text"><![CDATA[题目链接：HDU-1029kuangbin带你飞【专题十二 基础DP1 】&lt;/br&gt; 题目描述：“OK, you are not too bad, em… But you can never pass the next test.” feng5166 says. “I will tell you an odd number N, and then N integers. There will be a special integer among them, you have to tell me which integer is the special one after I tell you all the integers.” feng5166 says. “But what is the characteristic of the special integer?” Ignatius asks. “The integer will appear at least (N+1)/2 times. If you can’t find the right integer, I will kill the Princess, and you will be my dinner, too. Hahahaha…..” feng5166 says. Can you find the special integer for Ignatius? &lt;/br&gt; 思路:感觉不是DP，单纯的统计一下每个数字出现的次数即可；若某个出现的次数 &gt;= (n + 1) / 2，则其就是答案;我们用map保存每个数字出现的次数，遇到正确答案后保存正确答案即可； &lt;/br&gt; 代码:1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;#define long long long#define INF 0x3f3f3f3f#define MAX_N 100010int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n, tmp, key; while(cin &gt;&gt; n) &#123; map&lt;int, int&gt; F; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; tmp; F[tmp]++; if(F[tmp] &gt;= (n + 1) / 2) key = tmp; &#125; cout &lt;&lt; key &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞【专题十二】 基础DP1</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 539 (Div.2)]]></title>
    <url>%2F2019%2F02%2F17%2FCodeforces-539-Div2%2F</url>
    <content type="text"><![CDATA[题目链接：A题题目描述：给你一个长度n，然后从1这个点出发。每前进1个点需要花费1个单位的汽油。汽油的容量为v，然后在1-n每个点都可以加油，但是每单位的油价为i；问，最少花费； 思路签到题。显然的，越到后面油价越高，不难想到一个贪心。如果当前的油量不足以支撑全部路程，则将油加满。否则可以直接走到终点，不会有额外的花费； AC代码:1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;#define INF 0x3f3f3f3f#define long long long#define MAX_N 110int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n, v, val; cin &gt;&gt; n &gt;&gt; v; val = v; if(v &gt;= n - 1) // 容量 大于等于 路程 直接输出 路程即可；因为油单价为1 &#123; cout &lt;&lt; n - 1 &lt;&lt; endl; &#125; else &#123; n--; int ans = 2; while( n - v &gt; 0 ) // 不足以走到终点 则进行加油操作 油的价格为ans &#123; n--; val += ans; ans++; &#125; cout &lt;&lt; val &lt;&lt; endl; &#125; return 0;&#125; 题目链接：B题题目描述：给定n个数字，让你选择一组数字(a, b) 使得 a / x + b * x &lt; a + b;只能选择一组，让你计算选择之后，所有数字之和最小是多少;(可以不进行选择) 思路显然的，对于要乘以x的数字而言，越小对于结果越有利。然后我们枚举x 和 选择的那个要除以x的数字即可。记录一个最大的差值；如果这个最大的差值为正。 则答案等于 原sum - 这个差值；否则 就是不进行改变，直接输出原来的sum即可； AC代码:1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;#define INF 0x3f3f3f3f#define long long long#define MAX_N 100010int a[MAX_N];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n, MIN = INF, sum = 0;// MIN记录全部数字中最小值 sum为全部数字之和 cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; sum += a[i]; MIN = min(MIN, a[i]); &#125; int MAX = -INF; // MAX 记录改变前后的最大差值 for(int i = 2; i &lt;= 100; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; if(a[j] % i == 0) &#123; MAX = max(MAX, a[j] + MIN - a[j] / i - MIN * i);// 记录更新前后的最大差值 &#125; &#125; &#125; if(MAX &gt; 0)// 最大差值 &gt; 0 则更新 cout &lt;&lt; sum - MAX &lt;&lt; endl; else // 否则不更新 cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125; 题目链接：C题题目描述：给你n个数字，然后让你选择一段区间(l,r)使得1.(r - l + 1) % 2 == 0 即 区间长度是偶数2.前半段的异或值 = 后半段的异或值询问满足这两个条件的区间共有多少个； 思路我是真的蠢！！！我们可以考虑做一个异或前缀和fi， 然后要使区间前半段异或等于后半段异或即:a[l] ^ a[l + 1] ^ …. ^ a[mid] == a[mid + 1] ^ …..^ a[r]这个东西用前缀和的思想表示就是 f[mid] ^ f[l-1] == f[r] ^ f[mid]那么 前半段区间异或后半段区间肯定为0所以我们只需要统计 f[r] ^ f[l-1] == 0的个数即可; 至于为什么。 试想， 当f[r] ^ f[l - 1] = 0；那么，显然可以想到对于a[l] a[l+1] … a[r]对于异或值没有贡献，所以使得 f[r] == f[l - 1], 所以对于l - r 这段区间异或值肯定是0， 所以讲这一段任意分成两组后异或，结果一定相等。长度相等包含于任意长度，所以也成立然后我们记录在奇数位上出现每个值的个数，进行递推即可; PS: 偶数位 ans_2[0]要初始化为1， 因为当偶数位异或为0时，他可以从0点进行选择;统计要用long long AC代码:12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;int ans_1[1&lt;&lt;21], ans_2[1&lt;&lt;21];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); memset(ans_1, 0, sizeof(ans_1)); memset(ans_2, 0, sizeof(ans_2)); long long n, val = 0, ans = 0; cin &gt;&gt; n; ans_2[0] = 1; for(int i = 1, tmp; i &lt;= n; i++) &#123; cin &gt;&gt; tmp; val ^= tmp; if(i &amp; 1) &#123; if(ans_1[val]) ans += ans_1[val]; ans_1[val]++; &#125; else &#123; if(ans_2[val]) ans += ans_2[val]; ans_2[val]++; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2955 Brackets 【区间DP】]]></title>
    <url>%2F2019%2F02%2F16%2FPOJ-2955%E5%8C%BA%E9%97%B4DP%2F</url>
    <content type="text"><![CDATA[题目链接：POJ-2955kuangbin带你飞【专题二十二】 区间DP &lt;/br&gt; 题目描述：We give the following inductive definition of a “regular brackets” sequence: the empty sequence is a regular brackets sequence,if s is a regular brackets sequence, then (s) and [s] are regular brackets sequences, andif a and b are regular brackets sequences, then ab is a regular brackets sequence.no other sequence is a regular brackets sequenceFor instance, all of the following character sequences are regular brackets sequences: (), [], (()), ()[], ()[()] while the following character sequences are not: (, ], )(, ([)], ([(] Given a brackets sequence of characters a1a2 … an, your goal is to find the length of the longest regular brackets sequence that is a subsequence of s. That is, you wish to find the largest m such that for indices i1, i2, …, im where 1 ≤ i1 &lt; i2 &lt; … &lt; im ≤ n, ai1ai2 … aim is a regular brackets sequence. Given the initial sequence ([([]])], the longest regular brackets subsequence is [([])]. &lt;/br&gt; 思路:对于这道题，我们可以定义dp[i][j],表示从i到j的最大括号匹配数；然后我们可以发现，dp[i][j] = dp[i][k] + dp[k+1][j]我们每次更新前需要判断 s[i]是否等于s[j],如果等于 则将dp[i][j]赋值为dp[i+1][j-1]+1,不等于则赋值为dp[i+1][j-1]，然后枚举断点更新dp[i][j]即可; &lt;/br&gt; 代码:123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;#define INF 0x3f3f3f3f#define long long long#define MAX_N 110int dp[MAX_N][MAX_N];string s;bool judge(int x, int y)&#123; if( (s[x] == '(' &amp;&amp; s[y] == ')') || (s[x] == '[' &amp;&amp; s[y] == ']') ) return true; return false;&#125;int main()&#123; while(cin &gt;&gt; s, s != "end") &#123; s = ' ' + s; for(int k = 2; k &lt;= s.length(); k++) &#123; for(int i = 1; i + k - 1 &lt;= s.length(); i++) &#123; int ends = i + k - 1; dp[i][ends] = judge(i, ends) ? dp[i + 1][ends - 1] + 2 : dp[i + 1][ends - 1]; for(int j = i; j &lt; ends; j++) &#123; dp[i][ends] = max(dp[i][ends], dp[i][j] + dp[j + 1][ends]); &#125; &#125; &#125; cout &lt;&lt; dp[1][s.length()] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞【专题二十二】 区间DP</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1651 Multiplication Puzzle 【区间DP】]]></title>
    <url>%2F2019%2F02%2F16%2FPOJ-1651%E5%8C%BA%E9%97%B4DP%2F</url>
    <content type="text"><![CDATA[题目链接：POJ-1651kuangbin带你飞【专题二十二】 区间DP &lt;/br&gt; 题目描述：The multiplication puzzle is played with a row of cards, each containing a single positive integer. During the move player takes one card out of the row and scores the number of points equal to the product of the number on the card taken and the numbers on the cards on the left and on the right of it. It is not allowed to take out the first and the last card in the row. After the final move, only two cards are left in the row. The goal is to take cards in such order as to minimize the total number of scored points. For example, if cards in the row contain numbers 10 1 50 20 5, player might take a card with 1, then 20 and 50, scoring10150 + 50205 + 10505 = 500+5000+2500 = 8000 If he would take the cards in the opposite order, i.e. 50, then 20, then 1, the score would be15020 + 1205 + 1015 = 1000+100+50 = 1150. &lt;/br&gt; 思路:这题和石子合并这道题差不多，主要是要考虑下状态转移方程；要使整体合并费用最小，则中间过程的费用也是最小的；所以不难得出状态转移方程;dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + a[i]a[k]a[j]);注意：这里的i，j是开区间；举个例子 10 1 50 50 20 5 对于这组数据，我们知道首位是不可以选择的，所以我们dp[i][j]，是开区间,就是不选择i和j，只对其中间的点进行枚举;如， 要计算dp[i][j]， 我们已知dp[i][k], dp[k][j]；注意，这里是开区间，我们选择的点是k点，然后计算k点左半部分的最小费用，k点右半部分的最小费用。然后加上选择k点的费用，即可得出i到j的最小费用; 然后就是写代码，对于最外层循环，我们知道首位不能选，所以我们长度直接从3开始枚举；第二层枚举起点。注意，我这里写的是开区间(当然闭区间也可以做，但我感觉开区间更好理解)。第三层枚举选择点即可，更新dp值；还是怕不理解，上一张图片比如我们更新dp[1][7], 然后枚举点是4， 我们把枚举点当做左半部分的终点，当做有半部分的起点。然后计算左半部分的最小的有半部分的最小+当前选择后需要的费用即可更新dp[1][7]复杂度O(n^3) &lt;/br&gt; 代码:12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;#define INF 0x3f3f3f3f#define long long long#define MAX_N 110int dp[MAX_N][MAX_N], a[MAX_N];int main()&#123; int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for(int k = 3; k &lt;= n; k++) &#123; for(int i = 1; i + k - 1 &lt;= n; i++) &#123; int ends = i + k - 1; dp[i][ends] = INF; for(int j = i; j &lt; ends; j++) &#123; dp[i][ends] = min(dp[i][ends], dp[i][j] + dp[j][ends] + a[i] * a[j] * a[ends]); &#125; &#125; &#125; cout &lt;&lt; dp[1][n] &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞【专题二十二】 区间DP</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[石子归并 (区间DP)]]></title>
    <url>%2F2019%2F02%2F12%2F51nod-1021%2F</url>
    <content type="text"><![CDATA[题目链接：51nod-1021题目描述：N堆石子摆成一条线。现要将石子有次序地合并成一堆。规定每次只能选相邻的2堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的代价。计算将N堆石子合并成一堆的最小代价。 例如： 1 2 3 4，有不少合并方法1 2 3 4 =&gt; 3 3 4(3) =&gt; 6 4(9) =&gt; 10(19)1 2 3 4 =&gt; 1 5 4(5) =&gt; 1 9(14) =&gt; 10(24)1 2 3 4 =&gt; 1 2 7(7) =&gt; 3 7(10) =&gt; 10(20) 括号里面为总代价可以看出，第一种方法的代价最低，现在给出n堆石子的数量，计算最小合并代价。输入第1行：N（2 &lt;= N &lt;= 100)第2 - N + 1：N堆石子的数量（1 &lt;= A[i] &lt;= 10000)输出输出最小合并代价输入样例41234输出样例19 思路在没学习DP前，我会把这题考虑成为一个贪心题；要使合并代价最小，我们可以使权值较大的最后合并，减少权值较大的计算次数来减少最小合并代价；即局部考虑最优，然后整体最优；这是贪心的思想，但是这个结论却是错误的； 举个例子解释一下，46 5 5 6我们第一步选择合并代价最小的，即合并5 和 5新的石子堆 6 10 6 此时代价 = 10 。然后我们再次合并所需代价最小的；即合并6 10新的石子堆 16 6 代价 = 10 + 16。 然后再次合并新的石子堆 2 2 代价 = 10 + 16 + 22 = 48按照贪心的思想， 我们使得局部最优得到的解时是 48 ， 这个结果对不对呢？答案是错误的；比如我们第一步合并6，5.得到 11 5 6 代价为 11我们第二步合并5，6.得到 11 11 代价为 11 + 11我们第三步合并11,11.得到 22 代价为 11 + 11 + 22 = 44； 显然局部最优并非整体最优，所以我们得用动态规划来求解； 我们可以定义状态dp[i][j]代表从i到j的合并所需的最小代价;状态转移方程就是 dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + val);这里的val指的是当i-&gt;k已经合并为1堆，k+1-&gt;j合并为一堆；合并这两堆的代价；在本题中就是i-&gt;j的一个区间和，我们可以用前缀和来维护一下就可以; 我们在最外层枚举选取合并长度，第二层枚举起点，第三层枚举分割点即可； 注意算法复杂度为O(n^3)；计算最小代价初始化为INF；计算最大代价初始化为-INF； AC代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;#define long long long#define INF 0x3f3f3f3f#define MAX_N 110int a[MAX_N], sum[MAX_N], dp[MAX_N][MAX_N];//a记录输入数据 sum为前缀和int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++)//计算最小代价 初始为INF &#123; for(int j = i; j &lt;= n; j++) &#123; dp[i][j] = INF; &#125; &#125; for(int i = 1; i &lt;= n; i++)//录入数据并计算前缀和 &#123; cin &gt;&gt; a[i]; sum[i] = sum[i - 1] + a[i]; dp[i][i] = 0; &#125; for(int k = 1; k &lt;= n; k++)//枚举选取长度 &#123; for(int i = 1; i + k - 1 &lt;= n; i++)//枚举长度 i + k - 1即为终点 保证终点 &lt;= n &#123; int ends = i + k - 1;// ends为终点 for(int j = i; j &lt; ends; j++)// 枚举分割点 &#123; dp[i][ends] = min(dp[i][ends], dp[i][j] + dp[j+1][ends] + sum[ends] - sum[i - 1]); &#125; &#125; &#125; cout &lt;&lt; dp[1][n] &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>51nod</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 538 (Div.2)]]></title>
    <url>%2F2019%2F02%2F11%2FCodeforces-538-Div2%2F</url>
    <content type="text"><![CDATA[题目链接：A题题目描述：三个人吃葡萄，a只吃x类，b可以吃x类和y类，c的话x,y,z类都可以吃;然后输入a, b, c即a b c至少需要吃的个数然后输入x, y, z,代表每种葡萄的个数 思路签到题。我们可以先判断是否满足a的需求，如果不满足直接输出NO；否则 判断剩下的x + y &gt;= b 如果成立 则 判断 x + y + z - b &gt;= c是否成立 成立则输出YES， 其他情况输出的是NO 即x &gt;= a &amp;&amp; x + y - a &gt;= b &amp;&amp; x + y + z - a - b &gt;= c是否成立成立输出YES， 否则输出NO AC代码:1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;#define long long long#define INF 0x3f3f3f3f#define MAX_N 200010#define MAX_M 1000010int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int a, b, c, x, y, z; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; x &gt;&gt; y &gt;&gt; z; if(x &gt;= a &amp;&amp; x + y - a &gt;= b &amp;&amp; x + y + z - a - b &gt;= c) cout &lt;&lt; "YES" &lt;&lt; endl; else cout &lt;&lt; "NO" &lt;&lt; endl; return 0;&#125; 题目链接：B题题目描述：给定n, m, k; 代表着数组元素的个数， 拆分后每个集合包含元素的最小数目，拆分为k个集合;然后求出拆分后每个集合最大的m项的和，将着k个集合的最大和累加，求出最大和是多少，并给出拆分的位置; 思路我们会有k X m个数字相加得到最大的和； 所以我们可以对数组进行nlogn排序后，得到前 k X m 大的数字；求和得到最大值；然后对原数组进行遍历， 当在前 k X m大的数字长度到达m后，就将这个位置看做拆分点即可; AC代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;#define long long long#define INF 0x3f3f3f3f#define MAX_N 200010#define MAX_M 1000010long a[MAX_N], b[MAX_N];bool cmp(long a, long b)&#123; return a &gt; b;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; b[i] = a[i]; &#125; sort(b + 1, b + 1 + n, cmp); map&lt;long, long&gt; F; long val = 0; for(int i = 1; i &lt;= k * m; i++) &#123; F[b[i]]++; val += b[i]; &#125; cout &lt;&lt; val &lt;&lt; endl; int cnt = 0; for(int i = 1, ans = 0; i &lt;= n; i++) &#123; if(F[a[i]]) &#123; ans++; F[a[i]]--; &#125; if(ans == m &amp;&amp; cnt &lt; k - 1) &#123; cout &lt;&lt; i &lt;&lt; " "; cnt++; ans = 0; &#125; &#125; return 0;&#125; 题目链接：C题题目描述：题意很简单，给出一个n，一个b；问你n的阶乘转为b进制后，末尾一共有多少个0；注意，此题数据范围很大，需要用 long long存储 思路此题我们可以转化为 求 n!中 含有多少个因子b。 至于为啥可以这样做， 我们以栗子1看一看;当 n = 6 ，b = 9时； 我们转9进制是这样一个过程首先计算出 6 X 5 X 4 X 3 X 2 X 1 然后不断除以9取余；那这个过程能不能简化呢？ 当然是可以的， 那么 我们如何使末尾产生0呢？我们发现 如果 K 是 9的整数倍， 那么取余必定为0； 所以， 如果计算过程中出现了9的倍数， 那么就会在末尾产生一个0； 所以我们可以对b进行素因数分解， 然后对n！分解， 统计出有多少组乘积满足即可； 我们 素因数分解b后， 统计最小满足的个数即为答案； 比如 6 = 2 X 3；若 n！ = 3 X 3 X 2 X 1 这样 我们只有一对满足；意会一下； AC代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;#define long long long#define INF 0x3f3f3f3f#define MAX_N 100010long res[MAX_N], num[MAX_N];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); long n, b, k = 0; cin &gt;&gt; n &gt;&gt; b; for(int i = 2; i &lt;= b / i; i++) &#123; if(b % i == 0) &#123; int ans = 0; while(b % i == 0) &#123; ans++; b /= i; &#125; res[++k] = i; num[k] = ans; &#125; &#125; if(b != 1) &#123; res[++k] = b; num[k] = 1; &#125; long flag = 1, val = 0; for(int i = 1; i &lt;= k; i++) &#123; long tmp = n, sum = 0; while(tmp) &#123; sum += tmp / res[i]; tmp /= res[i]; &#125; if(flag) &#123; flag = 0; val = sum / num[i]; &#125; else &#123; val = min(val, sum / num[i]); &#125; &#125; cout &lt;&lt; val &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDOJ-3466 Proud Merchants【01背包】]]></title>
    <url>%2F2019%2F01%2F31%2FHDU-3466%2F</url>
    <content type="text"><![CDATA[题目链接：HDU-3466题目描述：Problem DescriptionRecently, iSea went to an ancient country. For such a long time, it was the most wealthy and powerful kingdom in the world. As a result, the people in this country are still very proud even if their nation hasn’t been so wealthy any more.The merchants were the most typical, each of them only sold exactly one item, the price was Pi, but they would refuse to make a trade with you if your money were less than Qi, and iSea evaluated every item a value Vi.If he had M units of money, what’s the maximum value iSea could get? InputThere are several test cases in the input. Each test case begin with two integers N, M (1 ≤ N ≤ 500, 1 ≤ M ≤ 5000), indicating the items’ number and the initial money.Then N lines follow, each line contains three numbers Pi, Qi and Vi (1 ≤ Pi ≤ Qi ≤ 100, 1 ≤ Vi ≤ 1000), their meaning is in the description. The input terminates by end of file marker. OutputFor each test case, output one integer, indicating maximum value iSea could get. Sample Input2 1010 15 105 10 53 105 10 53 5 62 7 3 Sample Output511 思路感觉是贪心+DP？ 因为01背包的状态转移是根据前i-1件物品的选择来确定第i种状态，所以对于我们这道题而言我们得先更新出那些p与q差值较小的状态，然后在确定那些p与q差值较大的状态；如果先更新差值较大的状态的话，可能会遗漏一部分状态，使得答案不正确； 所以我们先排序，然后进行01背包，就可以做到不重不漏； AC代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;#define long long long#define MAX_N 100010#define INF 0x3f3f3f3fint dp[MAX_N];struct Node&#123; int p, q, v;&#125;S[5050];bool cmp(Node a, Node b)&#123; return a.p - a.q &gt; b.p - b.q;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n, T; while(cin &gt;&gt; n &gt;&gt; T) &#123; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; S[i].p &gt;&gt; S[i].q &gt;&gt; S[i].v; &#125; sort(S+1, S+1+n, cmp); memset(dp, 0, sizeof(dp)); for(int i = 1; i &lt;= n; i++) &#123; for(int j = T; j &gt;= S[i].q; j--) &#123; dp[j] = max(dp[j], dp[j - S[i].p] + S[i].v); &#125; &#125; cout &lt;&lt; dp[T] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDOJ-2602 Bone Collector【01背包】]]></title>
    <url>%2F2019%2F01%2F31%2FHDU-2602%2F</url>
    <content type="text"><![CDATA[题目链接：HDU-2602题目描述：Problem DescriptionMany years ago , in Teddy’s hometown there was a man who was called “Bone Collector”. This man like to collect varies of bones , such as dog’s , cow’s , also he went to the grave …The bone collector had a big bag with a volume of V ,and along his trip of collecting there are a lot of bones , obviously , different bone has different value and different volume, now given the each bone’s value along his trip , can you calculate out the maximum of the total value the bone collector can get ? InputThe first line contain a integer T , the number of cases.Followed by T cases , each case three lines , the first line contain two integer N , V, (N &lt;= 1000 , V &lt;= 1000 )representing the number of bones and the volume of his bag. And the second line contain N integers representing the value of each bone. The third line contain N integers representing the volume of each bone. OutputOne integer per line representing the maximum of the total value (this number will be less than 231). Sample Input15 101 2 3 4 55 4 3 2 1 Sample Output14 思路裸的01背包，没啥说的。 AC代码:12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;#define long long long#define MAX_N 100010#define INF 0x3f3f3f3fint v[1010], w[1010], dp[MAX_N];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t; cin &gt;&gt; t; while(t--) &#123; memset(dp, 0, sizeof(dp)); int n, T; cin &gt;&gt; n &gt;&gt; T; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; v[i]; &#125; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; w[i]; &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = T; j &gt;= w[i]; j--) &#123; dp[j] = max(dp[j], dp[j - w[i]] + v[i]); &#125; &#125; cout &lt;&lt; dp[T] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDOJ-2546 饭卡【01背包】]]></title>
    <url>%2F2019%2F01%2F30%2FHDU-2546%2F</url>
    <content type="text"><![CDATA[题目链接：HDU-2546题目描述：Problem Description电子科大本部食堂的饭卡有一种很诡异的设计，即在购买之前判断余额。如果购买一个商品之前，卡上的剩余金额大于或等于5元，就一定可以购买成功（即使购买后卡上余额为负），否则无法购买（即使金额足够）。所以大家都希望尽量使卡上的余额最少。某天，食堂中有n种菜出售，每种菜可购买一次。已知每种菜的价格以及卡上的余额，问最少可使卡上的余额为多少。 Input多组数据。对于每组数据：第一行为正整数n，表示菜的数量。n&lt;=1000。第二行包括n个正整数，表示每种菜的价格。价格不超过50。第三行包括一个正整数m，表示卡上的余额。m&lt;=1000。 n=0表示数据结束。 Output对于每组输入,输出一行,包含一个整数，表示卡上可能的最小余额。 Sample Input1505101 2 3 2 1 1 2 3 2 1500 Sample Output-4532 思路题意很容易理解，我们可以先保留一个最大可以选择的菜； 然后最后减去这个价值最大的菜即可； 如果 钱数 &lt; 5 则直接输出当前钱数;如果 钱数 &gt;= 5 则我们先给钱数 - 5， 保证最大价值的菜可以取到， 然后进行01背包， 计算出 当钱数 - 5后的可以取到的最大价值是多少， 最后减去价值最大的菜即是答案; AC代码:123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;#define long long long#define INF 0x3f3f3f3f#define MAX_N 100010int v[1010], dp[50050];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n; while(cin &gt;&gt; n, n) &#123; memset(dp, 0, sizeof(dp)); for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; v[i]; &#125; sort(v + 1, v + 1 + n); int k; cin &gt;&gt; k; if(k &lt; 5) &#123; cout &lt;&lt; k &lt;&lt; endl; continue; &#125; k -= 5; for(int i = 1; i &lt; n; i++) &#123; for(int j = k; j &gt;= v[i]; j--) &#123; dp[j] = max(dp[j], dp[j - v[i]] + v[i]); &#125; &#125; cout &lt;&lt; k + 5 - dp[k] - v[n] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDOJ-1059 Dividing【多重背包】]]></title>
    <url>%2F2019%2F01%2F28%2FHDU-1059%2F</url>
    <content type="text"><![CDATA[题目链接：HDU-1059题目描述：Problem DescriptionMarsha and Bill own a collection of marbles. They want to split the collection among themselves so that both receive an equal share of the marbles. This would be easy if all the marbles had the same value, because then they could just split the collection in half. But unfortunately, some of the marbles are larger, or more beautiful than others. So, Marsha and Bill start by assigning a value, a natural number between one and six, to each marble. Now they want to divide the marbles so that each of them gets the same total value.Unfortunately, they realize that it might be impossible to divide the marbles in this way (even if the total value of all marbles is even). For example, if there are one marble of value 1, one of value 3 and two of value 4, then they cannot be split into sets of equal value. So, they ask you to write a program that checks whether there is a fair partition of the marbles. InputEach line in the input describes one collection of marbles to be divided. The lines consist of six non-negative integers n1, n2, …, n6, where ni is the number of marbles of value i. So, the example from above would be described by the input-line ``1 0 1 2 0 0’’. The maximum total number of marbles will be 20000. The last line of the input file will be ``0 0 0 0 0 0’’; do not process this line. OutputFor each colletcion, output Collection #k:&#39;&#39;, where k is the number of the test case, and then eitherCan be divided.’’ or ``Can’t be divided.’’. Output a blank line after each test case. Sample Input1 0 1 2 0 01 0 0 0 1 10 0 0 0 0 0 Sample OutputCollection #1:Can’t be divided. Collection #2:Can be divided. 思路这道题的题意是给定你6种玻璃珠的个数，然后每个玻璃珠的价值都是1.2…6；然后询问你，能不能分配玻璃珠，使得拆分后，两堆玻璃珠的价值相同； 对于这道题，我们可以先统计出所有玻璃珠的总价值val，当总价值是奇数时，显然不可能均分。然后当总价值为偶数时，我们可以假设有一个容量为val/2的背包，然后对这个背包进行装物品； 如果最后加入的最大价值 = val/2 则可以平分，否则不可以均分; AC代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;#define long long long#define INF 0x3f3f3f3f#define MAX_N 20010int dp[1000010];int v[10], w[10];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int ans = 0; int flag = 0; while(cin &gt;&gt; w[1] &gt;&gt; w[2] &gt;&gt; w[3] &gt;&gt; w[4] &gt;&gt; w[5] &gt;&gt; w[6]) &#123; ans++; if(flag) cout &lt;&lt; endl; flag = 1; memset(dp, 0, sizeof(dp)); int val = 0; for(int i = 1; i &lt;= 6; i++) &#123; val += w[i] * i; &#125; if(val == 0) break; cout &lt;&lt; "Collection #" &lt;&lt; ans &lt;&lt; ":" &lt;&lt; endl; if(val &amp; 1) &#123; cout &lt;&lt; "Can't be divided." &lt;&lt; endl; continue; &#125; for(int i = 1; i &lt;= 6; i++) &#123; int tmp = w[i]; for(int k = 1; ; k &lt;&lt;= 1) &#123; bool flag = 0; if(k &gt; tmp) &#123; k = tmp; flag = 1; &#125; for(int j = val / 2; j &gt;= k * i; j--) &#123; dp[j] = max(dp[j], dp[j - k * i] + k * i); &#125; tmp -= k; if(flag) break; &#125; &#125; if(dp[val / 2] == val / 2) cout &lt;&lt; "Can be divided." &lt;&lt; endl; else cout &lt;&lt; "Can't be divided." &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDOJ-2191【多重背包】]]></title>
    <url>%2F2019%2F01%2F28%2FHDU-2191%2F</url>
    <content type="text"><![CDATA[题目链接：HDU-2191题目描述：急！灾区的食物依然短缺！为了挽救灾区同胞的生命，心系灾区同胞的你准备自己采购一些粮食支援灾区，现在假设你一共有资金n元，而市场有m种大米，每种大米都是袋装产品，其价格不等，并且只能整袋购买。请问：你用有限的资金最多能采购多少公斤粮食呢？ Input输入数据首先包含一个正整数C，表示有C组测试用例，每组测试用例的第一行是两个整数n和m(1&lt;=n&lt;=100, 1&lt;=m&lt;=100),分别表示经费的金额和大米的种类，然后是m行数据，每行包含3个数p，h和c(1&lt;=p&lt;=20,1&lt;=h&lt;=200,1&lt;=c&lt;=20)，分别表示每袋的价格、每袋的重量以及对应种类大米的袋数。 Output对于每组测试数据，请输出能够购买大米的最多重量，你可以假设经费买不光所有的大米，并且经费你可以不用完。每个实例的输出占一行。 Sample Input18 22 100 44 100 2 Sample Output400 思路这道题类似于01背包，但由于规定每种物品的种类数有上限，所以是一道多重背包问题。这里列举一下三种背包的不同之处;01背包 每一种物品只有选择和不选两种状态；完全背包每一种物品可以选择0,1,2,3,4….n件； n w[i] &lt;= T， 就是最多选择 重量 个数 小于等于 容量个物品;多重背包规定了每种物品的选取上限，可以取0,1,2,3….MAX(i)件； 这是只说一下多重背包，多重背包可以拆分为多个01背包问题进行解决，即一个物品如果可以选择多个，那么我们可以将这个物品拆分为max(i)个物品，每一种选择都当做一种新的物品来看待，这样子就可以解决多重背包； 朴素的多重背包算法:1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;#define long long long#define MAX_N 100010#define INF 0x3f3f3f3fint dp[MAX_N];int v[110], w[110], k[110];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t; cin &gt;&gt; t; while(t--) &#123; memset(dp, 0, sizeof(dp)); int T, n; cin &gt;&gt; T &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; w[i] &gt;&gt; v[i] &gt;&gt; k[i]; &#125; for(int i = 1; i &lt;= n; i++)//枚举每个物品 &#123; for(int j = 1; j &lt;= k[i]; j++)//将第i种物品拆分为 k[i]种不同的物品 &#123; for(int p = T; p &gt;= w[i]; p--)//状态转移 &#123; dp[p] = max(dp[p], dp[p - w[i]] + v[i]); &#125; &#125; &#125; cout &lt;&lt; dp[T] &lt;&lt; endl; &#125; return 0;&#125; 当然，也可以在转移的过程中，枚举选取数量;代码如下1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;#define long long long#define MAX_N 100010#define INF 0x3f3f3f3fint dp[MAX_N];int v[110], w[110], k[110];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t; cin &gt;&gt; t; while(t--) &#123; memset(dp, 0, sizeof(dp)); int T, n; cin &gt;&gt; T &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; w[i] &gt;&gt; v[i] &gt;&gt; k[i]; &#125; for(int i = 1; i &lt;= n; i++)//枚举每个物品 &#123; for(int j = T; j &gt;= 0; j--)// 状态转移 &#123; for(int p = 1; p &lt;= k[i] &amp;&amp; p * w[i] &lt;= j; p++)// 枚举选择的数量 &#123; dp[j] = max(dp[j], dp[j - p * w[i]] + p * v[i]); &#125; &#125; &#125; cout &lt;&lt; dp[T] &lt;&lt; endl; &#125; return 0;&#125; 因为这到题的数据范围很小，所以用朴素的算法也可以通过；但是当数据范围变大的时候，朴素的算法表现的就不太好了。所以我们得做一些优化；我们可以用二进制进行优化。 比如 某一个物品最多可以选取13个， 我们朴素的做法是 将其拆分为13个原物品， 然后进行01背包； 这个过程我们可以优化， 试想 1， 2， 4， 6。是否可以枚举出1-13所有的状态呢？ 答案是肯定的，1-13无论是哪个状态，我们都可以对1,2,4,6这4个状态进行合并得到；这样就降低了原复杂度。 原来枚举O(n),现在只需要枚举O(logN)，大大降低了时间复杂度;OK, 写一下代码; 二进制优化代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;#define long long long#define MAX_N 100010#define INF 0x3f3f3f3fint dp[MAX_N];int v[110], w[110], k[110];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t; cin &gt;&gt; t; while(t--) &#123; memset(dp, 0, sizeof(dp)); int T, n; cin &gt;&gt; T &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; w[i] &gt;&gt; v[i] &gt;&gt; k[i]; &#125; for(int i = 1; i &lt;= n; i++)//枚举每一种物品 &#123; int tmp = k[i]; for(int p = 1; p &lt;= tmp; p &lt;&lt;= 1)//二进制拆分 &#123; for(int j = T; j &gt;= p * w[i]; j--)//状态转移 &#123; dp[j] = max(dp[j], dp[j - p * w[i]] + p * v[i]); &#125; tmp -= p; &#125; if(tmp) &#123; for(int j = T; j &gt;= tmp * w[i]; j--) &#123; dp[j] = max(dp[j], dp[j - tmp * w[i]] + tmp * v[i]); &#125; &#125; &#125; cout &lt;&lt; dp[T] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭电Oj3555 Bomb【数位DP】]]></title>
    <url>%2F2019%2F01%2F27%2FHDU-3555%2F</url>
    <content type="text"><![CDATA[题目链接：HDU-2089题目描述：BombTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 131072/65536 K (Java/Others)Total Submission(s): 24909 Accepted Submission(s): 9408 Problem DescriptionThe counter-terrorists found a time bomb in the dust. But this time the terrorists improve on the time bomb. The number sequence of the time bomb counts from 1 to N. If the current number sequence includes the sub-sequence “49”, the power of the blast would add one point.Now the counter-terrorist knows the number N. They want to know the final points of the power. Can you help them? InputThe first line of input consists of an integer T (1 &lt;= T &lt;= 10000), indicating the number of test cases. For each test case, there will be an integer N (1 &lt;= N &lt;= 2^63-1) as the description. The input terminates by end of file marker. OutputFor each test case, output an integer indicating the final points of the power. Sample Input3150500 Sample Output0115 思路数位DP解决的是类似于 给你一个区间L到R，然后让你求出满足某个条件P的数字有多少个；然后在我理解中，数位DP就是记忆化搜索+dfs， 感觉名字是DP，其实的实质是dfs+记忆化搜索; 举个栗子:我们要找 0 - 9999 之间没有62的数字有多少个;用朴素的算法可能就是暴力遍历每一个元素， 然后判断该数字是否满足这个条件P， 但是题目的数据范围一般都是 1 &lt;= l &lt;= r &lt;= 10 ^ 18，暴力肯定会T掉，所以我们需要更优的做法；然后数位DP要做的就是优化这个数shu（二声）数（四声）的过程;上图说明:我们可以将0 - 9999抽像为选择每一位数字的过程。然后我们可以优化这个数数的过程；试想， （以之前栗子为栗子），当前两位已经选定为 00，然后当第三位选择0 ， 1， 2， 3， 4， 5， 7， 8 ，9的种类数是一样多的，我们只需要统计一次即可，其他的都一样无需重复统计；然后再往上一层。 当第一位选定为 0 时， 我们统计出此时满足条件P的方案数。那么 当首位为 1， 2， 3， 4， 5， 7， 8,9， 的方案数都和首位为0时的方案数一致，我们无需重复统计就可以得出答案；OK， 这个就是数位DP， 然后需要注意一些细节，就是满足P的方案统计和方案上限的统计；（这种都需要重新统计一下）;具体的过程我感觉我码字说不清楚，这里推荐一个教的很好的视频，大家可以学习一下; 数位DP学习视频此题是裸的数位DP。稍微学习一下就可以过了; AC代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;#define long long long#define INF 0x3f3f3f3f#define MAX_N 100010long dp[50][2];long digit[50];long dfs(long k, bool if4, bool limit)&#123; if(k == 0) return 1; if(!limit &amp;&amp; dp[k][if4]) return dp[k][if4]; long cnt = 0, up_bound = (limit ? digit[k] : 9); for(int i = 0; i &lt;= up_bound; i++) &#123; if(if4 &amp;&amp; i == 9) continue; cnt += dfs(k - 1, i == 4, limit &amp;&amp; i == digit[k]); &#125; if(!limit) dp[k][if4] = cnt; return cnt;&#125;long solve(long num)&#123; long k = 0; while(num) &#123; digit[++k] = num % 10; num /= 10; &#125; return dfs(k, false, true);&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t; cin &gt;&gt; t; while(t--) &#123; long n; cin &gt;&gt; n; cout &lt;&lt; n + 1 - solve(n) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不要62 【数位DP】]]></title>
    <url>%2F2019%2F01%2F27%2FHDU-2089%2F</url>
    <content type="text"><![CDATA[题目链接：HDU-2089题目描述：Problem Description杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。不吉利的数字为所有含有4或62的号码。例如：62315 73418 88914都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。 Input输入的都是整数对n、m（0&lt;n≤m&lt;1000000），如果遇到都是0的整数对，则输入结束。 Output对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。 Sample Input1 1000 0 Sample Output80 思路数位DP解决的是类似于 给你一个区间L到R，然后让你求出满足某个条件P的数字有多少个；然后在我理解中，数位DP就是记忆化搜索+dfs， 感觉名字是DP，其实的实质是dfs+记忆化搜索; 举个栗子:我们要找 0 - 9999 之间没有62的数字有多少个;用朴素的算法可能就是暴力遍历每一个元素， 然后判断该数字是否满足这个条件P， 但是题目的数据范围一般都是 1 &lt;= l &lt;= r &lt;= 10 ^ 18，暴力肯定会T掉，所以我们需要更优的做法；然后数位DP要做的就是优化这个数shu（二声）数（四声）的过程;上图说明:我们可以将0 - 9999抽像为选择每一位数字的过程。然后我们可以优化这个数数的过程；试想， （以之前栗子为栗子），当前两位已经选定为 00，然后当第三位选择0 ， 1， 2， 3， 4， 5， 7， 8 ，9的种类数是一样多的，我们只需要统计一次即可，其他的都一样无需重复统计；然后再往上一层。 当第一位选定为 0 时， 我们统计出此时满足条件P的方案数。那么 当首位为 1， 2， 3， 4， 5， 7， 8,9， 的方案数都和首位为0时的方案数一致，我们无需重复统计就可以得出答案；OK， 这个就是数位DP， 然后需要注意一些细节，就是满足P的方案统计和方案上限的统计；（这种都需要重新统计一下）;具体的过程我感觉我码字说不清楚，这里推荐一个教的很好的视频，大家可以学习一下; 数位DP学习视频此题是裸的数位DP。稍微学习一下就可以过了; AC代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;#define long long long#define INF 0x3f3f3f3f#define MAX_N 100010long dp[50][2];long digit[50];long dfs(long k, bool if6, bool limit)&#123; if(k == 0) return 1; if(!limit &amp;&amp; dp[k][if6]) &#123; return dp[k][if6]; &#125; long cnt = 0, up_bound(limit ? digit[k] : 9); for(int i = 0; i &lt;= up_bound; i++) &#123; if((if6 &amp;&amp; i == 2) || i == 4) continue; cnt += dfs(k - 1, i == 6, limit &amp;&amp; i == digit[k]); &#125; if(!limit) &#123; dp[k][if6] = cnt; &#125; return cnt;&#125;long solve(long num)&#123; long k = 0; while(num) &#123; digit[++k] = num % 10; num /= 10; &#125; return dfs(k, false, true);&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); long l, r; while(cin &gt;&gt; l &gt;&gt; r, l + r) &#123; cout &lt;&lt; solve(r) - solve(l - 1) &lt;&lt; endl; &#125; return 0;&#125;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑妹的游戏I]]></title>
    <url>%2F2019%2F01%2F17%2F%E7%89%9B%E5%AE%A2%E7%BD%91-16766%2F</url>
    <content type="text"><![CDATA[题目链接：牛客网-16766题目描述：链接：https://ac.nowcoder.com/acm/problem/16766来源：牛客网 黑妹最近在玩一个有趣的游戏，游戏规则是这样的：刚开始黑板上有三个不同的初始数字，然后黑妹每一次可以选择黑板上的两个不同的数字，然后计算出这两个不同数字之差的绝对值，如果黑板上没有这个数字，那么就把这个新数字写在黑板上。黑妹已经玩腻了这个游戏，现在黑妹想知道她最多能添加多少个数字。输入描述:第一行一个整数T表示数据组数。(1≤T≤100000)接下来T行每行三个整数 a，b，c 表示黑板上的三个初始数字。(1≤a,b,c≤10^18，1≤a,b,c≤10^18)输出描述:对于每组数据输出一行表示答案。示例1输入23 2 16 5 4输出03 思路大概是一道思维题？ 我们举个例子。 假如初始的三个数字是8 6 4.我们发现 可以生成的新数字只有2，因为8 6 4这三个数字的共同最大公约数为2， 所以最后的数字只能是 8 - 2 * k;(k &lt; 8 / 2); 这个应该可以理解吧， 所以总共的数字 为 8 / 2 = 4 之前已经有了3个，所以只能新生成1个； 再举个栗子， 8 6 5;此时的最大公约数为 1；不难发现，只要我们生成了1， 我们就可以从8 依次减1递推到1； 总个数为 8 / 1减去之前已经有的3个，答案为5. 通过栗子，不难得出结论； 答案 = 三个数最大的 / 三个数的最大公约数 - 3; PS:注意数据范围 得开long long AC代码:12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;#define long long longint main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t; cin &gt;&gt; t; while(t--) &#123; long a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; long MAX = max(a, max(b, c)); long k = __gcd(a, __gcd(b, c)); cout &lt;&lt; MAX / k - 3 &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第43届ACM亚洲区域总决赛赛(EC-Final)总结]]></title>
    <url>%2F2019%2F01%2F03%2FEC-Final%20%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[现在才来填坑，感觉有点太晚了。 正文青岛铁了后就知道自己菜，本来也没对EC-Final报太大的希望，但由于今年的去年的瞎jb规则，导致很多学校的一队二队没办法来打。 知道了这个消息心里还是抱有一定的希望的，对自己而言确实是个很好拿牌的机会(但最后还是没拿到) 热身赛我校本就在西安，所以先考了四级然后去打的热身赛；由于这是我第一次打EC-Final，自己是弱校，做坐到自己的位置，各种慌。（如果没热身赛，我怀疑正赛我会紧张好久的2333感谢热身赛！！！） 对面浙大，后面是成电，就是那种你随便往哪里看，都是名校，哇，那种感觉，真的觉得自己超级菜。。。。 热身赛先过一道简单的签到，然后和队友一起推那个大雁塔的高度！（高中数学啊，都忘完了，还好队友给力！），代入队友的公式一发就过了；对面浙大大概不屑于做签到。然后我们吊打浙大（这个可以吹一年，hahha） 正赛正赛我们带了一堆板子，最后也没用上；一开始队友们读题，我在打板子和shell脚本；大概4,5分钟后，刷一下榜，大家好像开的D，随便读一下题，发现只要判断n和m的大小关系即可，我马上写完准备交，队友提醒我，要不要检查一下。 我刷了下榜看到已经过了100多队有坑，直接交了。很快就返回了绿油油的yes； 在刷榜，我们决定开L，但由于队友可能题意也理解的不是很清楚，我英语又很菜，只能硬着上，写了一发可以过样例的代码（只考虑了同一站和对面有边的情况），交了一发，返回wa，凉凉， 然后我又改改修修，就这样wa了5发（2发因为没关freopen，血亏啊，上次青岛我也把字母打错wa了一发，我真是要稳一稳啊！）， 然后我觉着我要冷静一下，队友上机写I，他当时想的是贪心。但是这个肯定是假的。我想了一会，然后看了看其他队的question，有一个是能不能一次全部用完啥的，这个提醒我了，想到了还有没边直接相连，需要跳3次，然后我上机改了改，过了；哇，过的那一刻真舒服。然后我们刷榜看到计算几何过的挺多，我们就开了计算几何，队友不愧是专业第一啊（好像高数竞赛省一），是真的牛皮，一会就推出来了结果，我和他确定是不是要小于10的-6次方就可以了，他大概给我说了下对； 我以为是我输出的结果和标称求一个差，这个差小于10的-。也没指定精度就直接交了；woc，然后wa掉了！！！！！和他确认后，我指定了下精度，就过了；队友牛逼； 然后此时我们还剩下大概1个小时，I题我看着T &lt; 10, n &lt; 100 就感觉这是个dp，但是我们三的dp都很弱啊，没法开。我是不想写了，想着听天由命吧。队友想着暴力dfs，3^100! 他上机写，最后大概交了一发，应该是wa了。最后我们数着打星对队，希望可以水个牌子；但最后还是差个10多名吧！ 游戏体验很好啊，菜是原罪； 这个寒假大概要走点工程方向了，不然找不到工作了，感觉只能奔着明年稳铜的目标去了！！！ 颁奖杜老师nb！没见到偶像吉老师。。。 弱校的合照]]></content>
      <categories>
        <category>比赛总结</category>
      </categories>
      <tags>
        <tag>-第43届ACM亚洲区域赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合数取模总结]]></title>
    <url>%2F2018%2F12%2F07%2F%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[题目描述：在ACM竞赛现在叫JB竞赛？中，经常会遇到组合数取模的题目；就我现在的水平而言，大概分为以下三类，以后遇到新的方法会在做补充； 第一种：n和m都较小 （&lt;1000）,在这个数据范围内，我们可以直接用杨辉三角O(n^2)的复杂度内预处理出所有的组合数，然后直接输出即可；典型例题就是给你一个二项式，例如: 这样子的题目，组合数我们可以O(n^2)预处理出来（利用递推式子来处理）。a^b之类的东西我们可以用快速幂logn的复杂度内处理出来; 这种题由于数据范围过小，当水题处理就行;代码大概是这样: 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;#define MOD 10007#define long long longlong pow_MOD(long a, long b)&#123; long tmp = 1; while(b) &#123; if(b &amp; 1) &#123; tmp = (tmp % MOD * a % MOD) % MOD; &#125; a = (a * a) % MOD; b &gt;&gt;= 1; &#125; return tmp;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int p, q, a, b, k; cin &gt;&gt; p &gt;&gt; q &gt;&gt; k &gt;&gt; a &gt;&gt; b; long tmp = 1; for(int i = 1; i &lt;= b; i++) &#123; if(tmp % i == 0) &#123; tmp = tmp / i * (k - i + 1) % MOD; &#125; else &#123; tmp = tmp * (k - i + 1) / i % MOD; &#125; &#125; //cout &lt;&lt; "tmp = " &lt;&lt; tmp &lt;&lt; endl; cout &lt;&lt; ((tmp % MOD) * (pow_MOD(p, a) % MOD) * (pow_MOD(q, b) % MOD)) % MOD; return 0;&#125; 第二种给定的n和m不太大 （1e5范围左右），给定的p较大(一般是1e9+7);这时候如果我们还是利用杨辉三角之类的东西就不行了；第一空间不足，没办法开出来1e51e5这么大的数组，第二在时间也是不允许的n^2的复杂度，肯定会T掉；所以我们需要利用线性方法递推组合数 公式大概是这样;就是可以依赖前一项的组合数推出下一项的组合数，在O(n)的时间内可以出结果；但是，这里由于在求余过程中，除法是不具有同余性；即(a + b) % mod = (a % mod + b % mod) % mod(a - b) % mod = (a % mod - b % mod) % mod(a b) % mod = (a % mod b % mod) % mod加法、减法、乘法都是有这个性质，只有除法不满足，所以中间直接模的话会出错；所以我们得预处理一下1-n关于p的逆元，把除法换为乘法。这样就没啥问题了；显然，他一共要走n+m-2步，所以答案就是；但是受限于数据范围，我们得先预处理一下逆元，然后线性推组合数即可；对了，处理逆元有很多种办法；如果要求单个数字的逆元我们可以用扩展欧几里得或者快速幂（建议exgcd，更快点）；如果要处理的是一堆，就是1-n所有数字的逆元，我们可以用欧拉筛打出逆元表，或者直接利用递推inv[i] = (p - p / i) (inv[p % i]) % p;这样子；经典问题就是走迷宫之类的东西,例如：我们先用线性推预处理逆元，然后用组合数的递推式递推组合数，即可AC 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;#define long long long#define MOD 1000000007#define N 1000010long inv[N];int main()&#123; long n, m; cin &gt;&gt; n &gt;&gt; m; inv[1] = 1; if(n &gt; m) swap(n, m); for(int i = 2; i &lt;= n; i++) &#123; inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD; &#125; long tmp = 1, val = n + m - 2; for(int i = 1; i &lt;= n-1; i++) &#123; tmp = tmp % MOD * (val - i + 1) % MOD * inv[i] % MOD; &#125; cout &lt;&lt; tmp &lt;&lt; endl; return 0;&#125; 第三种第三种就是n和m都较大(1e9左右)， p较小(1e5左右)；这种情况下，第二种做法都不行了，这时候我们得用Lucas定理来解决；Lucas就是把大化小把一个大的组合数拆分为很多小的组合数乘积的结果;有兴趣可以了解一下；就是将n，m都改为p进制，然后累乘；这样子；HDU-3037 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;#define long long long#define N 100010long a[N], p;long exgcd(long a, long b, long &amp;x, long &amp;y)&#123; if(b == 0) &#123; x = 1; y = 0; return a; &#125; long r = exgcd(b, a%b, x, y); long tmp = x; x = y; y = tmp - a / b * y; return r;&#125;long C(long n, long m)&#123; if(n &lt; m) return 0; long x, x1, y, y1; exgcd(a[m], p, x, y); exgcd(a[n-m], p, x1, y1); x = (x + p) % p; x1 = (x1 + p) % p; return ((a[n] % p) * x % p * x1 % p) % p;&#125;long Lucas(long n, long m)&#123; if(!m) return 1; return C(n % p, m % p) * Lucas(n / p, m / p) % p;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--) &#123; long n, m; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; a[0] = 1; for(int i = 1; i &lt;= p; i++) &#123; a[i] = (a[i-1] * i) % p; &#125; cout &lt;&lt; Lucas(n+m, m) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Square Coins]]></title>
    <url>%2F2018%2F11%2F30%2FHDU-1398%2F</url>
    <content type="text"><![CDATA[题目链接：HDU-1398&lt;/br&gt; 题目描述：Problem DescriptionPeople in Silverland use square coins. Not only they have square shapes but also their values are square numbers. Coins with values of all square numbers up to 289 (=17^2), i.e., 1-credit coins, 4-credit coins, 9-credit coins, …, and 289-credit coins, are available in Silverland.There are four combinations of coins to pay ten credits: ten 1-credit coins,one 4-credit coin and six 1-credit coins,two 4-credit coins and two 1-credit coins, andone 9-credit coin and one 1-credit coin. Your mission is to count the number of ways to pay a given amount using coins of Silverland. InputThe input consists of lines each containing an integer meaning an amount to be paid, followed by a line containing a zero. You may assume that all the amounts are positive and less than 300. &lt;/br&gt; 思路题意很明显了，就是告诉你一个数字，询问有多少种方式组成这个数； 我们这里运用母函数求解； 如果你不了解母函数，以下为推荐的两篇学习母函数的博客母函数学习母函数学习2 母函数在我的理解就是把组合问题的加法法则和幂级数的乘幂对应起来，这样就可以解决一些问题； 到最后，指数的大小就是(价值，质量等)，系数就是方案数； 当然，他可以优化一下，就是记录每个式子当前的最高次幂和上一次的最高次幂；可以节省一定的时间； 在本题中，我们用v数组保存每个数的价值，然后n1表示最小选择的数量，这里默认为0，n2表示当前数最多有多少种选择(即上限).c1保存的是多项式的乘积。初始化只有一项 （1） . 然后c2每次存储下一项与之前项的乘积；最后c1[n]存储的就是生成价值n的方案数; 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;#define N 20#define MAX 310int c1[MAX], c2[MAX], v[N], n1[N], n2[N];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n; for(int i = 0; i &lt; 17; i++) &#123; v[i] = (i + 1) * (i + 1); &#125; while(cin &gt;&gt; n, n) &#123; memset(c1, 0, sizeof(c1)); c1[0] = 1; for(int i = 0; i &lt; 17; i++) &#123; memset(c2, 0, sizeof(c2)); for(int j = n1[i]; j * v[i] &lt;= n; j++) &#123; for(int k = 0; k + j * v[i] &lt;= n; k++) &#123; c2[k + j * v[i]] += c1[k]; &#125; &#125; memcpy(c1, c2, sizeof(c2)); &#125; cout &lt;&lt; c1[n] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>母函数</category>
      </categories>
      <tags>
        <tag>母函数</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[找单词]]></title>
    <url>%2F2018%2F11%2F30%2FHDU-2082%2F</url>
    <content type="text"><![CDATA[题目链接：HDU-2082&lt;/br&gt; 题目描述：Problem Description假设有x1个字母A， x2个字母B,….. x26个字母Z，同时假设字母A的价值为1，字母B的价值为2,….. 字母Z的价值为26。那么，对于给定的字母，可以找到多少价值&lt;=50的单词呢？单词的价值就是组成一个单词的所有字母的价值之和，比如，单词ACM的价值是1+3+14=18，单词HDU的价值是8+4+21=33。(组成的单词与排列顺序无关，比如ACM与CMA认为是同一个单词）。 Input输入首先是一个整数N，代表测试实例的个数。然后包括N行数据，每行包括26个&lt;=20的整数x1,x2,…..x26. &lt;/br&gt; 思路题意很明显了，就是告诉你一个数字，询问有多少种方式组成这个数； 我们这里运用母函数求解； 如果你不了解母函数，以下为推荐的两篇学习母函数的博客母函数学习母函数学习2 母函数在我的理解就是把组合问题的加法法则和幂级数的乘幂对应起来，这样就可以解决一些问题； 到最后，指数的大小就是(价值，质量等)，系数就是方案数； 当然，他可以优化一下，就是记录每个式子当前的最高次幂和上一次的最高次幂；可以节省一定的时间； 在本题中，我们用v数组保存每个字母的价值，然后n1表示最小选择的数量，这里默认为0，n2表示当前字母最多有多少种选择(即上限).c1保存的是多项式的乘积。初始化只有一项 （1） . 然后c2每次存储下一项与之前项的乘积；最后c1[n]存储的就是生成价值n的方案数; 最后我们统计价值1 - 50的方案数即可; 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX 50#define N 26int c1[MAX + 10], c2[MAX + 10], v[N], n1[N], n2[N];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t; memset(n1, 0, sizeof(n1)); for(int i = 0; i &lt; N; i++) v[i] = i + 1; cin &gt;&gt; t; while(t--) &#123; for(int i = 0; i &lt; N; i++) cin &gt;&gt; n2[i]; memset(c1, 0, sizeof(c1)); memset(c2, 0, sizeof(c2)); c1[0] = 1; for(int i = 0; i &lt; N; i++) &#123; for(int j = n1[i]; j &lt;= n2[i] &amp;&amp; j * v[i] &lt;= MAX; j++) &#123; for(int k = 0; k + j * v[i] &lt;= MAX; k++) &#123; c2[k + j * v[i]] += c1[k]; &#125; &#125; for(int j = 0; j &lt;= MAX; j++) &#123; c1[j] = c2[j]; c2[j] = 0; &#125; &#125; int ans = 0; for(int i = 1; i &lt;= 50; i++) if(c1[i]) ans += c1[i]; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>母函数</category>
      </categories>
      <tags>
        <tag>母函数</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选课时间]]></title>
    <url>%2F2018%2F11%2F30%2FHDU-2079%2F</url>
    <content type="text"><![CDATA[题目链接：HDU-2079&lt;/br&gt; 题目描述：Problem Description又到了选课的时间了，xhd看着选课表发呆，为了想让下一学期好过点，他想知道学n个学分共有多少组合。你来帮帮他吧。（xhd认为一样学分的课没区别） Input输入数据的第一行是一个数据T，表示有T组数据。每组数据的第一行是两个整数n(1 &lt;= n &lt;= 40)，k(1 &lt;= k &lt;= 8)。接着有k行，每行有两个整数a(1 &lt;= a &lt;= 8),b(1 &lt;= b &lt;= 10)，表示学分为a的课有b门。 &lt;/br&gt; 思路题意很明显了，就是告诉你一个数字，询问有多少种方式组成这个数； 我们这里运用母函数求解； 如果你不了解母函数，以下为推荐的两篇学习母函数的博客母函数学习母函数学习2 母函数在我的理解就是把组合问题的加法法则和幂级数的乘幂对应起来，这样就可以解决一些问题； 到最后，指数的大小就是(价值，质量等)，系数就是方案数； 当然，他可以优化一下，就是记录每个式子当前的最高次幂和上一次的最高次幂；可以节省一定的时间； 在本题中，我们用v数组保存每个课的价值（也就是学分），然后n1表示最小选择的数量，这里默认为0，n2表示当前课最多有多少种选择(即上限).c1保存的是多项式的乘积。初始化只有一项 （1） . 然后c2每次存储下一项与之前项的乘积；最后c1[n]存储的就是生成学分n的方案数; 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX 50#define N 10int c1[MAX], c2[MAX], v[N], n1[N], n2[N];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); memset(n1, 0, sizeof(n1)); int t; cin &gt;&gt; t; while(t--) &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; v[i] &gt;&gt; n2[i]; &#125; memset(c1, 0, sizeof(c1)); memset(c2, 0, sizeof(c2)); c1[0] = 1; for(int i = 0; i &lt; k; i++) &#123; for(int j = n1[i]; j &lt;= n2[i] &amp;&amp; j * v[i] &lt;= n; j++) &#123; for(int k = 0; k + j * v[i] &lt;= n; k++) &#123; c2[k + j * v[i]] += c1[k]; &#125; &#125; for(int j = 0; j &lt;= n; j++) &#123; c1[j] = c2[j]; c2[j] = 0; &#125; &#125; cout &lt;&lt; c1[n] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>母函数</category>
      </categories>
      <tags>
        <tag>母函数</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ignatius and the Princess III]]></title>
    <url>%2F2018%2F11%2F30%2FHDU-1028%2F</url>
    <content type="text"><![CDATA[题目链接：HDU-1028&lt;/br&gt; 题目描述：“Well, it seems the first problem is too easy. I will let you know how foolish you are later.” feng5166 says. “The second problem is, given an positive integer N, we define an equation like this: N=a1+a2+a3+…+a[m]; a[i]&gt;0,1&lt;=m&lt;=N;My question is how many different equations you can find for a given N.For example, assume N is 4, we can find: 4 = 4; 4 = 3 + 1; 4 = 2 + 2; 4 = 2 + 1 + 1; 4 = 1 + 1 + 1 + 1;so the result is 5 when N is 4. Note that “4 = 3 + 1” and “4 = 1 + 3” is the same in this problem. Now, you do it!” &lt;/br&gt; 思路题意很明显了，就是告诉你一个数字，询问有多少种方式组成这个数； 这是经典的整数划分问题，我们可以用递归、dp、母函数等等方法求解；递归做会T掉，我们这里运用母函数求解； 如果你不了解母函数，以下为推荐的两篇学习母函数的博客母函数学习母函数学习2 母函数在我的理解就是把组合问题的加法法则和幂级数的乘幂对应起来，这样就可以解决一些问题； 到最后，指数的大小就是(价值，质量等)，系数就是方案数； 当然，他可以优化一下，就是记录每个式子当前的最高次幂和上一次的最高次幂；可以节省一定的时间； 代码12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;#define N 210int c1[N], c2[N];int main()&#123; int n; while(cin &gt;&gt; n) &#123; memset(c1, 0, sizeof(c1)); memset(c2, 0, sizeof(c2)); c1[0] = 1; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j * (i + 1) &lt;= n; j++) &#123; for(int k = 0; k + j * (i + 1) &lt;= n; k++) &#123; c2[k + j * (i + 1)] += c1[k]; &#125; &#125; for(int j = 0; j &lt;= n; j++) &#123; c1[j] = c2[j]; c2[j] = 0; &#125; &#125; cout &lt;&lt; c1[n] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>母函数</category>
      </categories>
      <tags>
        <tag>母函数</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[青蛙的约会 【exgcd】]]></title>
    <url>%2F2018%2F11%2F24%2FPOJ-1061%2F</url>
    <content type="text"><![CDATA[题目链接：POJ-1061【kuangbin带你飞】专题十四 数论基础&lt;/br&gt; 题目描述：两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。我们把这两只青蛙分别叫做青蛙A和青蛙B，并且规定纬度线上东经0度处为原点，由东往西为正方向，单位长度1米，这样我们就得到了一条首尾相接的数轴。设青蛙A的出发点坐标是x，青蛙B的出发点坐标是y。青蛙A一次能跳m米，青蛙B一次能跳n米，两只青蛙跳一次所花费的时间相同。纬度线总长L米。现在要你求出它们跳了几次以后才会碰面。 &lt;/br&gt; 思路先理解一下题意，我们看一下样例；初始地图是这样子的，黄色代表第一只青蛙的初始位置，蓝色代表第二只青蛙的初始位置；然后经过4步之后，他们处于同一个点，代表相遇，我们输出4即可；然后我们可以想到，可以设一个未知量K，代表通过K步，两只青蛙可以相遇;那么我们不难得到； (tmp_1 + K m ) % L = (tmp_2 + K n) % L即tmp_1 + K m ≡ tmp_2 + K n ( mod L) // 代表同余然后移项得到K(n - m) ≡ tmp_1 - tmp_2 (mod L)显然，这是一个扩展欧几里得的标准式即K(n - m) + L s = tmp_1 - tmp_2我们只需要求出K为多少即可知道答案；我们知道扩展欧几里得可以求出 ax + b * y = gcd(a, b) 的最小整数解，即一个特解；所以tmp_1 - tmp_2 不是 gcd(n-m, L) 的时候 这时候就输出Impossible其他情况，我们保证倍数和x都为正即可，因为步数不会为负; 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define long long longlong exgcd(long a, long b, long &amp;x, long &amp;y)&#123; if(b == 0) &#123; x = 1; y = 0; return a; &#125; long r = exgcd(b, a%b, x, y); long tmp = x; x = y; y = tmp - a / b * y; return r;&#125;int main()&#123; long tmp_1, tmp_2, m, n, L, x, y; cin &gt;&gt; tmp_1 &gt;&gt; tmp_2 &gt;&gt; m &gt;&gt; n &gt;&gt; L; long r = exgcd(n - m, L, x, y); if((tmp_1 - tmp_2) % (r) != 0) &#123; cout &lt;&lt; "Impossible" &lt;&lt; endl; &#125; else &#123; int k = (tmp_1 - tmp_2) / r; k = (k + L) % L; cout &lt;&lt; k * (x + L) % L &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞 专题十四 数论基础</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>exgcd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bi-shoe and Phi-shoe 【欧拉函数】]]></title>
    <url>%2F2018%2F11%2F22%2F%E6%95%B0%E8%AE%BA-LightOJ1370%2F</url>
    <content type="text"><![CDATA[题目链接：LightOJ-1370【kuangbin带你飞】专题十四 数论基础&lt;/br&gt; 题目描述：Bamboo Pole-vault is a massively popular sport in Xzhiland. And Master Phi-shoe is a very popular coach for his success. He needs some bamboos for his students, so he asked his assistant Bi-Shoe to go to the market and buy them. Plenty of Bamboos of all possible integer lengths (yes!) are available in the market. According to Xzhila tradition, Score of a bamboo = Φ (bamboo’s length) (Xzhilans are really fond of number theory). For your information, Φ (n) = numbers less than n which are relatively prime (having no common divisor other than 1) to n. So, score of a bamboo of length 9 is 6 as 1, 2, 4, 5, 7, 8 are relatively prime to 9. The assistant Bi-shoe has to buy one bamboo for each student. As a twist, each pole-vault student of Phi-shoe has a lucky number. Bi-shoe wants to buy bamboos such that each of them gets a bamboo with a score greater than or equal to his/her lucky number. Bi-shoe wants to minimize the total amount of money spent for buying the bamboos. One unit of bamboo costs 1 Xukha. Help him. &lt;/br&gt; 思路题意就是说给定一列数，然后求出比这个数大的phi的最小值是多少；例如:给定的数字为 2, 我们知道phi2 = 1, phi[3] = 2,phi[4] = 2….;我们可以发现，phi[3]和phi[4] 都是等于2，满足phi[] &gt;= 2 ，而且值也是 &gt; 2，所以这时候3,4都是满足题意的，但是k最小，所以我们只能取3；由于欧拉函数的性质，phi[p] = p - 1, 当p是素数的时候； 当给出的数字不是素数时 ，这时候的phi一定会 &lt; 给出的值的； 所以，我们只需要找到比这个数大的最小的质数，然后累加输出答案即可；我们用欧拉筛或者按个nlglgn的筛，筛出前1e6数据，直接搜就可以了。 PS：累加的过程会爆int，开long long 可以过; 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX_N 1000010bool check[MAX_N];int prime[MAX_N];void fun()&#123; memset(check, 0, sizeof(check)); check[0] = check[1] = 1; int ans = 0; for(int i = 2; i &lt; MAX_N; i++) &#123; if(!check[i]) &#123; prime[ans++] = i; &#125; for(int j = 0; j &lt; ans &amp;&amp; i * prime[j] &lt; MAX_N; j++) &#123; check[i * prime[j]] = 1; if(prime[j] % i == 0) break; &#125; &#125;&#125;int main()&#123; int t; fun(); cin &gt;&gt; t; for(int k = 1; k &lt;= t; k++) &#123; long long n, ans = 0; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; int tmp; cin &gt;&gt; tmp; for(int j = tmp+1; ; j++) &#123; if(!check[j]) &#123; ans += j; break; &#125; &#125; &#125; cout &lt;&lt; "Case " &lt;&lt; k &lt;&lt; ": " &lt;&lt; ans &lt;&lt; " Xukha" &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞 专题十四 数论基础</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>phi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CD操作 【LCA树上倍增】]]></title>
    <url>%2F2018%2F11%2F19%2FHUD-4547%2F</url>
    <content type="text"><![CDATA[题目链接：HUD-4547&lt;/br&gt; 题目描述：在Windows下我们可以通过cmd运行DOS的部分功能，其中CD是一条很有意思的命令，通过CD操作，我们可以改变当前目录。 这里我们简化一下问题，假设只有一个根目录，CD操作也只有两种方式： 1. CD 当前目录名...\目标目录名 (中间可以包含若干目录，保证目标目录通过绝对路径可达) 2. CD .. (返回当前目录的上级目录) 现在给出当前目录和一个目标目录，请问最少需要几次CD操作才能将当前目录变成目标目录？ &lt;/br&gt; 思路分两种情况讨论，当要查询的a，b直接是祖先关系。若b是a的祖先，则直接输出两个节点的深度差即可；其他情况，找到最近公共祖先，然后到达公共祖先需要深度差步，然后再往下1步即可到达； 这里给出的字符串，我用的是string处理，没出现过的string赋新值，出现过则直接用； PS：测试数据可能有锅？ 他说了边数应该是N-1，1e5的数据范围，然后双向边，我开了2e5竟然RE，迷；开了4e5才过； LCA代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX_N 100010#define MAX_M 200010int head[MAX_N], cnt = 0, fa[MAX_N][30], dfn[MAX_N], pre[MAX_N];int n, m;struct Node&#123; int to, next;&#125;edge[MAX_M * 2];void init()&#123; for(int i = 1; i &lt;= n; i++) pre[i] = i; memset(head, -1, sizeof(head)); memset(dfn, 0, sizeof(dfn));&#125;void add(int x, int y)&#123; edge[cnt].to = y; edge[cnt].next = head[x]; head[x] = cnt++;&#125;int Find(int x)&#123; return x == pre[x] ? pre[x] : pre[x] = Find(pre[x]);&#125;void Union(int x, int y)&#123; x = Find(x); y = Find(y); if(x != y) pre[x] = y;&#125;void dfs(int u)&#123; for(int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if(!dfn[v]) &#123; dfn[v] = dfn[u] + 1; fa[v][0] = u; dfs(v); &#125; &#125;&#125;int lca(int x, int y)&#123; if(dfn[x] &lt; dfn[y]) &#123; swap(x, y); &#125; for(int i = 20; i &gt;= 0; i--) &#123; if(dfn[fa[x][i]] &gt;= dfn[y]) x = fa[x][i]; &#125; if(x == y) return x; for(int i = 20; i &gt;= 0; i--) &#123; if(fa[x][i] != fa[y][i]) &#123; x = fa[x][i]; y = fa[y][i]; &#125; &#125; return fa[x][0];&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t; cin &gt;&gt; t; while(t--) &#123; int ans = 1; string x, y; map&lt;string, int&gt; F; cin &gt;&gt; n &gt;&gt; m; init(); for(int i = 0; i &lt; n - 1; i++) &#123; cin &gt;&gt; x &gt;&gt; y; if(!F[x]) &#123; F[x] = ans++; &#125; if(!F[y]) &#123; F[y] = ans++; &#125; Union(F[x], F[y]); add(F[x], F[y]); add(F[y], F[x]); &#125; int r = Find(pre[F[x]]); fa[r][0] = 0, dfn[r] = 1; dfs(r); for(int i = 1; i &lt;= 20; i++) &#123; for(int j = 1; j &lt;= n; j++) fa[j][i] = fa[fa[j][i-1]][i-1]; &#125; while(m--) &#123; string x, y; cin &gt;&gt; x &gt;&gt; y; if(lca(F[x], F[y]) != F[y]) cout &lt;&lt; dfn[F[x]] - dfn[lca(F[x], F[y])] + 1 &lt;&lt; endl; else &#123; cout &lt;&lt; dfn[F[x]] - dfn[F[y]] &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>练习</category>
      </categories>
      <tags>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nearest Common Ancestors 【LCA树上倍增】]]></title>
    <url>%2F2018%2F11%2F19%2FPOJ-1330%2F</url>
    <content type="text"><![CDATA[题目链接：POJ-1330&lt;/br&gt; 题目描述：In the figure, each node is labeled with an integer from {1, 2,…,16}. Node 8 is the root of the tree. Node x is an ancestor of node y if node x is in the path between the root and node y. For example, node 4 is an ancestor of node 16. Node 10 is also an ancestor of node 16. As a matter of fact, nodes 8, 4, 10, and 16 are the ancestors of node 16. Remember that a node is an ancestor of itself. Nodes 8, 4, 6, and 7 are the ancestors of node 7. A node x is called a common ancestor of two different nodes y and z if node x is an ancestor of node y and an ancestor of node z. Thus, nodes 8 and 4 are the common ancestors of nodes 16 and 7. A node x is called the nearest common ancestor of nodes y and z if x is a common ancestor of y and z and nearest to y and z among their common ancestors. Hence, the nearest common ancestor of nodes 16 and 7 is node 4. Node 4 is nearer to nodes 16 and 7 than node 8 is. For other examples, the nearest common ancestor of nodes 2 and 3 is node 10, the nearest common ancestor of nodes 6 and 13 is node 8, and the nearest common ancestor of nodes 4 and 12 is node 4. In the last example, if y is an ancestor of z, then the nearest common ancestor of y and z is y. Write a program that finds the nearest common ancestor of two distinct nodes in a tree. &lt;/br&gt; 思路题目是求最近公共祖先的裸题，然后给定a,b默认a是b的父亲节点；所以我们需要一个并查集来维护一下根节点。然后剩下的就是裸的LCA问题了； LCA代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;#define MAX_N 500050#define MAX_M 500050int head[MAX_N], cnt = 0, fa[MAX_N][30], dfn[MAX_N], pre[MAX_N];int n, m, t;struct Node&#123; int to, val, next;&#125;edge[MAX_M * 2];void init()&#123; cnt = 0; memset(head, -1, sizeof(head)); memset(dfn, 0, sizeof(dfn)); for(int i = 1; i &lt;= n; i++) pre[i] = i;&#125;int Find(int x)&#123; return x == pre[x] ? pre[x] : pre[x] = Find(pre[x]);&#125;void Union(int x, int y)&#123; x = Find(x); y = Find(y); if(x != y) pre[y] = x;&#125;void add(int x, int y)&#123; edge[cnt].to = y; edge[cnt].next = head[x]; head[x] = cnt++;&#125;void dfs(int u)&#123; for(int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if(!dfn[v]) &#123; dfn[v] = dfn[u] + 1; fa[v][0] = u; dfs(v); &#125; &#125;&#125;int lca(int x, int y)&#123; if(dfn[x] &lt; dfn[y]) &#123; swap(x, y); &#125; for(int i = 20; i &gt;= 0; i--) &#123; if(dfn[fa[x][i]] &gt;= dfn[y]) &#123; x = fa[x][i]; &#125; &#125; if(x == y) return x; for(int i = 20; i &gt;= 0; i--) &#123; if(fa[x][i] != fa[y][i]) &#123; x = fa[x][i]; y = fa[y][i]; &#125; &#125; return fa[x][0];&#125;int main()&#123; scanf("%d",&amp;t); while(t--) &#123; scanf("%d", &amp;n); init(); for(int i = 0; i &lt; n - 1; i++) &#123; int x, y; scanf("%d %d", &amp;x, &amp;y); Union(x, y); add(x, y); add(y, x); &#125; int root = Find(pre[1]); dfn[root] = 1, fa[root][0] = 0; dfs(root); for(int i = 1; i &lt;= 20; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; fa[j][i] = fa[fa[j][i-1]][i-1]; &#125; &#125; int x, y; scanf("%d %d", &amp;x, &amp;y); printf("%d\n", lca(x, y)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>练习</category>
      </categories>
      <tags>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How far away ？ 【LCA树上倍增】]]></title>
    <url>%2F2018%2F11%2F19%2FHDU-2586%2F</url>
    <content type="text"><![CDATA[题目链接：HDU-2586&lt;/br&gt; 题目描述：There are n houses in the village and some bidirectional roads connecting them. Every day peole always like to ask like this “How far is it if I want to go from house A to house B”? Usually it hard to answer. But luckily int this village the answer is always unique, since the roads are built in the way that there is a unique simple path(“simple” means you can’t visit a place twice) between every two houses. Yout task is to answer all these curious people.就是给你一颗树，然后问任意两点的距离是多少； &lt;/br&gt; 思路一开始看到数据范围只有40000，想着爆搜也不会T掉，然后就写了一发爆搜，然后就过了； 爆搜代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX_N 40010int head[MAX_N], cnt = 0, vis[MAX_N], sum = 0;int n, m;struct Node&#123; int to, val, next;&#125;edge[MAX_N * 2];void init()&#123; memset(head, -1, sizeof(head)); cnt = sum = 0;&#125;void add(int x, int y, int val)&#123; edge[cnt].to = y; edge[cnt].val = val; edge[cnt].next = head[x]; head[x] = cnt++;&#125;int dfs(int x, int y)&#123; for(int i = head[x]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if(v == y) &#123; return edge[i].val; &#125; else &#123; if(!vis[v]) &#123; vis[v] = 1; int k = dfs(v, y); if(k) return edge[i].val + k; &#125; &#125; &#125; return 0;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t; cin &gt;&gt; t; while(t--) &#123; init(); cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n - 1; i++) &#123; int x, y, val; cin &gt;&gt; x &gt;&gt; y &gt;&gt; val; add(x, y, val); add(y, x, val); &#125; while(m--) &#123; memset(vis, 0, sizeof(vis)); int x, y; cin &gt;&gt; x &gt;&gt; y; vis[x] = 1; cout &lt;&lt; dfs(x, y) &lt;&lt; endl; &#125; &#125; return 0;&#125; 爆搜的意思就是从x点出发，能不能到达y点，可以到达则返回到达y点的距离，不能到达那就返回0，由于是无向图，所以加了一个vis数组记录节点是否已经访问；可能数据比较弱吧，然后就是用LCA的解法； LCA是用来求解最近公共祖先的，在这道体中，我们可以在dfs预处理的时候把每个节点到根节点的距离也预处理出来；就是 Dist[v] = Dist[u] + edge[i].val;这样子；然后画张图看一下;若我们要求4到6的距离，则只需要求出4,6的最近公共祖先，也就是3；然后Dist[4] + Dist[6] - 2 * Dist[3] 就是4到6的距离了；很好理解的; LCA代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX_N 500050#define MAX_M 500050int head[MAX_N], cnt = 0, fa[MAX_N][30], dfn[MAX_N], Dist[MAX_N];int n, m, t;struct Node&#123; int to, val, next;&#125;edge[MAX_M * 2];void init()&#123; cnt = 0; memset(head, -1, sizeof(head)); memset(dfn, 0, sizeof(dfn));&#125;void add(int x, int y, int val)&#123; edge[cnt].to = y; edge[cnt].val = val; edge[cnt].next = head[x]; head[x] = cnt++;&#125;void dfs(int u)&#123; for(int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if(!dfn[v]) &#123; Dist[v] = Dist[u] + edge[i].val; dfn[v] = dfn[u] + 1; fa[v][0] = u; dfs(v); &#125; &#125;&#125;int lca(int x, int y)&#123; if(dfn[x] &lt; dfn[y]) &#123; swap(x, y); &#125; for(int i = 20; i &gt;= 0; i--) &#123; if(dfn[fa[x][i]] &gt;= dfn[y]) &#123; x = fa[x][i]; &#125; &#125; if(x == y) return x; for(int i = 20; i &gt;= 0; i--) &#123; if(fa[x][i] != fa[y][i]) &#123; x = fa[x][i]; y = fa[y][i]; &#125; &#125; return fa[x][0];&#125;int main()&#123; scanf("%d",&amp;t); while(t--) &#123; scanf("%d %d", &amp;n, &amp;m); init(); for(int i = 0; i &lt; n - 1; i++) &#123; int x, y, val; scanf("%d %d %d", &amp;x, &amp;y, &amp;val); add(x, y, val); add(y, x, val); &#125; dfn[1] = 1, fa[1][0] = 0, Dist[1] = 0; dfs(1); for(int i = 1; i &lt;= 20; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; fa[j][i] = fa[fa[j][i-1]][i-1]; &#125; &#125; while(m--) &#123; int x, y; scanf("%d %d", &amp;x, &amp;y); printf("%d\n", Dist[x] + Dist[y] - 2 * Dist[lca(x, y)]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>练习</category>
      </categories>
      <tags>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Popular Cows 【tarjan求缩点】]]></title>
    <url>%2F2018%2F11%2F17%2FPOJ-2186%2F</url>
    <content type="text"><![CDATA[题目链接：POJ-1286&lt;/br&gt; 题目描述：题意就是说 给定n头牛，m种关系，然后给定关系a, b代表着a认为b最帅，然后这种关系有着传递性，就是 a认为 b最帅，b认为c最帅，则a也认为c最帅。 然后要求出被其他所有牛都认为是最帅的奶牛有多少头； &lt;/br&gt; 思路用例： 可以明确看出，只有第3只牛满足题意；所以输出1； 那么我们如何解这道题呢？我们可以用tarjan算法将图中的强联通分量缩为一个点，即缩点；然后找出出度为0的缩点，该缩点的大小就是我们所求的答案；如何理解呢？ 随手画的一个图，我们可以看出，3， 4， 5都为最帅的牛；所以答案为3; 我们缩点之后就变为了 这样的样子，可以看出只有节点3的出度为0，所以直接输出节点3的大小即可; 然后我们统计出度为0的缩点个数，为1的话，我们直接输出当前缩点的环大小；否则输出0即可； AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define MAX_N 10010stack&lt;int&gt; S;vector&lt;int&gt; g[MAX_N], scc[MAX_N];int in_stack[MAX_N], dfn[MAX_N], low[MAX_N], idx = 1, ans_scc = 0, belong[MAX_N], out[MAX_N];void tarjan(int u)&#123; low[u] = dfn[u] = idx++; S.push(u); in_stack[u] = 1; for(int i = 0; i&lt;g[u].size(); i++) &#123; int v = g[u][i]; if(!dfn[v]) &#123; tarjan(v); low[u] = min(low[u], low[v]); &#125; else if(in_stack[v]) &#123; low[u] = min(low[u], dfn[v]); &#125; &#125; if(dfn[u] == low[u]) &#123; ans_scc++; do &#123; int k = S.top(); belong[k] = ans_scc; in_stack[k] = false; S.pop(); scc[ans_scc].push_back(k); if(u == k) break; &#125; while(!S.empty()); &#125;&#125;int main()&#123; int n, m; scanf("%d %d", &amp;n, &amp;m); for(int i = 0; i&lt;m; i++) &#123; int x, y; scanf("%d %d", &amp;x, &amp;y); g[x].push_back(y); &#125; memset(dfn, 0, sizeof(dfn)); for(int i = 1; i&lt;=n; i++) &#123; if(!dfn[i]) &#123; tarjan(i); &#125; &#125; for(int i = 1; i&lt;=n; i++) &#123; int sz = g[i].size(); for(int j = 0; j &lt; sz; j++) &#123; int v = g[i][j]; if(belong[v] != belong[i]) &#123; out[belong[i]]++; &#125; &#125; &#125; int tmp = 0, ans; for(int i = 1; i&lt;=ans_scc; i++) &#123; if(out[i] == 0) &#123; tmp++; ans = scc[i].size(); &#125; &#125; if(tmp != 1) &#123; cout &lt;&lt; 0; &#125; else cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>练习</category>
      </categories>
      <tags>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迷宫城堡 【tarjan求强连通分量的个数】]]></title>
    <url>%2F2018%2F11%2F15%2FHDU-1269%2F</url>
    <content type="text"><![CDATA[题目链接：HDOJ-1269&lt;/br&gt; 题目描述：为了训练小希的方向感，Gardon建立了一座大城堡，里面有N个房间(N&lt;=10000)和M条通道(M&lt;=100000)，每个通道都是单向的，就是说若称某通道连通了A房间和B房间，只说明可以通过这个通道由A房间到达B房间，但并不说明通过它可以由B房间到达A房间。Gardon需要请你写个程序确认一下是否任意两个房间都是相互连通的，即：对于任意的i和j，至少存在一条路径可以从房间i到房间j，也存在一条路径可以从房间j到房间i。 &lt;/br&gt; 思路这道题的题意很明显，是一道tarjan的裸题；首先题目给出的是有向图，然后要求判断该图是否联通，即任意两点可以相互到达；我们可以用tarjan算法对这张图进行改造为一张DAG，然后判断存在几个强连通分量即可；若强连通分量的个数 == 1 则输出Yes其他情况下输出 No 即可 AC AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX_N 10010#define MAX_M 100010int head[MAX_N], dfn[MAX_N], low[MAX_N], cnt = 0, idx = 1, in_stack[MAX_N], scc = 0;stack&lt;int&gt; S;struct Node&#123; int to, next;&#125;edge[MAX_M];void init()&#123; scc = cnt = 0; idx = 1; memset(head, -1, sizeof(head)); memset(dfn, 0, sizeof(dfn)); memset(in_stack, 0, sizeof(in_stack));&#125;void add(int x, int y)&#123; edge[cnt].to = y; edge[cnt].next = head[x]; head[x] = cnt++;&#125;void tarjan(int u)&#123; low[u] = dfn[u] = idx++; S.push(u); in_stack[u] = true; for(int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if(!dfn[v]) &#123; dfn[v] = dfn[u] + 1; tarjan(v); low[u] = min(low[u], low[v]); &#125; else if(in_stack[v]) &#123; low[u] = min(low[u], dfn[v]); &#125; &#125; if(low[u] == dfn[u]) &#123; scc++; do &#123; int k = S.top(); S.pop(); in_stack[k] = false; if(k == u) break; &#125; while(!S.empty()); &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n, m; while(cin &gt;&gt; n &gt;&gt; m, n + m) &#123; init(); for(int i = 0; i &lt; m; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; add(x, y); &#125; for(int i = 1; i &lt;= n; i++) &#123; if(!dfn[i]) &#123; tarjan(i); &#125; &#125; if(scc == 1) cout &lt;&lt; "Yes" &lt;&lt; endl; else cout &lt;&lt; "No" &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>练习</category>
      </categories>
      <tags>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计蒜客 受欢迎的蒜头君 【tarjan求缩点】]]></title>
    <url>%2F2018%2F11%2F14%2F%E8%AE%A1%E8%92%9C%E5%AE%A2-%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E8%92%9C%E5%A4%B4%E5%90%9B%2F</url>
    <content type="text"><![CDATA[题目链接：计蒜客&lt;/br&gt; 题目描述： &lt;/br&gt; 思路因为关系具有传递性，我们可以把强连通分量看做是一个点。然后利用tarjan算法，将图上所有的强连通分量缩成一个点，最后我们只处理这样新处理出来的图；因为这是一张DAG（有向无环图），要使所有的顶点有到某一点的通路，即可以求出所有出度为0的点。 由于是DAG，所以不可能存在出度为0的点的个数是0；出度为0的顶点的个数只可能 &gt;= 0， 当这样的点存在1个时，我们输出这个顶点所在的环的大小即可，当出度为0的顶点的个数 &gt;= 2 时， 此时代表一开始的图就不是强连通图，此时输出0即可； AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX_N 10010stack&lt;int&gt; S;vector&lt;int&gt; g[MAX_N], scc[MAX_N];int in_stack[MAX_N], dfn[MAX_N], low[MAX_N], idx = 1, ans_scc = 0, belong[MAX_N], out[MAX_N];void tarjan(int u)&#123; low[u] = dfn[u] = idx++; S.push(u); in_stack[u] = 1; for(int i = 0; i&lt;g[u].size(); i++) &#123; int v = g[u][i]; if(!dfn[v]) &#123; tarjan(v); low[u] = min(low[u], low[v]); &#125; else if(in_stack[v]) &#123; low[u] = min(low[u], dfn[v]); &#125; &#125; if(dfn[u] == low[u]) &#123; ans_scc++; do &#123; int k = S.top(); belong[k] = ans_scc; in_stack[k] = false; S.pop(); scc[ans_scc].push_back(k); if(u == k) break; &#125; while(!S.empty()); &#125;&#125;int main()&#123; int n, m; scanf("%d %d", &amp;n, &amp;m); for(int i = 0; i&lt;m; i++) &#123; int x, y; scanf("%d %d", &amp;x, &amp;y); g[x].push_back(y); &#125; memset(dfn, 0, sizeof(dfn)); for(int i = 1; i&lt;=n; i++) &#123; if(!dfn[i]) &#123; tarjan(i); &#125; &#125; for(int i = 1; i&lt;=n; i++) &#123; int sz = g[i].size(); for(int j = 0; j &lt; sz; j++) &#123; int v = g[i][j]; if(belong[v] != belong[i]) &#123; out[belong[i]]++; &#125; &#125; &#125; int tmp = 0, ans; for(int i = 1; i&lt;=ans_scc; i++) &#123; if(out[i] == 0) &#123; tmp++; ans = scc[i].size(); &#125; &#125; if(tmp != 1) &#123; cout &lt;&lt; 0; &#125; else cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>练习</category>
      </categories>
      <tags>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2661 信息传递 【tarjan求最小环】]]></title>
    <url>%2F2018%2F11%2F14%2F%E6%B4%9B%E8%B0%B7-P2661%2F</url>
    <content type="text"><![CDATA[题目链接：洛谷P2661&lt;/br&gt; 题目描述：有 n 个同学（编号为1到n） 正在玩一个信息传递的游戏。在游戏里每人都有一个固定的信息传递对象，其中，编号为 i 的同学的信息传递对象是编号为 Ti的同学。 游戏开始时，每人都只知道自己的生日。之后每一轮中，所有人会同时将自己当前所知的生日信息告诉各自的信息传递对象（注意：可能有人可以从若干人那里获取信息， 但是每人只会把信息告诉一个人，即自己的信息传递对象）。当有人从别人口中得知自 己的生日时，游戏结束。请问该游戏一共可以进行几轮？ &lt;/br&gt; 思路把每个同学看成一个点，信息的传递就是在他们之间连有向边，游戏轮数就是求最小环。 这里我写的是用Tarjan求出所有的强连通分量，然后比较找出 &gt;= 2 的最小环。 建议求最小环的时候直接在tarjan里面做， 如果求出所有的强连通分量然后求最小环的话，需要 O(scc * n)的时间，当边数较大时，可能会T掉； AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX_N 2000010#define INF 0x3f3f3f3fint head[MAX_N], cnt = 0, idx = 1, dfn[MAX_N], low[MAX_N], in_stack[MAX_N], belong[MAX_N], scc = 0, ans = INF;stack&lt;int&gt; q;struct Node&#123; int to, next;&#125;edge[MAX_N];void init()&#123; memset(head, -1, sizeof(head)); cnt = 0; idx = 1;&#125;void add(int x, int y)&#123; edge[cnt].to = y; edge[cnt].next = head[x]; head[x] = cnt++;&#125;void tarjan(int u)&#123; low[u] = dfn[u] = idx++; q.push(u); in_stack[u] = 1; for(int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if(!dfn[v]) &#123; tarjan(v); low[u] = min(low[u], low[v]); &#125; else if(in_stack[v]) &#123; low[u] = min(low[u], dfn[v]); &#125; &#125; int tmp_ans = 0; if(low[u] == dfn[u]) &#123; scc++; do &#123; int k = q.top(); in_stack[k] = false; belong[k] = scc; q.pop(); tmp_ans++; if(k == u) break; &#125; while(!q.empty()); &#125; if(tmp_ans &gt;= 2) ans = min(ans, tmp_ans);&#125;int main()&#123; init(); int n; scanf("%d", &amp;n); for(int i = 1; i&lt;=n; i++) &#123; int x; scanf("%d", &amp;x); add(i, x); &#125; memset(dfn, 0, sizeof(dfn)); for(int i = 1; i&lt;=n; i++) &#123; if(!dfn[i]) &#123; tarjan(i); &#125; &#125; printf("%d", ans); return 0;&#125;]]></content>
      <categories>
        <category>练习</category>
      </categories>
      <tags>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018ACM青岛 C题]]></title>
    <url>%2F2018%2F11%2F13%2F2018%E9%9D%92%E5%B2%9BC%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目链接：ZOJ-4060&lt;/br&gt; 题目描述： &lt;/br&gt; 思路此题，我们统计异或后 0 和 1 的数量； 我们要做的就是处理异或后的结果， 也就是对异或后的结果取两个区间进行异或操作，使得最后的序列全为0，问这样的方法有多少种； 化简了问题后，我们分类讨论。我们用ans_0 记录异或后结果为0的数量， ans_1记录异或后结果为1的数量; 当 ans_0 == len代表着异或后结果全为0； 我们写一个列子看看红线代表第一次所取的区间 ， 黑线代表第二次所取的区间；此时为区间长度为 1 时 此时的种类数 为 len此时为区间长度为 2 时 此时的种类数 为 len - 1 不难得到规律， 异或后结果全为 0 时.总得方案数量 = (1 + len) * len / 2; 当 ans_1 = len 时此时代表着异或后的结果全为1； 我们来看一个例子；红线代表第一次所取的区间 ， 黑线代表第二次所取的区间； 显然 我们得到的方案数是 len - 1， 考虑到 上下区间可以交换，所以。该种情况下， 我们得到的方法数 = （len - 1） * 2 当0存在于两个1中间 此时是无解的 此种情况下就是无解的； 当两边是0， 中间夹着全是1的情况下 我们分两部分考虑 1.忽略两侧的0， 此时与情况2完全一致， 结果为(ans_1 - 1) * 2 2.考虑两侧的0， 此时为 (cnt_l + cnt_r) * 2 所以总得结果就是两种情况求和 [ans_1 - 1] 乘以 2 + [cnt_l + cnt_r] 乘以 2 当两边是1， 中间夹着全是0的情况下 这种情况无论咋样结果都是6，直接输出即可； 剩下的一般情况 正常的中间夹着一个0 或者连续的0 结果都是6，直接输出即可； 讨论完毕 我们只需要按着讨论结果，进行相应的输出即可ac； AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;using namespace std;#define long long long#define MAX_N 1000010char s_1[MAX_N], s_2[MAX_N];int main()&#123; int t; scanf("%d", &amp;t); while(t--) &#123; int len, ans_0 = 0, ans_1 = 0;// ans_0 统计异或为0 ans_1 统计异或为1 scanf("%d %s %s", &amp;len, s_1, s_2); vector&lt;int&gt; a; for(int i = 0; i&lt;len; i++) &#123; if(s_1[i] == s_2[i]) &#123; a.push_back(0); ans_0++; &#125; else &#123; a.push_back(1); ans_1++; &#125; &#125; if(ans_0 == len) // 异或结果全为0 &#123; printf("%d\n", (len + 1) * len / 2 ); &#125; else if(ans_1 == len)// 异或结果全为1 &#123; printf("%d\n", (len - 1) * 2); &#125; else &#123; int flag = 0, cnt_m = 0, cnt_l = 0, cnt_r = 0; for(int i = 0; i&lt;a.size(); i++) &#123; if(flag == 0) &#123; if(a[i] == 1) flag = 1; &#125; else &#123; if(a[i] == 1) &#123; if(cnt_m != 0) break; &#125; else &#123; cnt_m++; &#125; &#125; &#125; for(int i = 0; i&lt;a.size(); i++) &#123; if(a[i] == 1) break; else cnt_l++; &#125; for(int i = a.size() - 1; i &gt;= 0; i--) &#123; if(a[i] == 1) break; else cnt_r++; &#125; if(cnt_l + cnt_r == ans_0) &#123; cnt_m = 0; &#125; if(cnt_l + cnt_r + cnt_m != ans_0) &#123; printf("0\n"); &#125; else if(cnt_l + cnt_r == ans_0) &#123; printf("%d\n", (ans_1 - 1) * 2 + (cnt_l + cnt_r) * 2); &#125; else if(cnt_m == ans_0) &#123; printf("6\n"); &#125; else &#123; printf("6\n"); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>比赛总结</category>
      </categories>
      <tags>
        <tag>水题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018ACM青岛 J题]]></title>
    <url>%2F2018%2F11%2F12%2F2018%E9%9D%92%E5%B2%9BJ%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目链接：ZOJ-4067&lt;/br&gt; 题目描述： &lt;/br&gt; 思路此题，我们统计价格为0的图书数量， 记为ans_0; 然后我们分类讨论 当 n == k代表着所有的书都可以买下来， 输出 Richman 当 ans_0 &gt; k 时此时是不可能的， 我们输出 Impossible; 其他情况我们除去0， 计算出剩下的还需要取的图书的数量；然后，当取够时，我们在之后找到一个图书价格的最小值；然后 输出 sum + min - 1 ;这个就是我们要求的答案； AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;#define long long long#define INF 0x3f3f3f3fint main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t; cin &gt;&gt; t; while(t--) &#123; int n, k, ans_0 = 0; // ans_0 统计价格为0的图书数量 long sum = 0; cin &gt;&gt; n &gt;&gt; k; vector&lt;long&gt; a; for(int i = 0; i &lt; n; i++) &#123; long tmp; cin &gt;&gt; tmp; if(tmp == 0) ans_0++; else a.push_back(tmp); &#125; if(n == k) cout &lt;&lt; "Richman" &lt;&lt; endl; else if(ans_0 &gt; k) cout &lt;&lt; "Impossible" &lt;&lt; endl; else &#123; k -= ans_0; long tmp_min = INF; for(int i = 0; i&lt;a.size(); i++) &#123; if(k) &#123; sum += a[i]; k--; &#125; else &#123; tmp_min = min(tmp_min, a[i]); &#125; &#125; cout &lt;&lt; sum + tmp_min - 1 &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>比赛总结</category>
      </categories>
      <tags>
        <tag>水题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018ACM青岛 M题]]></title>
    <url>%2F2018%2F11%2F12%2F2018%E9%9D%92%E5%B2%9BM%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目链接：ZOJ-4070&lt;/br&gt; 题目描述： &lt;/br&gt; 思路这显然是一道签到题， 我们可以深搜+减枝就可以过了这道题； 我们容易发现， 最终的结果一定会跳回 0 或者 1 ，然后我们判断一下奇偶就可以进行大量的节省时间，不会造成爆栈； AC代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;int val[10] = &#123;1, 0, 0, 0, 1, 0, 1, 0, 2, 1&#125;;int fun(int n, int k)&#123; if(k == 0) return n; if(n == 0)//差不多是个剪枝吧 &#123; if(k &amp; 1) &#123; return 1; &#125; else &#123; return 0; &#125; &#125; int sum = 0; while(n) &#123; sum += val[n % 10]; n /= 10; &#125; return fun(sum, k-1);&#125;int main()&#123; int t; scanf("%d", &amp;t); while(t--) &#123; int n, k; scanf("%d %d", &amp;n, &amp;k); printf("%d\n", fun(n, k)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>比赛总结</category>
      </categories>
      <tags>
        <tag>水题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[节点的最近公共祖先 【倍增算法】]]></title>
    <url>%2F2018%2F11%2F12%2F%E8%AE%A1%E8%92%9C%E5%AE%A2-%E8%8A%82%E7%82%B9%E6%9C%80%E8%BF%91%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%2F</url>
    <content type="text"><![CDATA[题目链接：计蒜客&lt;/br&gt; 题目描述： &lt;/br&gt; 思路这是一个裸的LCA问题，即求书上两个节点的最近公共祖先。我们可以用树上倍增来做； 当然，在做之前我们假设不知道该算法。那么我们如何来做这种类型的题目呢？显然，我们可以用暴力来做，找到两点的最近公共祖先，我们可以用前向星存双向边，然后依次存储每个点到的根的路径。然后找到最先同时出现在两条路径的公共点即可；显然，这样是可做的。但是这样做，考虑到:1.当书的深度非常大2.当最坏情况树退化为一条链式3.当询问次数非常多的时候。以上，无论那种情况，起步都是O（N^2）的复杂度,显然，这样的做法并不够优秀，所以我们引入倍增的做法，它可以NlogN的时间复杂度完成预处理，每次询问LogN的时间给出回答； 倍增算法：所谓倍增，就是按2的倍数来增大，也就是跳 1,2,4,8,16,32 …… 不过在这我们不是按从小到大跳，而是从大向小跳，即按……32,16,8,4,2,1来跳，如果大的跳不过去，再把它调小。这是因为从小开始跳，可能会出现“悔棋”的现象。拿 5为例，从小向大跳，5≠1+2+4,所以我们还要回溯一步，然后才能得出5=1+4；而从大向小跳，直接可以得出5=4+1。这也可以拿二进制为例，5(101)，从高位向低位填很简单，如果填了这位之后比原数大了，那我就不填，这个过程是很好操作的。 lca的倍增做法就是 用一个fa[i][j]数组 来存储 i 节点的 2^j 倍父亲是哪个节点； 这样做每次都是2倍区间查询，所以可以在logN的时间给出答案； 我们先跑一遍dfs， 初始化 深度 d数组 ， 初始化 fa[i][0] 。 跑一遍dfs后，d数组存储的就是每个节点的深度（默认根节点深度为1）. fa数组存储的就是 fa[i][0] 就是 每个节点存储的都是他父亲节点的编号； 跑完dfs，我们需要对全局fa进行赋值； 这里用到的转移方程是fa[i][j] = fa[fa[i][j-1]][j-1] 。比如(画的比较丑)2节点的 fa[2][0] 为 1 。 就是 2节点 的 (2^0 = 1)的父亲为 14节点的fa[4][0]为 2。 就是 4号节点的父亲为 2 要求 fa4 我们可以表示为 fa[fa[4][0]][0]， 就是4号父亲的父亲， 这样递推上去，就可以的出每个fa； 完成这步之后，我们剩下就是求Lca了； 先把x节点和y节点挪到同一层， 挪到同一层后， 若 x == y 代表一开始 x 就是y的祖先或者y是x的祖先； 若 x != y， 则 我们找到最深的满足 fa[x][i] != fa[y][i] ；然后返回x的父亲节点即可。至此，我们的算法就结束了； lca倍增学习：很明白的lca教程 易错点1.建树用前向星建， 注意边数为n-1条，双向边，则应该开辟MAX_N * 2空间2.这道题指明a是b的父亲，得用并查集维护一下根节点，不然会wa的 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX_N 10010int head[MAX_N], cnt = 0, d[MAX_N], fa[MAX_N][30];struct Node&#123; int to, next;&#125;edge[MAX_N * 2];void add(int x, int y)&#123; edge[cnt].to = y; edge[cnt].next = head[x]; head[x] = cnt++;&#125;void dfs(int k)&#123; for(int i = head[k]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if(d[v] == 0) &#123; fa[v][0] = k; d[v] = d[k] + 1; dfs(v); &#125; &#125;&#125;int lca(int x, int y)&#123; if(d[x] &lt; d[y]) &#123; swap(x, y); &#125; for(int i = 20; i&gt;= 0; i--) &#123; if(d[fa[x][i]] &gt;= d[y]) &#123; x = fa[x][i]; &#125; &#125; if(x == y) return x; for(int i = 20; i&gt;=0; i--) &#123; if(fa[x][i] != fa[y][i]) &#123; x = fa[x][i]; y = fa[y][i]; &#125; &#125; return fa[x][0];&#125;int pre[MAX_N];void init(int n)&#123; for(int i = 1; i&lt;=n; i++) pre[i] = i;&#125;int Find(int x)&#123; return x == pre[x] ? x : pre[x] = Find(pre[x]);&#125;void Union(int x, int y)&#123; x = Find(x); y = Find(y); if(x != y) &#123; pre[y] = x; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n; cin &gt;&gt; n; init(n); for(int i = 1; i&lt;=n; i++) &#123; head[i] = -1; d[i] = 0; &#125; for(int i = 1; i&lt;n; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; Union(x, y); add(x, y); add(y, x); &#125; int r = Find(pre[1]); fa[r][0] = 0, d[r] = 1; dfs(r); for(int i = 1; i&lt;=20; i++) &#123; for(int j = 1; j&lt;=n; j++) &#123; fa[j][i] = fa[fa[j][i-1]][i-1]; &#125; &#125; int t; cin &gt;&gt; t; while(t--) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; lca(x, y) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>倍增LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最近公共祖先（LCA） 【倍增算法】]]></title>
    <url>%2F2018%2F11%2F12%2F%E6%B4%9B%E8%B0%B7-P3379%2F</url>
    <content type="text"><![CDATA[题目链接：洛谷-P3379&lt;/br&gt; 题目描述：如题，给定一棵有根多叉树，请求出指定两个点直接最近的公共祖先。 &lt;/br&gt; 思路这是一个裸的LCA问题，即求书上两个节点的最近公共祖先。我们可以用树上倍增来做； 当然，在做之前我们假设不知道该算法。那么我们如何来做这种类型的题目呢？显然，我们可以用暴力来做，找到两点的最近公共祖先，我们可以用前向星存双向边，然后依次存储每个点到的根的路径。然后找到最先同时出现在两条路径的公共点即可；显然，这样是可做的。但是这样做，考虑到:1.当书的深度非常大2.当最坏情况树退化为一条链式3.当询问次数非常多的时候。以上，无论那种情况，起步都是O（N^2）的复杂度,显然，这样的做法并不够优秀，所以我们引入倍增的做法，它可以NlogN的时间复杂度完成预处理，每次询问LogN的时间给出回答； 倍增算法：所谓倍增，就是按2的倍数来增大，也就是跳 1,2,4,8,16,32 …… 不过在这我们不是按从小到大跳，而是从大向小跳，即按……32,16,8,4,2,1来跳，如果大的跳不过去，再把它调小。这是因为从小开始跳，可能会出现“悔棋”的现象。拿 5为例，从小向大跳，5≠1+2+4,所以我们还要回溯一步，然后才能得出5=1+4；而从大向小跳，直接可以得出5=4+1。这也可以拿二进制为例，5(101)，从高位向低位填很简单，如果填了这位之后比原数大了，那我就不填，这个过程是很好操作的。 lca的倍增做法就是 用一个fa[i][j]数组 来存储 i 节点的 2^j 倍父亲是哪个节点； 这样做每次都是2倍区间查询，所以可以在logN的时间给出答案； 我们先跑一遍dfs， 初始化 深度 d数组 ， 初始化 fa[i][0] 。 跑一遍dfs后，d数组存储的就是每个节点的深度（默认根节点深度为1）. fa数组存储的就是 fa[i][0] 就是 每个节点存储的都是他父亲节点的编号； 跑完dfs，我们需要对全局fa进行赋值； 这里用到的转移方程是fa[i][j] = fa[fa[i][j-1]][j-1] 。比如(画的比较丑)2节点的 fa[2][0] 为 1 。 就是 2节点 的 (2^0 = 1)的父亲为 14节点的fa[4][0]为 2。 就是 4号节点的父亲为 2 要求 fa4 我们可以表示为 fa[fa[4][0]][0]， 就是4号父亲的父亲， 这样递推上去，就可以的出每个fa； 完成这步之后，我们剩下就是求Lca了； 先把x节点和y节点挪到同一层， 挪到同一层后， 若 x == y 代表一开始 x 就是y的祖先或者y是x的祖先； 若 x != y， 则 我们找到最深的满足 fa[x][i] != fa[y][i] ；然后返回x的父亲节点即可。至此，我们的算法就结束了； lca倍增学习：很明白的lca教程 易错点1.建树用前向星建， 注意边数为n-1条，双向边，则应该开辟MAX_N * 2空间2.此题输入输出量很大， 用scanf和printf输入输出；3.这题好像卡常数的样子？ 初始化head和深度d的时候用循环初始化，memset会超时！ AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX_N 500050int head[MAX_N], cnt = 0, d[MAX_N], fa[MAX_N][30];struct Node&#123; int to, next;&#125;edge[MAX_N * 2];void add(int x, int y)&#123; edge[cnt].to = y; edge[cnt].next = head[x]; head[x] = cnt++;&#125;void dfs(int v)&#123; for(int i = head[v]; i != -1; i = edge[i].next) &#123; int k = edge[i].to; if(d[k] == 0) &#123; d[k] = d[v] + 1; fa[k][0] = v; dfs(k); &#125; &#125;&#125;int lca(int x, int y)&#123; if(d[x] &lt; d[y]) &#123; swap(x, y); &#125; for(int i = 20; i&gt;=0; i--) &#123; if(d[fa[x][i]] &gt;= d[y]) x = fa[x][i]; &#125; if(x == y) return x; for(int i = 20; i &gt;= 0; i--) &#123; if(fa[x][i] != fa[y][i]) &#123; x = fa[x][i]; y = fa[y][i]; &#125; &#125; return fa[x][0];&#125;int main()&#123; int n, m, r; scanf("%d %d %d", &amp;n, &amp;m, &amp;r); for(int i = 1; i&lt;=n; i++) &#123; head[i] = -1; d[i] = 0; &#125; for(int i = 0; i&lt;n-1; i++) &#123; int x, y; scanf("%d %d", &amp;x, &amp;y); add(x, y); add(y, x); &#125; fa[r][0] = 0, d[r] = 1; dfs(r); for(int i = 1; i&lt;=20; i++) &#123; for(int j = 1; j&lt;=n; j++) &#123; fa[j][i] = fa[fa[j][i-1]][i-1]; &#125; &#125; while(m--) &#123; int x, y; scanf("%d %d", &amp;x, &amp;y); printf("%d\n", lca(x, y)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>倍增LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第43届ACM亚洲区域赛(青岛)总结]]></title>
    <url>%2F2018%2F11%2F06%2F43%E5%B1%8A%E9%9D%92%E5%B2%9B%E5%8C%BA%E5%9F%9F%E8%B5%9B%E6%84%9F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[从网络赛拿到名额的时候，就一直在训练，差不多训练了1个半月吧。实力也有所增长，但由于学校停电的原因，期间一直没打cf，只刷着Bin聚的专题，可能见到的题型少，遇到问题不能马上量化为熟悉的问题； 关于青岛 【青岛站附近的栈桥】第一次来打区域赛，感觉其他高校的环境真好啊，坐了大概1个小时的公交来到了中国石油大学，这里不得不吐槽青岛的公交，真的是拥挤啊！！！硬生生的站了一个小时，腿都站麻了！！！然后来到了校园里； 热身赛第一天的热身赛还是很轻松的，热身A，B题都属于基础题，但是C题是10道题目，然后让你判断正确，最后提交的结果是类似于TTTFFFTFT之类的字符串，很迷；然后惊现神人，wa了250发，hahahha；D题是一道比较难的题，我们看都看不懂，现场过的人也寥寥无几，热身赛还是很友好的，很满意！ 正赛正赛我们带了一堆板子，最后也没用上；一开始直接看后面的题，有一道画着 M题M题链接无疑，一道签到题，显然是一道递归问题，但可能会爆栈，所以加了点条件提前结束，就1A了。现在回想起来，数据范围都是1e9，貌似累加3次必定会出结果，比递归优秀点，但签到题，无所谓啦； J题J题链接然后我们开的是J题，这题大概就是个模拟吧，能取则取，不能取，则记录不能取序列里面的最小值，然后sum + MIN - 1 即可;这题我们wa了2发，第一法我发现我的Richman字母打错了，然后改了改交了一发，又是wa，然后又想了想爆int，改long long 后就过了；这2发罚时有点亏，完全可以避免的，扇自己的脸； C题C题链接C题题意容易理解，然后我们可以异或一下，比如 样例3 01010 00111 异或结果是 01101 我们需要勾住两个区间，然后对区间元素取反，使得最后得到全0的序列，问这样的方法有多少种；这里我们wa了6发，因为总结公式,分类不够全面，赛场上或许真的很难很快分析出来；也许有很简单的做法，很多队直接1A，也是真的强啊；当序列 为 两边为 1 中间包 1个连续 0 的话 直接输出 6当 序列 全是1 或者 全 0 时 共有 （n+1） n / 2 种方法当 序列 中间包两个0序列时 不可能构造出 直接输出 0当序列中间为 1 序列 两侧还有0的话 输出 （n+1） n / 2 + 2 + 两侧0的个数 * 2大概就是这样吧，分析了很久，唉，难受。 然后过完C题后，就剩1个半小时了，对比了下D和F，我们开了F，可能结果不尽人意，如果当时莽D的话，应该有可能过的。但当时看了下n，m的长度都是2e5，我想着那么长的数字，应该不可做，然后转F，但F感情是道图论题，太弱，最后只能痛苦的挂机等结束； 三题结束了青岛站；有一些遗憾吧；题目很好，菜是原罪。英语很重要！！！ PS：崂山可乐是真的好喝啊，已经买了一箱了，哈哈哈，没机会尝到崂山白花蛇草水也是可惜；]]></content>
      <categories>
        <category>比赛总结</category>
      </categories>
      <tags>
        <tag>-第43届ACM亚洲区域赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Balanced Lineup 【线段树】]]></title>
    <url>%2F2018%2F10%2F30%2F%E7%BA%BF%E6%AE%B5%E6%A0%91POJ-3264%2F</url>
    <content type="text"><![CDATA[题目链接：POJ-3264[kuangbin带你飞]专题七 线段树&lt;/br&gt; 题目描述：For the daily milking, Farmer John’s N cows (1 ≤ N ≤ 50,000) always line up in the same order. One day Farmer John decides to organize a game of Ultimate Frisbee with some of the cows. To keep things simple, he will take a contiguous range of cows from the milking lineup to play the game. However, for all the cows to have fun they should not differ too much in height. Farmer John has made a list of Q (1 ≤ Q ≤ 200,000) potential groups of cows and their heights (1 ≤ height ≤ 1,000,000). For each group, he wants your help to determine the difference in height between the shortest and the tallest cow in the group. &lt;/br&gt; 思路区间查询最大最小，可以用RMQ也可以用线段树；&lt;/br&gt; 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;#define MAX 50050#define INF 0x3f3f3f3fstruct Node&#123; int l, r, Max, Min;&#125;tree[MAX * 4];void push_up(int k)&#123; tree[k].Max = max(tree[k&lt;&lt;1].Max, tree[k&lt;&lt;1|1].Max); tree[k].Min = min(tree[k&lt;&lt;1].Min, tree[k&lt;&lt;1|1].Min);&#125;void build(int k, int l, int r)&#123; tree[k].l = l, tree[k].r = r; if(l == r) &#123; scanf("%d", &amp;tree[k].Max); tree[k].Min = tree[k].Max; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; build(k&lt;&lt;1, l, mid); build(k&lt;&lt;1|1, mid+1, r); push_up(k); &#125;&#125;int query_Max(int k, int l, int r)&#123; int L = tree[k].l, R = tree[k].r; if(l &lt;= L &amp;&amp; R &lt;= r) &#123; return tree[k].Max; &#125; else &#123; int tmp_max = -INF; int mid = (L + R) &gt;&gt; 1; if(l &lt;= mid) tmp_max = max(tmp_max, query_Max(k&lt;&lt;1, l, r)); if(mid &lt; r) tmp_max = max(tmp_max, query_Max(k&lt;&lt;1|1, l, r)); return tmp_max; &#125;&#125;int query_Min(int k, int l, int r)&#123; int L = tree[k].l, R = tree[k].r; if(l &lt;= L &amp;&amp; R &lt;= r) &#123; return tree[k].Min; &#125; else &#123; int tmp_min = INF; int mid = (L + R) &gt;&gt; 1; if(l &lt;= mid) tmp_min = min(tmp_min, query_Min(k&lt;&lt;1, l, r)); if(mid &lt; r) tmp_min = min(tmp_min, query_Min(k&lt;&lt;1|1, l, r)); return tmp_min; &#125;&#125;int main()&#123; int n, m; scanf("%d %d", &amp;n, &amp;m); build(1, 1, n); for(int i = 1; i&lt;=m; i++) &#123; int x, y; scanf("%d %d", &amp;x, &amp;y); printf("%d\n",query_Max(1, x, y) - query_Min(1, x, y)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞专题七 线段树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Just a Hook 【线段树】]]></title>
    <url>%2F2018%2F10%2F30%2F%E7%BA%BF%E6%AE%B5%E6%A0%91-HDU1698%2F</url>
    <content type="text"><![CDATA[题目链接：HDU-1698[kuangbin带你飞]专题七 线段树&lt;/br&gt; 题目描述：Now Pudge wants to do some operations on the hook. Let us number the consecutive metallic sticks of the hook from 1 to N. For each operation, Pudge can change the consecutive metallic sticks, numbered from X to Y, into cupreous sticks, silver sticks or golden sticks.The total value of the hook is calculated as the sum of values of N metallic sticks. More precisely, the value for each kind of stick is calculated as follows: For each cupreous stick, the value is 1.For each silver stick, the value is 2.For each golden stick, the value is 3. Pudge wants to know the total value of the hook after performing the operations.You may consider the original hook is made up of cupreous sticks. &lt;/br&gt; 思路区间修改，询问区间和。 典型的线段树板子题；易错1.需要用到lazy标记；&lt;/br&gt; 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;using namespace std;#define long long long#define MAX 100010struct Node&#123; long l, r, sum, lazy; void updata(long val) &#123; sum = (r - l + 1) * val; lazy = val; &#125;&#125;tree[MAX * 4];void push_up(int k)&#123; tree[k].sum = tree[k&lt;&lt;1].sum + tree[k&lt;&lt;1|1].sum;&#125;void push_down(int k)&#123; long lazyval = tree[k].lazy; if(lazyval) &#123; tree[k&lt;&lt;1].updata(lazyval); tree[k&lt;&lt;1|1].updata(lazyval); tree[k].lazy = 0; &#125;&#125;void build(int k, int l, int r)&#123; tree[k].l = l, tree[k].r = r; tree[k].sum = tree[k].lazy = 0; if(l == r) &#123; tree[k].sum = 1; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; build(k&lt;&lt;1, l, mid); build(k&lt;&lt;1|1, mid+1, r); push_up(k); &#125;&#125;void updata(int k, int l, int r, int val)&#123; int L = tree[k].l, R = tree[k].r; if(l &lt;= L &amp;&amp; R &lt;= r) &#123; tree[k].updata(val); &#125; else &#123; push_down(k); int mid = (L + R) &gt;&gt; 1; if(l &lt;= mid) updata(k&lt;&lt;1, l, r, val); if(mid &lt; r) updata(k&lt;&lt;1|1, l, r, val); push_up(k); &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t; cin &gt;&gt; t; for(int i = 1; i&lt;=t; i++) &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; build(1, 1, n); for(int j = 1; j&lt;=m; j++) &#123; int x, y, val; cin &gt;&gt; x &gt;&gt; y &gt;&gt; val; updata(1, x, y, val); &#125; cout &lt;&lt; "Case " &lt;&lt; i &lt;&lt; ": The total value of the hook is " &lt;&lt; tree[1].sum &lt;&lt; "." &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞专题七 线段树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A Simple Problem with Integers 【线段树】]]></title>
    <url>%2F2018%2F10%2F30%2F%E7%BA%BF%E6%AE%B5%E6%A0%91POJ-3468%2F</url>
    <content type="text"><![CDATA[题目链接：POJ-3468[kuangbin带你飞]专题七 线段树&lt;/br&gt; 题目描述：You have N integers, A1, A2, … , AN. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval. &lt;/br&gt; 思路区间修改，询问区间和。 典型的线段树板子题；易错1.需要用到lazy标记2.数据范围可能会爆int， 数据类型开 long long&lt;/br&gt; 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;iostream&gt;using namespace std;#define MAX 100010struct Node&#123; long long l, r; long long sum, lazy; void updata(long long val) &#123; sum += (r - l + 1) * val; lazy += val; &#125; &#125;tree[MAX * 4];void push_up(int k)&#123; tree[k].sum = tree[k&lt;&lt;1].sum + tree[k&lt;&lt;1|1].sum;&#125;void push_down(int k)&#123; long long lazyval = tree[k].lazy; if(lazyval) &#123; tree[k&lt;&lt;1].updata(lazyval); tree[k&lt;&lt;1|1].updata(lazyval); tree[k].lazy = 0; &#125;&#125;void build(int k, int l, int r)&#123; tree[k].l = l, tree[k].r = r; tree[k].sum = tree[k].lazy = 0; if(l == r) &#123; cin &gt;&gt; tree[k].sum; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; build(k&lt;&lt;1, l, mid); build(k&lt;&lt;1|1, mid+1, r); push_up(k); &#125;&#125;void updata(int k, int l, int r, long long val)&#123; int L = tree[k].l, R = tree[k].r; if(l &lt;= L &amp;&amp; R &lt;= r) &#123; tree[k].updata(val); &#125; else &#123; push_down(k); int mid = (L + R) &gt;&gt; 1; if(l &lt;= mid) updata(k&lt;&lt;1, l, r, val); if(mid &lt; r) updata(k&lt;&lt;1|1, l, r, val); push_up(k); &#125;&#125;long long query(int k, int l, int r)&#123; int L = tree[k].l, R = tree[k].r; if(l &lt;= L &amp;&amp; R &lt;= r) &#123; return tree[k].sum; &#125; else &#123; long long tmp = 0; push_down(k); int mid = (L + R) &gt;&gt; 1; if(l &lt;= mid) tmp += query(k&lt;&lt;1, l, r); if(mid &lt; r) tmp += query(k&lt;&lt;1|1, l, r); push_up(k); return tmp; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n, m; while(cin &gt;&gt; n &gt;&gt; m) &#123; build(1, 1, n); for(int i = 1; i&lt;=m; i++) &#123; string s; cin &gt;&gt; s; if(s == "Q") &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; query(1, x, y) &lt;&lt; endl; &#125; else &#123; long long x, y, val; cin &gt;&gt; x &gt;&gt; y &gt;&gt; val; updata(1, x, y, val); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞专题七 线段树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[I Hate It 【线段树】]]></title>
    <url>%2F2018%2F10%2F30%2F%E7%BA%BF%E6%AE%B5%E6%A0%91-HDU1754%2F</url>
    <content type="text"><![CDATA[题目链接：HDU-1754[kuangbin带你飞]专题七 线段树&lt;/br&gt; 题目描述：很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。这让很多学生很反感。 不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。 &lt;/br&gt; 思路单点修改，区间询问最值，典型的RMQ问题；这里用线段树写的；树状数组和RMQ问题，大多数都可以利用线段树来解决！&lt;/br&gt; 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX 200010struct Node&#123; int l, r, Max;&#125;tree[MAX * 4];void push_up(int k)&#123; tree[k].Max = max(tree[k&lt;&lt;1].Max, tree[k&lt;&lt;1|1].Max);&#125;void build(int k, int l, int r)&#123; tree[k].l = l, tree[k].r = r; if(l == r) &#123; cin &gt;&gt; tree[k].Max; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; build(k&lt;&lt;1, l, mid); build(k&lt;&lt;1|1, mid+1, r); push_up(k); &#125;&#125;void updata(int k, int l, int r, int val)&#123; int L = tree[k].l, R = tree[k].r; if(l &lt;= L &amp;&amp; R &lt;= r) &#123; tree[k].Max = val; &#125; else &#123; int mid = (L + R) &gt;&gt; 1; if(l &lt;= mid) updata(k&lt;&lt;1, l, r, val); if(mid &lt; r) updata(k&lt;&lt;1|1, l, r, val); push_up(k); &#125;&#125;int query(int k, int l, int r)&#123; int L = tree[k].l, R = tree[k].r; if(l &lt;= L &amp;&amp; R &lt;= r) &#123; return tree[k].Max; &#125; else &#123; int tmp = -0x3f3f3f3f; int mid = (L + R) &gt;&gt; 1; if(l &lt;= mid) tmp = max(tmp, query(k&lt;&lt;1, l, r)); if(mid &lt; r) tmp = max(tmp, query(k&lt;&lt;1|1, l, r)); return tmp; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n, m; while(cin &gt;&gt; n &gt;&gt; m) &#123; build(1, 1, n); for(int i = 1; i&lt;=m; i++) &#123; string s; cin &gt;&gt; s; if(s == "Q") &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; query(1, x, y) &lt;&lt; endl; &#125; else &#123; int x, val; cin &gt;&gt; x &gt;&gt; val; updata(1, x, x, val); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞专题七 线段树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[敌兵布阵 【线段树】]]></title>
    <url>%2F2018%2F10%2F30%2F%E7%BA%BF%E6%AE%B5%E6%A0%91-HDU1166%2F</url>
    <content type="text"><![CDATA[题目链接：HDU-1166[kuangbin带你飞]专题七 线段树&lt;/br&gt; 题目描述：C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的. &lt;/br&gt; 思路典型的单点修改，询问区间和区间； 所以我们可以运用树状数组或者线段树来解决；&lt;/br&gt; 树状数组代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX 50050int tree[MAX], n;int lowbit(int k)&#123; return k &amp; -k;&#125;void add(int index, int val)&#123; while(index &lt;= n) &#123; tree[index] += val; index += lowbit(index); &#125;&#125;int query(int x)&#123; int sum = 0; while(x &gt; 0) &#123; sum += tree[x]; x -= lowbit(x); &#125; return sum;&#125;int main()&#123; int t; cin &gt;&gt; t; for(int i = 1; i&lt;=t; i++) &#123; cout &lt;&lt; "Case " &lt;&lt; i &lt;&lt; ":" &lt;&lt; endl; memset(tree, 0, sizeof(tree)); cin &gt;&gt; n; for(int i = 1; i&lt;=n; i++) &#123; int tmp; cin &gt;&gt; tmp; add(i, tmp); &#125; string s; while(cin &gt;&gt; s, s != "End") &#123; if(s == "Query") &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt;query(y) - query(x-1) &lt;&lt; endl; &#125; else if(s == "Add") &#123; int x, val; cin &gt;&gt; x &gt;&gt; val; add(x, val); &#125; else &#123; int x, val; cin &gt;&gt; x &gt;&gt; val; add(x, -val); &#125; &#125; &#125; return 0;&#125; 线段树代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX 50050struct Node&#123; int l, r, sum;&#125;tree[MAX * 4];void push_up(int k)&#123; tree[k].sum = tree[k&lt;&lt;1].sum + tree[k&lt;&lt;1|1].sum;&#125;void build(int k, int l, int r)&#123; tree[k].l = l, tree[k].r = r; if(l == r) &#123; cin &gt;&gt; tree[k].sum; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; build(k&lt;&lt;1, l, mid); build(k&lt;&lt;1|1, mid+1, r); push_up(k); &#125;&#125;void updata(int k, int l, int r, int val)&#123; int L = tree[k].l, R = tree[k].r; if(l &lt;= L &amp;&amp; R &lt;= r) &#123; tree[k].sum += val; &#125; else &#123; int mid = (L + R) &gt;&gt; 1; if(l &lt;= mid) updata(k&lt;&lt;1, l, r, val); if(mid &lt; r) updata(k&lt;&lt;1|1, l, r, val); push_up(k); &#125;&#125;int query(int k, int l, int r)&#123; int L = tree[k].l, R = tree[k].r; if(l &lt;= L &amp;&amp; R &lt;= r) &#123; return tree[k].sum; &#125; else &#123; int tmp = 0; int mid = (L + R) &gt;&gt; 1; if(l &lt;= mid) tmp += query(k&lt;&lt;1, l, r); if(mid &lt; r) tmp += query(k&lt;&lt;1|1, l, r); push_up(k); return tmp; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t; cin &gt;&gt; t; for(int i = 1; i&lt;=t; i++) &#123; cout &lt;&lt; "Case " &lt;&lt; i &lt;&lt; ":" &lt;&lt; endl; int n; cin &gt;&gt; n; build(1, 1, n); string s; while(cin &gt;&gt; s, s != "End") &#123; if(s == "Query") &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; query(1, x, y) &lt;&lt; endl; &#125; else if(s == "Add") &#123; int x, val; cin &gt;&gt; x &gt;&gt; val; updata(1, x, x, val); &#125; else &#123; int x, val; cin &gt;&gt; x &gt;&gt; val; updata(1, x, x, -val); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞专题七 线段树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1068 Bash游戏 V3 【博弈】]]></title>
    <url>%2F2018%2F10%2F28%2F51nod-1068%2F</url>
    <content type="text"><![CDATA[题目链接：51nod-1068&lt;/br&gt; 题目描述：有一堆石子共有N个。A B两个人轮流拿，A先拿。每次拿的数量只能是2的正整数次幂，比如(1,2,4,8,16….)，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N，问最后谁能赢得比赛。例如N = 3。A只能拿1颗或2颗，所以B可以拿到最后1颗石子。（输入的N可能为大数） &lt;/br&gt; 思路神奇的博弈论；这个题就不是裸了，我们需要打出sg表，找出规律之后才可以做；关于sg的打表，看下面两个博客就可以学会啦！关于博弈论的学习Blog：1.博弈论及算法实现2.SG函数和SG定理【详解】&lt;/br&gt; 过程我们先用sg函数打一个0-100的表 看一下规律; 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;#define N 10#define MAX 1000int f[N], sg[MAX], vis[MAX];void init(int n)&#123; memset(sg, 0, sizeof(sg)); for(int i = 1; i&lt;=n; i++) &#123; memset(vis, 0, sizeof(vis)); for(int j = 0; f[j] &lt;= i &amp;&amp; j &lt; N; j++) &#123; vis[sg[i - f[j]]] = 1; &#125; for(int j = 0; ; j++) &#123; if(!vis[j]) &#123; sg[i] = j; break; &#125; &#125; &#125;&#125;int main()&#123; for(int i = 0; i&lt;N; i++) f[i] = pow(2, i); init(100); for(int i = 0; i&lt;100; i++) &#123; cout &lt;&lt; "i = " &lt;&lt; i &lt;&lt; " sg[i] = " &lt;&lt; sg[i] &lt;&lt; endl; &#125; return 0;&#125; 结果是这样:可以看出 当 n % 3 是 先手必败 否则先手必胜；注意一点这里给出的n可能是大数，所以我们用string接受，然后逐位求和膜3即可； AC代码12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int t; cin &gt;&gt; t; while(t--) &#123; string s; cin &gt;&gt; s; int sum = 0; for(int i = 0; i&lt;s.length(); i++) &#123; sum += s[i] - '0'; &#125; if(sum % 3 == 0) cout &lt;&lt; "B" &lt;&lt; endl; else cout &lt;&lt; "A" &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>51nod</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1067 Bash游戏 V2 【博弈】]]></title>
    <url>%2F2018%2F10%2F28%2F51nod%20-%201067%E5%8D%9A%E5%BC%88%2F</url>
    <content type="text"><![CDATA[题目链接：51nod-1067&lt;/br&gt; 题目描述：有一堆石子共有N个。A B两个人轮流拿，A先拿。每次只能拿1，3，4颗，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N，问最后谁能赢得比赛。例如N = 2。A只能拿1颗，所以B可以拿到最后1颗石子。 &lt;/br&gt; 思路神奇的博弈论；这个题就不是裸了，我们需要打出sg表，找出规律之后才可以做；关于sg的打表，看下面两个博客就可以学会啦！but：发现大牛的小问题，就是这个 j &lt;= N 我觉得有问题， 他可能会把自己的sg加入到s序列 导致最后的sg表不正确；【实例】取石子问题 有1堆n个的石子，每次只能取{ 1, 3, 4 }个石子，先取完石子者胜利，那么各个数的SG值为多少？ SG[0]=0，f[]={1,3,4}, x=1 时，可以取走1 - f{1}个石子，剩余{0}个，所以 SG1 = mex{ SG[0] }= mex{0} = 1; x=2 时，可以取走2 - f{1}个石子，剩余{1}个，所以 SG2 = mex{ SG1 }= mex{1} = 0; x=3 时，可以取走3 - f{1,3}个石子，剩余{2,0}个，所以 SG3 = mex{SG2,SG[0]} = mex{0,0} =1; x=4 时，可以取走4- f{1,3,4}个石子，剩余{3,1,0}个，所以 SG[4] = mex{SG3,SG1,SG[0]} = mex{1,1,0} = 2; x=5 时，可以取走5 - f{1,3,4}个石子，剩余{4,2,1}个，所以SG[5] = mex{SG[4],SG2,SG1} =mex{2,0,1} = 3;以下是自己的延伸：x=6时，可以取走6 - f{1, 3, 4}个石子，剩余{5, 3, 2}个，所以SG[5] = mae{SG[5], SG3, SG2} = mex{3, 1, 0}终点来了，就是当x=7时会出现问题x=7时，按原大牛的写法可以取走 7 - f{1,3,4}, 但是当 i == 7时， 两个条件都满足，会把 SG[7]也加进去， 导致SG[7]得到的不是正确的结果！关于博弈论的学习Blog：1.博弈论及算法实现2.SG函数和SG定理【详解】&lt;/br&gt; 过程我们先用sg函数打一个0-100的表 看一下规律; 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;#define N 3#define MAX 1000int f[N], sg[MAX], vis[MAX];void init(int n)&#123; memset(sg, 0, sizeof(sg)); for(int i = 1; i&lt;=n; i++) &#123; memset(vis, 0, sizeof(vis)); for(int j = 0; f[j] &lt;= i &amp;&amp; j &lt; N; j++) &#123; vis[sg[i - f[j]]] = 1; &#125; for(int j = 0; ; j++) &#123; if(!vis[j]) &#123; sg[i] = j; break; &#125; &#125; &#125;&#125;int main()&#123; f[0] = 1, f[1] = 3, f[2] = 4; init(100); for(int i = 0; i&lt;100; i++) &#123; cout &lt;&lt; "i = " &lt;&lt; i &lt;&lt; " sg[i] = " &lt;&lt; sg[i] &lt;&lt; endl; &#125; return 0;&#125; 结果是这样:可以看出 当 n % 7 == 0 || (n - 2) % 7 == 0 是 先手必败 否则先手必胜； AC代码1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int t; cin &gt;&gt; t; while(t--) &#123; int n; cin &gt;&gt; n; if(n % 7 == 0 || (n - 2) % 7 == 0) cout &lt;&lt; "B" &lt;&lt; endl; else cout &lt;&lt; "A" &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>51nod</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1066 Bash游戏 【博弈】]]></title>
    <url>%2F2018%2F10%2F28%2F51nod-1066%E5%8D%9A%E5%BC%88%2F</url>
    <content type="text"><![CDATA[题目链接：51nod-1066&lt;/br&gt; 题目描述：有一堆石子共有N个。A B两个人轮流拿，A先拿。每次最少拿1颗，最多拿K颗，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N和K，问最后谁能赢得比赛。例如N = 3，K = 2。无论A如何拿，B都可以拿到最后1颗石子。 &lt;/br&gt; 思路神奇的博弈论，Bash游戏的板子题。石子总数对(最大可取数+1)取模，若最后的结果为0，则后手必胜，否则先手必胜（两面都聪明，取最优策略） 关于博弈论的学习Blog：1.博弈论及算法实现2.SG函数和SG定理【详解】&lt;/br&gt; AC代码1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int t; cin &gt;&gt; t; while(t--) &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; if(n%(k+1) == 0) cout&lt;&lt;"B"&lt;&lt;endl; else cout&lt;&lt;"A"&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>51nod</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1069 Nim游戏 【博弈】]]></title>
    <url>%2F2018%2F10%2F28%2F51nod-1069%E5%8D%9A%E5%BC%88%2F</url>
    <content type="text"><![CDATA[题目链接：51nod-1069&lt;/br&gt; 题目描述：有N堆石子。A B两个人轮流拿，A先拿。每次只能从一堆中取若干个，可将一堆全取走，但不可不取，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N及每堆石子的数量，问最后谁能赢得比赛。例如：3堆石子，每堆1颗。A拿1颗，B拿1颗，此时还剩1堆，所以A可以拿到最后1颗石子。 &lt;/br&gt; 思路神奇的博弈论，Nim游戏的板子题。对N对石子取异或操作，若最后的结果为0，则后手必胜，否则先手必胜（两面都聪明，取最优策略） 关于博弈论的学习Blog：1.博弈论及算法实现2.SG函数和SG定理【详解】&lt;/br&gt; AC代码12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; int ans = 0; for(int i = 1; i&lt;=n; i++) &#123; int tmp; cin &gt;&gt; tmp; ans ^= tmp; &#125; if(ans) cout &lt;&lt; "A"; else cout &lt;&lt; "B"; return 0;&#125;]]></content>
      <categories>
        <category>51nod</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个人的旅行 【Dijkstra+堆优化】]]></title>
    <url>%2F2018%2F10%2F25%2F%E6%9C%80%E7%9F%AD%E8%B7%AF-HDU-2066%2F</url>
    <content type="text"><![CDATA[题目链接：HDU-2066&lt;/br&gt; 题目描述：虽然草儿是个路痴（就是在杭电待了一年多，居然还会在校园里迷路的人，汗~),但是草儿仍然很喜欢旅行，因为在旅途中 会遇见很多人（白马王子，^0^），很多事，还能丰富自己的阅历，还可以看美丽的风景……草儿想去很多地方，她想要去东京铁塔看夜景，去威尼斯看电影，去阳明山上看海芋，去纽约纯粹看雪景，去巴黎喝咖啡写信，去北京探望孟姜女……眼看寒假就快到了，这么一大段时间，可不能浪费啊，一定要给自己好好的放个假，可是也不能荒废了训练啊，所以草儿决定在要在最短的时间去一个自己想去的地方！因为草儿的家在一个小镇上，没有火车经过，所以她只能去邻近的城市坐火车（好可怜啊~）。 &lt;/br&gt; 思路一开始看着是多源最短路，所以用Floyd算法搞了搞，然后交了一发TLE， 看到他的顶点数 &lt;= 1000 所以n的复杂度必然会超时，所以有用Dijkstra+堆优化搞了一下；计算多次从指定出发点出发的最短路，每次取出最小的终点；双重循环就可以搞定； 易错：1.给出的边是无向边；2.可能y有重边&lt;/br&gt; TLE代码 Floyd算法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX_N 1010#define INF 0x3f3f3f3fint mat[MAX_N][MAX_N];void init()&#123; for(int i = 1; i&lt;MAX_N; i++) &#123; for(int j = 1; j&lt;MAX_N; j++) mat[i][j] = INF; &#125;&#125;void Floyd(int n)&#123; for(int k = 1; k&lt;=n; k++) &#123; for(int i = 1; i&lt;=n; i++) &#123; for(int j = 1; j&lt;=n; j++) if(mat[i][k] + mat[k][j] &lt; mat[i][j]) mat[i][j] = mat[i][k] + mat[k][j]; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t, s, d; int x, y, val; while(cin &gt;&gt; t &gt;&gt; s &gt;&gt; d) &#123; init(); int tmp_max = -INF; for(int i = 1; i&lt;=t; i++) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; val; tmp_max = max(tmp_max, max(x, y)); mat[x][y] = val; &#125; Floyd(tmp_max); vector&lt;int&gt; a, b; for(int i = 1; i&lt;=s; i++) &#123; int tmp; cin &gt;&gt; tmp; a.push_back(tmp); &#125; for(int i = 1; i&lt;=d; i++) &#123; int tmp; cin &gt;&gt; tmp; b.push_back(tmp); &#125; int tmp_min = INF; for(int i = 0; i&lt;a.size(); i++) &#123; for(int j = 0; j&lt;b.size(); j++) &#123; tmp_min = min(tmp_min, mat[a[i]][b[j]]); &#125; &#125; cout &lt;&lt;tmp_min &lt;&lt; endl; &#125; return 0;&#125; AC代码 Dijkstra + 堆优化算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX_N 1010#define MAX_M 100010#define INF 0x3f3f3f3fint head[MAX_M], dist[MAX_N], vis[MAX_N], cnt = 0;struct Node&#123; int to, val, next;&#125;edge[MAX_M];struct Min_Heap&#123; int key, val; bool operator &lt; (const Min_Heap &amp;a) const &#123; return a.val &lt; val; &#125; Min_Heap(int tmp_key, int tmp_val) &#123; key = tmp_key; val = tmp_val; &#125;&#125;;void init(int n)&#123; cnt = 0; memset(head, -1, sizeof(head)); memset(vis, 0, sizeof(vis)); for(int i = 1; i&lt;=n; i++) dist[i] = INF;&#125;void add(int x, int y, int val)&#123; edge[cnt].to = y; edge[cnt].val = val; edge[cnt].next = head[x]; head[x] = cnt++;&#125;void Dijkstra(int n, int v)&#123; priority_queue&lt;Min_Heap&gt; S; dist[v] = 0; S.push(Min_Heap(v, dist[v])); while(!S.empty()) &#123; Min_Heap h = S.top(); S.pop(); if(vis[h.key]) continue; vis[h.key] = 1; for(int j = head[h.key]; j != -1; j = edge[j].next) &#123; int v = edge[j].to; if(!vis[v] &amp;&amp; h.val + edge[j].val &lt; dist[v]) &#123; dist[v] = h.val + edge[j].val; S.push(Min_Heap(v, dist[v])); &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t, s, d; while(cin &gt;&gt; t &gt;&gt; s &gt;&gt; d) &#123; init(MAX_N-1); int tmp_max = -INF; for(int i = 1; i&lt;=t; i++) &#123; int x, y, val; cin &gt;&gt; x &gt;&gt; y &gt;&gt; val; tmp_max = max(tmp_max, max(x, y)); add(x, y, val); add(y, x, val); &#125; vector&lt;int&gt; a, b; for(int i = 1; i&lt;=s; i++) &#123; int tmp; cin &gt;&gt; tmp; a.push_back(tmp); &#125; for(int i = 1; i&lt;=d; i++) &#123; int tmp; cin &gt;&gt; tmp; b.push_back(tmp); &#125; int tmp_min = INF; for(int i = 0; i&lt;a.size(); i++) &#123; int v = a[i]; memset(vis, 0, sizeof(vis)); Dijkstra(tmp_max, v); for(int j = 0; j&lt;b.size(); j++) &#123; tmp_min = min(tmp_min, dist[b[j]]); &#125; &#125; cout &lt;&lt; tmp_min &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞【专题六】 最短路</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[过山车 【二分图匹配】]]></title>
    <url>%2F2018%2F10%2F25%2F%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95-HDU2063%2F</url>
    <content type="text"><![CDATA[题目链接：HDU-2063&lt;/br&gt; 题目描述：RPG girls今天和大家一起去游乐场玩，终于可以坐上梦寐以求的过山车了。可是，过山车的每一排只有两个座位，而且还有条不成文的规矩，就是每个女生必须找个个男生做partner和她同坐。但是，每个女孩都有各自的想法，举个例子把，Rabbit只愿意和XHD或PQK做partner，Grass只愿意和linle或LL做partner，PrincessSnow愿意和水域浪子或伪酷儿做partner。考虑到经费问题，boss刘决定只让找到partner的人去坐过山车，其他的人，嘿嘿，就站在下面看着吧。聪明的Acmer，你可以帮忙算算最多有多少对组合可以坐上过山车吗？ &lt;/br&gt; 思路匈牙利算法的裸题，每次得注意临接矩阵的初始化，防止多次使用临接矩阵时未进行初始化倒置答案错误；匈牙利算法，感觉就是dfs判断有无其他可以相连的边，不断的腾出位置，也是个不断试探的过程！&lt;/br&gt; 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX_N 550int mat[MAX_N][MAX_N], vis[MAX_N], link[MAX_N], k, n, m;bool dfs(int n)&#123; for(int i = 1; i&lt;=m; i++) &#123; if(mat[n][i] &amp;&amp; !vis[i]) &#123; vis[i] = 1; if(link[i] == -1 || dfs(link[i])) &#123; link[i] = n; return 1; &#125; &#125; &#125; return 0;&#125;int hungury()&#123; int ans = 0; for(int i = 1; i&lt;=n; i++) &#123; memset(vis, 0, sizeof(vis)); if(dfs(i)) ans++; &#125; return ans;&#125;int main()&#123; while(cin &gt;&gt; k, k) &#123; cin &gt;&gt; n &gt;&gt; m; memset(mat, 0, sizeof(mat)); memset(link, -1, sizeof(link)); for(int i = 1; i&lt;=k; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; mat[x][y] = 1; &#125; cout &lt;&lt; hungury() &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Silver Cow Party]]></title>
    <url>%2F2018%2F10%2F22%2F%E6%9C%80%E7%9F%AD%E8%B7%AFPOJ-3268%2F</url>
    <content type="text"><![CDATA[题目链接：POJ-3268&lt;/br&gt;kuangbin带你飞【专题六】 最短路 题目描述：有编号为1－N的牛，它们之间存在一些单向的路径。给定一头牛的编号，其他牛要去拜访它并且拜访完之后要返回自己原来的位置，求这些牛中所花的最长的来回时间是多少。 &lt;/br&gt; 思路我们很容易求出从给定点出发，到其他顶点的最短路。那如何求出其他顶点到给定点的最短路呢？ 我们可以反向存边，再来计算一次从给定顶点到其他顶点的最短路，两次求出的最短路求和，然后找出最大的那个数值，就是答案！&lt;/br&gt; 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;#define MAX_N 1010#define MAX_M 100010#define INF 0x3f3f3f3fint dist[MAX_N], vis[MAX_N], mat[MAX_N][MAX_N];struct Min_Heap&#123; int key, val; bool operator &lt; (const Min_Heap &amp;a) const &#123; return a.val &lt; val; &#125; Min_Heap(int tmp_key, int tmp_val) &#123; key = tmp_key; val = tmp_val; &#125;&#125;;void init(int n)&#123; memset(vis, 0, sizeof(vis)); for(int i = 1; i&lt;=n; i++) &#123; for(int j = 1; j&lt;=n; j++) mat[i][j] = INF; dist[i] = INF; &#125;&#125;void Union(int x, int y, int val)&#123; if(val &lt; mat[x][y]) mat[x][y] = val;&#125;void Dijkstra(int n, int v)&#123; priority_queue&lt;Min_Heap&gt; S; dist[v] = 0; S.push(Min_Heap(v, 0)); while(!S.empty()) &#123; Min_Heap h = S.top(); S.pop(); int k = h.key, val = h.val; if(vis[k]) continue; vis[k] = 1; for(int i = 1; i&lt;=n; i++) &#123; if(!vis[i] &amp;&amp; val + mat[k][i] &lt; dist[i]) &#123; dist[i] = val + mat[k][i]; S.push(Min_Heap(i, dist[i])); &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n, m, v; int len[MAX_N]; memset(len, 0, sizeof(len)); cin &gt;&gt; n &gt;&gt; m &gt;&gt; v; init(n); for(int i = 1; i&lt;=m; i++) &#123; int x, y, val; cin &gt;&gt; x &gt;&gt; y &gt;&gt; val; Union(x, y, val); &#125; Dijkstra(n, v);//计算每只回去时最少的时间 for(int i = 1; i&lt;=n; i++) len[i] += dist[i]; for(int i = 1; i&lt;=n; i++) &#123; for(int j = 1; j&lt;i; j++) swap(mat[i][j], mat[j][i]); &#125; for(int i = 1; i&lt;=n; i++) dist[i] = INF; memset(vis, 0, sizeof(vis)); Dijkstra(n, v);//计算每只来时最少的时间 for(int i = 1; i&lt;=n; i++) len[i] += dist[i]; int MAX = -INF; for(int i = 1; i&lt;=n; i++) MAX = max(MAX, len[i]); cout &lt;&lt; MAX; return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞【专题六】 最短路</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【计蒜客】 闯关游戏 Spfa判断环]]></title>
    <url>%2F2018%2F10%2F22%2F%E6%9C%80%E7%9F%AD%E8%B7%AF-%E8%AE%A1%E8%92%9C%E5%AE%A2-%E9%97%AF%E5%85%B3%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[题目链接：【计蒜客】 闯关游戏&lt;/br&gt;kuangbin带你飞【专题六】 最短路 题目描述： &lt;/br&gt; 思路参考spfa算法，将节点增加或减少的值作为路径长度，我们要做的是找到每个点到起点的最大路径。在之前的Spfa算法中，我们是要寻找最短路径，即 dist[u] + w[u][v] &lt; dist[v] 则更新dist[v]。在此题中，我们需要寻找最长的那条路径；即 dist[u] + w[u][v] &gt; dist[v]，则需要更新dist[v]。在更新的过程中，若更新的某个点的最大路径为负数，说明不能到达此房间，不要入队。若最后不能到达目标点或者目标点的最大路径为负，则判断为No注意：在之前的最短路问题中，我们遇到负权值回路时，则其没有最短路（可以一直在负权值回路中绕圈子）。在此题中，我们类比，当最长路可以不断增加时，即存在正权值回路时，我们可以在这个圈子中一直绕。所以若有正环，说明可在此无限增加体力，可直接判断为Yes。&lt;/br&gt; 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX_N 110#define MAX_M 500050#define INF 0x3f3f3f3fint head[MAX_M], dist[MAX_N], vis[MAX_N], num[MAX_N], cnt = 0;struct Node&#123; int to, val, next;&#125;edge[MAX_M];void init(int n)&#123; cnt = 0; memset(head, -1, sizeof(head)); memset(vis, 0, sizeof(vis)); memset(num, 0, sizeof(num)); for(int i = 1; i&lt;=n; i++) dist[i] = -INF;&#125;void add(int x, int y, int val)&#123; edge[cnt].to = y; edge[cnt].val = val; edge[cnt].next = head[x]; head[x] = cnt++;&#125;void Spfa(int n, int v)&#123; queue&lt;int&gt; S; S.push(v); dist[v] = 100; vis[v] = 1; num[v]++; while(!S.empty()) &#123; int k = S.front(); S.pop(); vis[k] = 0; for(int i = head[k]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if(dist[v] &lt; edge[i].val + dist[k] &amp;&amp; edge[i].val + dist[k] &gt; 0) &#123; dist[v] = edge[i].val + dist[k]; if(!vis[v]) &#123; S.push(v); num[v]++; if(num[v] &gt;= n) &#123; cout &lt;&lt; "Yes"; return ; &#125; &#125; &#125; &#125; &#125; if(dist[n] &gt; 0) cout &lt;&lt; "Yes"; else cout &lt;&lt; "No";&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n; cin &gt;&gt; n; init(n); for(int i = 1; i&lt;=n; i++) &#123; int val, m; cin &gt;&gt; val &gt;&gt; m; for(int j = 1; j&lt;=m; j++) &#123; int tmp; cin &gt;&gt;tmp; add(i, tmp, val); &#125; &#125; Spfa(n, 1); return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞【专题六】 最短路</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wormholes SPFA算法]]></title>
    <url>%2F2018%2F10%2F21%2F%E6%9C%80%E7%9F%AD%E8%B7%AFPOJ-3259%2F</url>
    <content type="text"><![CDATA[题目链接：POJ-3259&lt;/br&gt;kuangbin带你飞【专题六】 最短路 题目描述：农夫 FJ 有 N 块田地【编号 1…n】 (1&lt;=N&lt;=500) 田地间有 M 条路径 【双向】(1&lt;= M &lt;= 2500) 同时有 W 个孔洞,可以回到以前的一个时间点【单向】(1&lt;= W &lt;=200) 问：FJ 是否能在田地中遇到以前的自己 &lt;/br&gt; 思路田地间的双向路径加边,权值为正 孔洞间的单向路径加边,权值为负【可以回到以前】 判断有向图是否存在负环 因为如果存在了负数环,时间就会不停的减少, 那么 FJ 就可以回到以前更远的地方,肯定能遇到以前的自己的 运用Spfa算法，当某个点入队次数 &gt;= 顶点数， 说明存在负权值回路，我们直接return true；否则dist数组里存储的就是单源最短路的距离；&lt;/br&gt; 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;#define MAX_N 550#define MAX_M 5050#define INF 0x3f3f3f3fint head[MAX_M], vis[MAX_N], dist[MAX_N], cnt = 0, Count[MAX_N];struct Node&#123; int to, val, next;&#125;edge[MAX_M];void init(int n)&#123; cnt = 0; memset(Count, 0, sizeof(Count)); memset(head, -1, sizeof(head)); memset(vis, 0, sizeof(vis)); for(int i = 1; i&lt;=n; i++) &#123; dist[i] = INF; &#125;&#125;void add(int x, int y, int val)&#123; edge[cnt].to = y; edge[cnt].val = val; edge[cnt].next = head[x]; head[x] = cnt++;&#125;bool Spfa(int n, int v)&#123; queue&lt;int&gt; S; S.push(v); dist[v] = 0; vis[v] = 1; Count[v]++; while(!S.empty()) &#123; int k = S.front(); S.pop(); vis[k] = 0; for(int i = head[k]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if(dist[k] + edge[i].val &lt; dist[v]) &#123; dist[v] = dist[k] + edge[i].val; if(!vis[v]) &#123; S.push(v); Count[v]++; vis[v] = 1; if(Count[v] &gt;= n) return true; &#125; &#125; &#125; &#125; return false;&#125;int main()&#123; int T; cin &gt;&gt; T; while(T--) &#123; int n, a, b; cin &gt;&gt; n &gt;&gt; a &gt;&gt; b; init(n); for(int i = 1; i&lt;=a; i++)//正权无向边 &#123; int x, y, val; cin &gt;&gt; x &gt;&gt; y &gt;&gt; val; add(x, y, val); add(y, x, val); &#125; for(int i = 1; i&lt;=b; i++) &#123; int x, y, val; cin &gt;&gt; x &gt;&gt; y &gt;&gt; val; add(x, y, -val); &#125; if(Spfa(n, 1)) cout &lt;&lt; "YES" &lt;&lt; endl; else cout &lt;&lt; "NO" &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞【专题六】 最短路</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[畅通工程续 SPFA算法]]></title>
    <url>%2F2018%2F10%2F21%2F%E6%9C%80%E7%9F%AD%E8%B7%AF-spfa%2F</url>
    <content type="text"><![CDATA[题目链接：HDU-1874&lt;/br&gt; 题目描述：某省自从实行了很多年的畅通工程计划后，终于修建了很多路。不过路多了也不好，每次要从一个城镇到另一个城镇时，都有许多种道路方案可以选择，而某些方案要比另一些方案行走的距离要短很多。这让行人很困扰。 现在，已知起点和终点，请你计算出要从起点到终点，最短需要行走多少距离。 &lt;/br&gt; 思路使用Spfa算法ac的此题；易错点:使用前向星存图，如果只是一次计算，cnt可以只是全局初始化一次，若有多次计算，则init里面必须初始cnt = 0 ， 否则会与之前的数据冲突，发生一些意想不到的错误；&lt;/br&gt; 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX_N 210#define MAX_M 2020#define INF 0x3f3f3f3fint dist[MAX_N], vis[MAX_N], head[MAX_M], cnt = 0;struct Node&#123; int to, val, next;&#125;edge[MAX_M];void init(int n)&#123; cnt = 0; memset(head, -1, sizeof(head)); memset(vis, 0, sizeof(vis)); for(int i = 0; i&lt;n; i++) &#123; dist[i] = INF; &#125;&#125;void add(int x, int y, int val)&#123; edge[cnt].to = y; edge[cnt].val = val; edge[cnt].next = head[x]; head[x] = cnt++;&#125;void Spfa(int n, int v)&#123; dist[v] = 0; vis[v] = 1; queue&lt;int&gt; S; S.push(v); while(!S.empty()) &#123; int k = S.front(); S.pop(); vis[k] = 0; for(int j = head[k]; j != -1; j = edge[j].next) &#123; int v = edge[j].to; if(dist[v] &gt; edge[j].val + dist[k]) &#123; dist[v] = edge[j].val + dist[k]; if(!vis[v]) &#123; S.push(v); vis[v] = 1; &#125; &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n, m; while(cin &gt;&gt; n &gt;&gt; m) &#123; init(n); for(int i = 0; i&lt;m; i++) &#123; int x, y, val; cin &gt;&gt; x &gt;&gt; y &gt;&gt;val; add(x, y, val); add(y, x, val); &#125; int x, y; cin &gt;&gt; x &gt;&gt; y; Spfa(n, x); dist[y] == INF ? cout &lt;&lt; "-1" &lt;&lt; endl : cout &lt;&lt; dist[y] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞【专题六】 最短路</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ】Cow Contest 闭包传递]]></title>
    <url>%2F2018%2F10%2F20%2F%E6%9C%80%E7%9F%AD%E8%B7%AF-%E9%97%AD%E5%8C%85%E4%BC%A0%E9%80%92POJ-3660%2F</url>
    <content type="text"><![CDATA[题目链接：POJ-3660&lt;/br&gt; 题目描述：N个选手，如果A比B强,B比C强，则A必比C强告知若干个强弱关系，问有多少人的排名可以确定Sample Input5 54 34 23 21 22 5Sample Output2 &lt;/br&gt; 思路floyd算法的基础题；求出所有奶牛的对应关系，如果第i头奶牛可以赢 a 个牛， 且输给 m个牛， 若 n + m == 总奶牛个数-1。则它的排名就是确定的！mat[i][j] = 1表示 第i头奶牛可以赢第j头奶牛mat[i][j] = 0表示，第i头奶牛和第j头奶牛的关系不确定；所以递推关系为 如果 第i头奶牛赢第k头奶牛 ， 第k头奶牛赢第j头奶牛， 则必有第i头奶牛赢第j头奶牛；据此，我们利用floyd算法即可ac此题！ &lt;/br&gt; 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;#define MAX_N 110#define MAX_M 5000int mat[MAX_N][MAX_N], dist_1[MAX_N], dist_2[MAX_N];//dist_1[i] 表示第i头奶牛可以赢得数量 dist_2[i]表示第i头奶牛输的数量void floyd(int n)&#123; for(int k = 1; k&lt;=n; k++) &#123; for(int i = 1; i&lt;=n; i++) &#123; for(int j = 1; j&lt;=n; j++) &#123; if(mat[i][k] &amp;&amp; mat[k][j]) mat[i][j] = 1; &#125; &#125; &#125;&#125;void show(int n)&#123; for(int i = 1; i&lt;=n; i++) &#123; for(int j = 1; j&lt;=n; j++) &#123; cout &lt;&lt; mat[i][j] &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); memset(mat, 0, sizeof(mat)); int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i&lt;=m; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; mat[x][y] = 1; &#125; floyd(n); //show(n); memset(dist_1, 0, sizeof(dist_1)); memset(dist_2, 0, sizeof(dist_2)); for(int i = 1; i&lt;=n; i++) &#123; for(int j = 1; j&lt;=n; j++) &#123; if(mat[i][j]) &#123; dist_1[i]++; dist_2[j]++; &#125; &#125; &#125; int ans = 0; for(int i = 1; i&lt;=n; i++) if(dist_1[i] + dist_2[i] == n-1) ans++; cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞【专题六】 最短路</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【计蒜客】吃辣椒 基础数论]]></title>
    <url>%2F2018%2F10%2F19%2F%E6%95%B0%E8%AE%BA-%E5%90%83%E8%BE%A3%E6%A4%92%2F</url>
    <content type="text"><![CDATA[题目链接：吃辣椒&lt;/br&gt; 题目描述： &lt;/br&gt; 思路容易想到，把辣度值升序后， p[i]取多少次是等于c[i-1][k-1]的 例如:5个取3个 要使每次必取最后一个 得到的就是从2个里取一个，所以不难得出计算式; &lt;/br&gt; 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX_N 100010#define MAX_K 60#define MOD 1000000007#define long long longlong C[MAX_N][MAX_K];long p[MAX_N];void init(int n)&#123; for(int i = 0; i&lt;=n; i++) &#123; C[i][0] = 1; if(i &lt; MAX_K) C[i][i] = 1; for(int j = 1; j&lt;i &amp;&amp; j &lt; MAX_K; j++) &#123; C[i][j] = (C[i-1][j] + C[i-1][j-1] ) % MOD; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n, k; long ans = 0; cin &gt;&gt; n &gt;&gt; k; init(n); for(int i = 1; i&lt;=n; i++) cin &gt;&gt; p[i]; sort(p + 1, p+n+1); for(int i = k; i &lt;= n; i++) &#123; ans += (C[i-1][k-1] * p[i]) % MOD; ans %= MOD; &#125; cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>基础数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【计蒜客】吃辣椒 基础数论]]></title>
    <url>%2F2018%2F10%2F19%2F%E6%95%B0%E8%AE%BA-%E8%92%9C%E5%A4%B4%E5%90%9B%E7%9A%84%E5%A4%9A%E9%A1%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[题目链接：蒜头君的多项式&lt;/br&gt; 题目描述： &lt;/br&gt; 思路题意很好理解，用二项式定理处理出组合数，带入计算即可；注意不要溢出；&lt;/br&gt; 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;#define long long long#define MAX 1010#define MOD 10007long C[MAX][MAX];void init(int n)&#123; C[0][0] = 1; for(int i = 1; i&lt;=n; i++) &#123; C[i][0] = C[i][i] = 1; for(int j = 1; j &lt; i; j++) &#123; C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD; &#125; &#125;&#125;long pow_mod(int n, int m)&#123; long tmp = 1; while(m) &#123; if(m &amp; 1) tmp = ((tmp % MOD) * (n % MOD) ) % MOD; n = ((n%MOD) * (n%MOD) ) % MOD; m &gt;&gt;= 1; &#125; return tmp;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int p, q, k, a, b; cin &gt;&gt; p &gt;&gt; q &gt;&gt; k &gt;&gt; a &gt;&gt; b; init(k); cout &lt;&lt; pow_mod(p, a) % MOD * pow_mod(q, b) % MOD * C[k][b] % MOD; return 0;&#125;]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>基础数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【计蒜客】骑车比赛 堆优化 + Dijkstra]]></title>
    <url>%2F2018%2F10%2F18%2F%E6%9C%80%E7%9F%AD%E8%B7%AF-%E8%AE%A1%E8%92%9C%E5%AE%A2%E9%AA%91%E8%BD%A6%E6%AF%94%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[题目链接：骑车比赛[kuangbin带你飞]专题六最短路&lt;/br&gt; 题目描述： &lt;/br&gt; 思路Dijkstra算法： 裸的最短路问题，求顶点1到顶点n的最短路；用堆优化的Dijkstar可以过； 本题用前向星存了下图，用优先队列模拟实现小根堆；&lt;/br&gt; 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//Hang_cccccc#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX_N 1010#define MAX_M 10010#define INF 0x3f3f3f3fint dist[MAX_N], vis[MAX_N], head[MAX_N], cnt = 0;struct Node&#123; int to, val, next;&#125;edge[MAX_M];struct Min_Heap&#123; int key, val; Min_Heap(int tmp_key, int tmp_val) &#123; key = tmp_key; val = tmp_val; &#125; bool operator &lt; (const Min_Heap &amp;a) const &#123; return a.val &lt; val; &#125;&#125;;void init(int n)&#123; memset(vis, 0, sizeof(vis)); memset(head, -1, sizeof(head)); for(int i = 1; i&lt;=n; i++) dist[i] = INF;&#125;void add(int x, int y, int val)&#123; edge[cnt].to = y; edge[cnt].val =val; edge[cnt].next = head[x]; head[x] = cnt++;&#125;void Dijkstra(int n, int v)&#123; dist[v] = 0; priority_queue&lt;Min_Heap&gt; S; S.push(Min_Heap(v, 0)); while(!S.empty()) &#123; Min_Heap h = S.top(); S.pop(); if(vis[h.key]) continue; vis[h.key] = 1; for(int j = head[h.key]; j != -1; j = edge[j].next) &#123; int k = edge[j].to; if(!vis[k]) &#123; dist[k] = min(dist[k], h.val + edge[j].val); S.push(Min_Heap(k, dist[k])); &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n, m; cin &gt;&gt; n &gt;&gt; m; init(n); for(int i = 1; i&lt;=m; i++) &#123; int x, y, val; cin &gt;&gt; x &gt;&gt; y &gt;&gt; val; add(x, y, val); add(y, x, val); &#125; Dijkstra(n, 1); cout &lt;&lt; dist[n]; return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞【专题六】 最短路</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Frogger POJ-2253]]></title>
    <url>%2F2018%2F10%2F16%2F%E6%9C%80%E7%9F%AD%E8%B7%AFPOJ-2253%2F</url>
    <content type="text"><![CDATA[题目链接：POJ-2253[kuangbin带你飞]专题六最短路&lt;/br&gt; 题目描述：Freddy Frog is sitting on a stone in the middle of a lake. Suddenly he notices Fiona Frog who is sitting on another stone. He plans to visit her, but since the water is dirty and full of tourists’ sunscreen, he wants to avoid swimming and instead reach her by jumping.Unfortunately Fiona’s stone is out of his jump range. Therefore Freddy considers to use other stones as intermediate stops and reach her by a sequence of several small jumps.To execute a given sequence of jumps, a frog’s jump range obviously must be at least as long as the longest jump occuring in the sequence.The frog distance (humans also call it minimax distance) between two stones therefore is defined as the minimum necessary jump range over all possible paths between the two stones. You are given the coordinates of Freddy’s stone, Fiona’s stone and all other stones in the lake. Your job is to compute the frog distance between Freddy’s and Fiona’s stone. &lt;/br&gt; 思路Dijkstra算法： 复制一下别人的题意，有两只青蛙和若干块石头，现在已知这些东西的坐标，两只青蛙A坐标和青蛙B坐标是第一个和第二个坐标，现在A青蛙想要到B青蛙那里去，并且A青蛙可以借助任意石头的跳跃，而从A到B有若干通路，问从A到B的所有通路上的最大边，比如有 有两条通路 1(4)5 (3）2 代表1到5之间的边为4, 5到2之间的边为3，那么该条通路跳跃范围（两块石头之间的最大距离）为 4， 另一条通路 1(6) 4(1) 2 ，该条通路的跳跃范围为6， 两条通路的跳跃范围分别是 4 ，6，我们要求的就是最小的那一个跳跃范围，即4, &lt;/br&gt; 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iomanip&gt;using namespace std;#define MAX 210#define INF 0x3f3f3f3fint x[MAX], y[MAX], vis[MAX];double mat[MAX][MAX], dist[MAX];void init(int n)&#123; memset(vis, 0, sizeof(vis)); for(int i = 1; i&lt;=n; i++) &#123; for(int j = 1; j&lt;=n; j++) mat[i][j] = INF; dist[i] = INF; &#125;&#125;void Dijkstra(int n, int v)&#123; dist[v] = 0; for(int i = 1; i&lt;=n; i++) &#123; int min_vertex; double min_dist = INF; for(int j = 1; j&lt;=n; j++) &#123; if(!vis[j] &amp;&amp; dist[j] &lt; min_dist) &#123; min_dist = dist[j]; min_vertex = j; &#125; &#125; vis[min_vertex] = 1; for(int j = 1; j&lt;=n; j++) &#123; if(!vis[j]) dist[j] = min(dist[j], max(min_dist , mat[min_vertex][j])); &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n, t = 0; while(cin &gt;&gt; n, n) &#123; t++; init(n); for(int i = 1; i&lt;=n; i++)//录入顶点坐标 &#123; cin &gt;&gt; x[i] &gt;&gt; y[i]; &#125; for(int i = 1; i&lt;=n; i++) &#123; for(int j = i; j&lt;=n; j++) &#123; mat[i][j] = mat[j][i] = sqrt(pow(x[i]-x[j],2) + pow(y[i]-y[j], 2)); //cout &lt;&lt; "i = " &lt;&lt; i &lt;&lt; "j = " &lt;&lt; j &lt;&lt; " mat[i][j] = " &lt;&lt; mat[i][j] &lt;&lt; endl; &#125; &#125; Dijkstra(n, 1); cout &lt;&lt; "Scenario #" &lt;&lt; t &lt;&lt; endl; cout &lt;&lt; "Frog Distance = " &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; dist[2] &lt;&lt; endl &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞【专题六】 最短路</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【模板】单源最短路径（弱化版） 洛谷P3371]]></title>
    <url>%2F2018%2F10%2F15%2F%E6%B4%9B%E8%B0%B7%E6%9C%80%E7%9F%AD%E8%B7%AFP3371-%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%2F</url>
    <content type="text"><![CDATA[题目链接：洛谷P3371[kuangbin带你飞]专题六最短路&lt;/br&gt; 题目描述：题目描述如题，给出一个有向图，请输出从某一点出发到所有点的最短路径长度。 输入输出格式输入格式：第一行包含三个整数N、M、S，分别表示点的个数、有向边的个数、出发点的编号。 接下来M行每行包含三个整数Fi、Gi、Wi，分别表示第i条有向边的出发点、目标点和长度。 输出格式：一行，包含N个用空格分隔的整数，其中第i个整数表示从点S出发到点i的最短路径长度（若S=i则最短路径长度为0，若从点S无法到达点i，则最短路径长度为2147483647） &lt;/br&gt; 思路Dijkstra算法： Dijkstra算法和Prim算法的思想类似都是贪心的思想，不断加入最短的边，直到联通所有的顶点即可； 该题如果直接利用Dijkstar会超内存。即如果利用邻接矩阵存图的话，需要存储10000 * 10000 个对应关系，这使得我们必须优化内存来通过此题； 再此题中，我选择应用链式前向星来存图，可以节省内存开销；链式前向星存图学习：大佬的链式前向星 图文并茂的建议大家手绘一下，模拟整个存图过程的实现，易于理解； 我的理解是：邻接矩阵是存储顶点到顶点的关系，这就有许多没用的关系也进行了存储；而链式前向星是用来存储边的集合，所以大家可以依据题目要求选择适当的结构来存储； 链式前向星可以自己过滤掉重边，因为他在寻找i为起点的所有路径，自然会选择最短的；（事实上，它也存储了那些权值较大的边，只是在Dijkstra算法的过程中，会选择权值最小的边） &lt;/br&gt; 代码 未使用前向星（只过了70%的数据）:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;#define MAX 10010#define INF 0x3f3f3f3fint mat[MAX][MAX], vis[MAX], dist[MAX];void init(int n)&#123; memset(vis, 0, sizeof(vis)); for(int i = 1; i&lt;=n; i++) &#123; for(int j = 1; j&lt;=n; j++) mat[i][j] = INF; dist[i] = INF; &#125;&#125;void Union(int x, int y, int val)&#123; if(val &lt; mat[x][y]) mat[x][y] = val;&#125;void Dijkstra(int n, int v)&#123; dist[v] = 0; for(int i = 0; i&lt;n; i++) &#123; int min_vertex, min_dist = INF; for(int j = 1; j&lt;=n; j++) &#123; if(!vis[j] &amp;&amp; dist[j] &lt; min_dist) &#123; min_dist = dist[j]; min_vertex = j; &#125; &#125; vis[min_vertex] = 1; for(int j = 1; j&lt;=n; j++) &#123; if(!vis[j] &amp;&amp; mat[min_vertex][j] + min_dist &lt; dist[j]) &#123; dist[j] = mat[min_vertex][j] + min_dist; &#125; &#125; &#125;&#125;int main()&#123; int n, m, v; cin &gt;&gt; n &gt;&gt; m &gt;&gt; v; init(n); for(int i = 0; i&lt;m; i++) &#123; int x, y, val; cin &gt;&gt; x &gt;&gt; y &gt;&gt; val; Union(x, y, val); &#125; Dijkstra(n, v); for(int i = 1; i&lt;=n; i++) &#123; if(dist[i] == INF) cout &lt;&lt; "2147483647"; else cout &lt;&lt; dist[i]; if(i != n) cout &lt;&lt; " "; &#125; return 0;&#125; 链式前向星优化内存的Dijkstra,可以AC; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;#define MAXN 500050//边的个数#define MAX 10010//顶点的个数#define INF 0x3f3f3f3fstruct Node&#123; int to;//代表当前边的终点 int next;//代表下一个与当前同起点的下标 int val;//代表当前起点到当前点的权值&#125;edge[MAXN];int cnt = 0, vis[MAX], dist[MAX], head[MAXN];inline void init(int n)&#123; memset(head, -1, sizeof(head)); memset(vis, 0, sizeof(vis)); for(int i = 1; i&lt;=n; i++) &#123; dist[i] = INF; &#125;&#125;inline void add(int x, int v, int val)&#123; edge[cnt].val = val; edge[cnt].to = v; edge[cnt].next = head[x]; head[x] = cnt++;&#125;void Dijkstra(int n, int v)&#123; dist[v] = 0; for(int i = 1; i&lt;=n; i++) &#123; int min_vertex, min_dist = INF; for(int j = 1; j&lt;=n; j++) &#123; if(!vis[j] &amp;&amp; min_dist &gt; dist[j]) &#123; min_dist = dist[j]; min_vertex = j; &#125; &#125; vis[min_vertex] = 1; for(int j = head[min_vertex], k = edge[j].to; j != -1; j = edge[j].next, k = edge[j].to) &#123; if(!vis[k] &amp;&amp; edge[j].val + min_dist &lt; dist[k]) &#123; dist[k] = edge[j].val + min_dist; &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n, m, t; cin &gt;&gt; n &gt;&gt; m &gt;&gt; t; init(n); for(int i = 0; i&lt;m; i++) &#123; int x, y, val; cin &gt;&gt; x &gt;&gt; y &gt;&gt; val; add(x, y, val); &#125; Dijkstra(n, t); for(int i = 1; i&lt;=n; i++) &#123; dist[i] == INF ? cout &lt;&lt; "2147483647" : cout &lt;&lt; dist[i]; if(i != n) cout &lt;&lt; " "; &#125; return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞【专题六】 最短路</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Til the Cows Come Home POJ-2387【最短路】]]></title>
    <url>%2F2018%2F10%2F14%2F%E6%9C%80%E7%9F%AD%E8%B7%AFPOJ-2387%2F</url>
    <content type="text"><![CDATA[题目链接：POJ-2387[kuangbin带你飞]专题六最短路&lt;/br&gt; 题目描述：给定的无向图有n个顶点，m条边；求出从顶点1到顶点m的最短路径；Bessie is out in the field and wants to get back to the barn to get as much sleep as possible before Farmer John wakes her for the morning milking. Bessie needs her beauty sleep, so she wants to get back as quickly as possible. Farmer John’s field has N (2 &lt;= N &lt;= 1000) landmarks in it, uniquely numbered 1..N. Landmark 1 is the barn; the apple tree grove in which Bessie stands all day is landmark N. Cows travel in the field using T (1 &lt;= T &lt;= 2000) bidirectional cow-trails of various lengths between the landmarks. Bessie is not confident of her navigation ability, so she always stays on a trail from its start to its end once she starts it. Given the trails between the landmarks, determine the minimum distance Bessie must walk to get back to the barn. It is guaranteed that some such route exists. &lt;/br&gt; 思路Prim算法： 裸的Dijkstra算法数据范围小，不需要优化内存及算法就可以ac&lt;/br&gt; 代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;#define MAX 2010#define INF 0x3f3f3f3fint mat[MAX][MAX], vis[MAX], dist[MAX];void init(int n)&#123; memset(vis, 0, sizeof(vis)); for(int i = 1; i&lt;=n; i++) &#123; for(int j = 1; j&lt;=n; j++) mat[i][j] = INF; dist[i] = INF; &#125;&#125;void Union(int x, int y, int val)&#123; if(val &lt; mat[x][y]) mat[x][y] = mat[y][x] = val;&#125;void Dijkstra(int n)&#123; dist[1] = 0; for(int i = 0; i&lt;n; i++) &#123; int min_vertex, min_dist = INF; for(int j = 1; j&lt;=n; j++) &#123; if(!vis[j] &amp;&amp; dist[j] &lt; min_dist) &#123; min_dist = dist[j]; min_vertex = j; &#125; &#125; vis[min_vertex] = 1; for(int j = 1; j&lt;=n; j++) &#123; if(!vis[j] &amp;&amp; mat[min_vertex][j] + min_dist &lt; dist[j]) &#123; dist[j] = mat[min_vertex][j] + min_dist; &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n, m; while(cin &gt;&gt; n &gt;&gt; m) &#123; init(m); for(int i = 0; i&lt;n; i++) &#123; int x, y, val; cin &gt;&gt; x &gt;&gt; y &gt;&gt; val; Union(x, y, val); &#125; Dijkstra(m); cout &lt;&lt; dist[m] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞【专题六】 最短路</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[畅通工程续 HDU-1874【最短路】]]></title>
    <url>%2F2018%2F10%2F14%2F%E6%9C%80%E7%9F%AD%E8%B7%AFHDU-1874%2F</url>
    <content type="text"><![CDATA[题目链接：HDU-1874[kuangbin带你飞]专题六最短路&lt;/br&gt; 题目描述：某省自从实行了很多年的畅通工程计划后，终于修建了很多路。不过路多了也不好，每次要从一个城镇到另一个城镇时，都有许多种道路方案可以选择，而某些方案要比另一些方案行走的距离要短很多。这让行人很困扰。现在，已知起点和终点，请你计算出要从起点到终点，最短需要行走多少距离。 &lt;/br&gt; 思路Prim算法： 裸的Dijkstra算法数据范围小，不需要优化内存及算法就可以ac &lt;/br&gt; 代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX 210#define INF 0x3f3f3f3fint dist[MAX], mat[MAX][MAX], vis[MAX];void init(int n)&#123; memset(vis, 0, sizeof(vis)); for(int i = 0; i&lt;n; i++) &#123; for(int j = 0; j&lt;n; j++) mat[i][j] = INF; dist[i] = INF; &#125;&#125;void Union(int x, int y, int val)&#123; if(val &lt; mat[x][y]) &#123; mat[x][y] = mat[y][x] = val; &#125;&#125;void Dijkstra(int n, int v)&#123; dist[v] = 0; for(int i = 0; i&lt;n; i++) &#123; int min_vertex, min_dist = INF; for(int j = 0; j&lt;n; j++) &#123; if(!vis[j] &amp;&amp; dist[j] &lt; min_dist) &#123; min_dist = dist[j]; min_vertex = j; &#125; &#125; vis[min_vertex] = 1; for(int j = 0; j&lt;n; j++) &#123; if(!vis[j] &amp;&amp; mat[min_vertex][j] + min_dist &lt; dist[j]) &#123; dist[j] = mat[min_vertex][j] + min_dist; &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n, m; while(cin &gt;&gt; n &gt;&gt; m) &#123; init(n); for(int i = 0; i&lt;m; i++) &#123; int x, y, val; cin &gt;&gt; x &gt;&gt; y &gt;&gt; val; Union(x, y, val); &#125; int star, End; cin &gt;&gt; star &gt;&gt; End; Dijkstra(n, star); dist[End] == INF ? cout &lt;&lt; -1 &lt;&lt; endl : cout &lt;&lt; dist[End] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞【专题六】 最短路</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jungle Roads POJ-1251【最小生成树】]]></title>
    <url>%2F2018%2F10%2F11%2F%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91POJ-1251%2F</url>
    <content type="text"><![CDATA[题目链接：POJ-1251[kuangbin带你飞]专题六最小生成树&lt;/br&gt; 题目描述：The Head Elder of the tropical island of Lagrishan has a problem. A burst of foreign aid money was spent on extra roads between villages some years ago. But the jungle overtakes roads relentlessly, so the large road network is too expensive to maintain. The Council of Elders must choose to stop maintaining some roads. The map above on the left shows all the roads in use now and the cost in aacms per month to maintain them. Of course there needs to be some way to get between all the villages on maintained roads, even if the route is not as short as before. The Chief Elder would like to tell the Council of Elders what would be the smallest amount they could spend in aacms per month to maintain roads that would connect all the villages. The villages are labeled A through I in the maps above. The map on the right shows the roads that could be maintained most cheaply, for 216 aacms per month. Your task is to write a program that will solve such problems. &lt;/br&gt; 思路Prim算法： Prim算法就是定义mat用来存图，dist数组用来存每个点到最小生成树的最短距离，vis数组标记此点是否已经在最小生成树中了（防止出现环）。 实际操作就是先随便把一个点加入到生成树里（一般是第一个点），然后寻找与该点距离最短的点并加入，然后在寻找与1,2点相连最短的点，并加入到生成树中，就这样不断的加下去，直到加入的点数与原图一致终止； 可以自己手动模仿一下过程，其实还是好理解的！ 裸的最小生成树，直接做即可 易错点1.每次加入前确保加入的权值比之前加入的权值要小，否则不加入； 如 第一次 给出 1-2边的权值为3， 然后某次加边操作说 1-2边权值为10， 这时候我们保留第一次的权值（保留权值较小的那次） &lt;/br&gt; 代码:Prim算法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;#define MAX 256#define INF 0x3f3f3f3fint mat[MAX][MAX], dist[MAX], vis[MAX];void init(int n)&#123; memset(vis, 0, sizeof(vis)); for(int i = 0; i&lt;n; i++) &#123; for(int j = 0; j&lt;n; j++) mat[i][j] = INF; dist[i] = INF; &#125;&#125;void Union(int x, int y, int val)&#123; if(val &lt; mat[x][y]) &#123; mat[x][y] = mat[y][x] = val; &#125;&#125;int Prim(int n)&#123; int sum = 0; dist[0] = 0; for(int i = 0; i&lt;n; i++) &#123; int min_dist = INF, min_vertex; for(int j = 0; j&lt;n; j++) &#123; if(!vis[j] &amp;&amp; dist[j] &lt; min_dist) &#123; min_dist = dist[j]; min_vertex = j; &#125; &#125; vis[min_vertex] = 1; sum += min_dist; for(int j = 0; j&lt;n; j++) &#123; if(!vis[j] &amp;&amp; mat[min_vertex][j] &lt; dist[j]) &#123; dist[j] = mat[min_vertex][j]; &#125; &#125; &#125; return sum;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n; while(cin &gt;&gt; n, n) &#123; init(n); for(int i = 0; i&lt;n-1; i++) &#123; char tmp; int m; cin &gt;&gt; tmp &gt;&gt; m; for(int j = 0; j &lt; m; j++) &#123; char key; int val; cin &gt;&gt; key &gt;&gt; val; Union(tmp - 'A', key - 'A', val); &#125; &#125; cout &lt;&lt; Prim(n) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞【专题六】 最小生成树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[畅通工程再续 HDU-1875【最小生成树】]]></title>
    <url>%2F2018%2F10%2F10%2F%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91HDU-1875%2F</url>
    <content type="text"><![CDATA[题目链接：HDU-1875[kuangbin带你飞]专题六最小生成树&lt;/br&gt; 题目描述：相信大家都听说一个“百岛湖”的地方吧，百岛湖的居民生活在不同的小岛中，当他们想去其他的小岛时都要通过划小船来实现。现在政府决定大力发展百岛湖，发展首先要解决的问题当然是交通问题，政府决定实现百岛湖的全畅通！经过考察小组RPRush对百岛湖的情况充分了解后，决定在符合条件的小岛间建上桥，所谓符合条件，就是2个小岛之间的距离不能小于10米，也不能大于1000米。当然，为了节省资金，只要求实现任意2个小岛之间有路通即可。其中桥的价格为 100元/米。 &lt;/br&gt; 思路Prim算法： Prim算法就是定义mat用来存图，dist数组用来存每个点到最小生成树的最短距离，vis数组标记此点是否已经在最小生成树中了（防止出现环）。 实际操作就是先随便把一个点加入到生成树里（一般是第一个点），然后寻找与该点距离最短的点并加入，然后在寻找与1,2点相连最短的点，并加入到生成树中，就这样不断的加下去，直到加入的点数与原图一致终止； 可以自己手动模仿一下过程，其实还是好理解的！ 先存储所有的点，然后进行判断，当满足 &lt; 10 &gt; 1000的情况下进行Union,否则赋值为INF， 然后运用Prim算法，当某一步的距离最小生成树的最近点的权值为INF时，则其不连通，输出“oh!” 然后return即可， 如果把所有的点都加入了最小生成树，则输出其最小花费即可; 易错点1.每次加入前确保加入的权值比之前加入的权值要小，否则不加入； 如 第一次 给出 1-2边的权值为3， 然后某次加边操作说 1-2边权值为10， 这时候我们保留第一次的权值（保留权值较小的那次） 2.dist数组定义为double，算出来的权值需要乘以100； &lt;/br&gt; 代码:Prim算法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX 110#define INF 0x3f3f3f3fstruct Node&#123; double x, y;&#125;S[5050];double mat[MAX][MAX], dist[MAX];int vis[MAX];void init(int n)&#123; for(int i = 0; i&lt;n; i++) &#123; for(int j = 0; j&lt;n; j++) &#123; mat[i][j] = INF; &#125; dist[i] = INF; &#125;&#125;void Union(int x, int y, double val)&#123; if(val &lt; mat[x][y]) mat[x][y] = mat[y][x] = val;&#125;void Prim(int n)&#123; double sum = 0; dist[0] = 0; for(int i = 0; i&lt;n; i++) &#123; double min_dist = INF; int min_vertex; for(int j = 0; j &lt; n; j++) &#123; if(!vis[j] &amp;&amp; dist[j] &lt; min_dist) &#123; min_dist = dist[j]; min_vertex = j; &#125; &#125; if(min_dist == INF) &#123; cout &lt;&lt; "oh!" &lt;&lt; endl; return ; &#125; vis[min_vertex] = 1; sum += min_dist; for(int j = 0; j &lt; n; j++) &#123; if(!vis[j] &amp;&amp; mat[min_vertex][j] &lt; dist[j]) &#123; dist[j] = mat[min_vertex][j]; &#125; &#125; &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; sum * 100 &lt;&lt; endl;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int T; cin &gt;&gt; T; while(T--) &#123; int n; cin &gt;&gt; n; init(n); memset(vis, 0, sizeof(vis)); for(int i = 0; i&lt;n; i++) &#123; cin &gt;&gt; S[i].x &gt;&gt; S[i].y; &#125; for(int i = 0; i&lt;n-1; i++) &#123; for(int j = i + 1; j &lt; n; j++) &#123; double d = pow(S[i].x - S[j].x, 2) + pow(S[i].y - S[j].y, 2); if(d &lt; 100 || d &gt; 1000000) &#123; mat[i][j] = mat[j][i] = INF; &#125; else &#123; Union(i, j, sqrt(d)); &#125; &#125; &#125; Prim(n); &#125; return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞【专题六】 最小生成树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继续畅通工程 HDU-1879【最小生成树】]]></title>
    <url>%2F2018%2F10%2F10%2F%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91HDU-1879%2F</url>
    <content type="text"><![CDATA[题目链接：HDU-1879[kuangbin带你飞]专题六最小生成树&lt;/br&gt; 题目描述：省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可）。现得到城镇道路统计表，表中列出了任意两城镇间修建道路的费用，以及该道路是否已经修通的状态。现请你编写程序，计算出全省畅通需要的最低成本。 &lt;/br&gt; 思路最小生成树裸题，当道路已经建立过，则其权值赋为0即可；Prim算法： 不断寻找距离最小生成树最近的顶点，直到加入最小生成树的点数等于顶点数终止;Kruskal算法： 从权值最小的边开始加，当顶点已经添加过则跳过，直到加入的边数等于顶点数-1终止； 易错点1.每次加入前确保加入的权值比之前加入的权值要小，否则不加入（防止重边）； 如 第一次 给出 1-2边的权值为3， 然后某次加边操作说 1-2边权值为10， 这时候我们保留第一次的权值（保留权值较小的那次） 2.**使用克鲁斯卡尔算法要注意，当加入的边 = 顶点数-1 时 可以直接返回最小生成树的权值， 但 一定要注意吗即使 边 ！= 顶点数 - 1 也不一定是不连通的， 当n = 1 时 一定要返回 0， 否则会wa的很惨！！！** 3.使用克鲁斯卡尔算法时， 建立并查集一定得按着题意的下标进行初始化， 如1-N编号，或者0 - N-1编号之类的， 或者全局都初始化，否则wa的很惨！！！ &lt;/br&gt; 代码:Prim算法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX 110#define INF 0x3f3f3f3fint mat[MAX][MAX], dist[MAX], vis[MAX];void init(int n)&#123; for(int i = 1; i&lt;=n; i++) &#123; for(int j = 1; j&lt;=n; j++) mat[i][j] = INF; dist[i] = INF; &#125;&#125;void Union(int x, int y, int val)&#123; if(val &lt; mat[x][y]) &#123; mat[x][y] = mat[y][x] = val; &#125;&#125;int Prim(int n)&#123; int sum = 0; dist[1] = 0; for(int i = 0; i&lt;n; i++) &#123; int min_dist = INF, min_vertex; for(int j = 1; j&lt;=n; j++) &#123; if(!vis[j] &amp;&amp; dist[j] &lt; min_dist) &#123; min_dist = dist[j]; min_vertex = j; &#125; &#125; vis[min_vertex] = 1; sum += min_dist; for(int j = 1; j &lt;= n; j++) &#123; if(!vis[j] &amp;&amp; mat[min_vertex][j] &lt; dist[j]) &#123; dist[j] = mat[min_vertex][j]; &#125; &#125; &#125; return sum;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n, m; while(cin &gt;&gt; n, n) &#123; memset(vis, 0, sizeof(vis)); init(n); m = n * (n-1) / 2; for(int i = 0; i&lt;m; i++) &#123; int x, y ,val, tmp; cin &gt;&gt; x &gt;&gt; y &gt;&gt; val &gt;&gt; tmp; if(tmp)//已经建立 &#123; Union(x, y, 0); &#125; else &#123; Union(x, y, val); &#125; &#125; cout &lt;&lt; Prim(n) &lt;&lt; endl; &#125; return 0;&#125; Kruskal算法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;int pre[110];struct Node&#123; int x, y, val;&#125;S[5050];bool cmp(const Node &amp;a, const Node &amp;b)&#123; return a.val &lt; b.val;&#125;void init(int n)&#123; for(int i = 1; i &lt;= n; i++) pre[i] = i;&#125;int Find(int x)&#123; return x == pre[x] ? x : pre[x] = Find(pre[x]);&#125;int Kruskal(int n, int m)&#123; int sum = 0, ans = 0; sort(S, S+m, cmp); for(int i = 0; i&lt;m; i++) &#123; int x = Find(S[i].x); int y = Find(S[i].y); if(x != y) &#123; sum += S[i].val; ans++; pre[x] = y; &#125; &#125; return sum;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int m, n; while(cin &gt;&gt; n, n) &#123; m = n * (n - 1) / 2; init(n); for(int i = 0; i&lt;m; i++) &#123; int tmp; cin &gt;&gt; S[i].x &gt;&gt; S[i].y &gt;&gt; S[i].val &gt;&gt; tmp; if(tmp == 1) S[i].val = 0; &#125; cout &lt;&lt; Kruskal(n, m) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞【专题六】 最小生成树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[还是畅通工程 POJ-1233【最小生成树】]]></title>
    <url>%2F2018%2F10%2F10%2F%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91HDU-1233%2F</url>
    <content type="text"><![CDATA[题目链接：HDU-1233[kuangbin带你飞]专题六最小生成树&lt;/br&gt; 题目描述：某省调查乡村交通状况，得到的统计表中列出了任意两村庄间的距离。省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可），并要求铺设的公路总长度为最小。请计算最小的公路总长度。 &lt;/br&gt; 思路Prim算法： 不断寻找距离最小生成树最近的顶点，直到加入最小生成树的点数等于顶点数终止;Kruskal算法： 从权值最小的边开始加，当顶点已经添加过则跳过，直到加入的边数等于顶点数-1终止； 易错点1.每次加入前确保加入的权值比之前加入的权值要小，否则不加入（防止重边）； 如 第一次 给出 1-2边的权值为3， 然后某次加边操作说 1-2边权值为10， 这时候我们保留第一次的权值（保留权值较小的那次） 2.**使用克鲁斯卡尔算法要注意，当加入的边 = 顶点数-1 时 可以直接返回最小生成树的权值， 但 一定要注意吗即使 边 ！= 顶点数 - 1 也不一定是不连通的， 当n = 1 时 一定要返回 0， 否则会wa的很惨！！！** &lt;/br&gt; 代码:Prim算法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX 110#define INF 0x3f3f3f3fint mat[MAX][MAX], vis[MAX], dist[MAX];void init(int n)&#123; for(int i = 1; i&lt;=n; i++) &#123; for(int j = 1; j&lt;=n; j++) &#123; mat[i][j] =INF; &#125; dist[i] = INF; &#125;&#125;void Union(int x, int y, int val)&#123; if(val &lt; mat[x][y]) &#123; mat[x][y] = mat[y][x] = val; &#125;&#125;int Prim(int n)&#123; int sum = 0, k; dist[1] = 0; for(int i = 0; i&lt;n; i++) &#123; int min_vertex, min_dist = INF; for(int j = 1; j&lt;=n; j++) &#123; if(!vis[j] &amp;&amp; min_dist &gt; dist[j]) &#123; min_dist = dist[j]; min_vertex = j; &#125; &#125; vis[min_vertex] = 1; sum += min_dist; for(int j = 1; j&lt;=n; j++) &#123; if(!vis[j] &amp;&amp; mat[min_vertex][j] &lt; dist[j]) &#123; dist[j] = mat[min_vertex][j]; &#125; &#125; &#125; return sum;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n; while(cin &gt;&gt; n, n) &#123; init(n); memset(vis, 0, sizeof(vis)); int m = n * (n-1) / 2; for(int i = 0; i&lt;m; i++) &#123; int x, y, val; cin &gt;&gt; x &gt;&gt; y &gt;&gt; val; Union(x, y, val); &#125; cout &lt;&lt; Prim(n) &lt;&lt; endl; &#125; return 0;&#125; Kruskal算法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX 110int pre[MAX];struct Node&#123; int x, y, val;&#125;S[5050];bool cmp(const Node &amp;a, const Node &amp;b)&#123; return a.val &lt; b.val;&#125;void init(int n)&#123; for(int i = 1; i&lt;=n; i++) pre[i] = i;&#125;int Find(int x)&#123; return x == pre[x] ? x : pre[x] = Find(pre[x]);&#125;int Kruskal(int n, int m)&#123; sort(S+1, S+m+1, cmp); int sum = 0, ans = 0; for(int i = 1; i&lt;=m; i++) &#123; int x = Find(S[i].x); int y = Find(S[i].y); if(x != y) &#123; pre[x] = y; sum += S[i].val; ans++; &#125; if(ans == n-1) return sum; &#125; return sum;&#125;int main()&#123; int n; while(cin &gt;&gt; n, n) &#123; init(n); int m = n * (n-1) / 2; for(int i = 1; i&lt;=m; i++) &#123; cin &gt;&gt; S[i].x &gt;&gt; S[i].y &gt;&gt; S[i].val; &#125; cout &lt;&lt; Kruskal(n, m) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞【专题六】 最小生成树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Networking POJ-1287【最小生成树】]]></title>
    <url>%2F2018%2F10%2F09%2F%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91POJ-1287%2F</url>
    <content type="text"><![CDATA[题目链接：POJ-1287[kuangbin带你飞]专题六最小生成树&lt;/br&gt; 题目描述：您被分配设计广泛区域中某些点之间的网络连接。您将获得该区域中的一组点，以及可连接成对点的电缆的一组可能路线。对于两点之间的每条可能路线，您将获得连接该路线上的点所需的电缆长度。请注意，在两个给定点之间可能存在许多可能的路径。假设给定的可能路线（直接或间接）连接该区域中的每两个点。您的任务是为该区域设计网络，以便在每两个点之间存在连接（直接或间接）（即，所有点都是互连的，但不一定是通过直接电缆），并且总长度为用过的电缆很少。 &lt;/br&gt; 思路Prim算法： Prim算法就是定义mat用来存图，dist数组用来存每个点到最小生成树的最短距离，vis数组标记此点是否已经在最小生成树中了（防止出现环）。 实际操作就是先随便把一个点加入到生成树里（一般是第一个点），然后寻找与该点距离最短的点并加入，然后在寻找与1,2点相连最短的点，并加入到生成树中，就这样不断的加下去，直到加入的点数与原图一致终止； 可以自己手动模仿一下过程，其实还是好理解的！ 易错点1.每次加入前确保加入的权值比之前加入的权值要小，否则不加入； 如 第一次 给出 1-2边的权值为3， 然后某次加边操作说 1-2边权值为10， 这时候我们保留第一次的权值（保留权值较小的那次） 2.题意说是边可能无限，那么大概不能用Kruskal算法来做；Prim算法用来存顶点，而Kruskal算法用来存边，当边很多或者不确定是，我们可能无法用Kruskal算法来做（当然，现在2018年10月9日16:39:24可能还是不能做的，以后说不定也可以做） &lt;/br&gt; 代码:Prim算法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;#define MAX 5050#define INF 0x3f3f3f3fint mat[MAX][MAX], vis[MAX], dist[MAX];void init(int n)&#123; for(int i = 1; i&lt;=n; i++) &#123; for(int j = 1; j&lt;=n; j++) &#123; mat[i][j] = INF; &#125; dist[i] = INF; &#125;&#125;void Union(int x, int y, int val)&#123; if(val &lt; mat[x][y]) &#123; mat[x][y] = mat[y][x] = val; &#125;&#125;int Prim(int n)&#123; int sum = 0; dist[1] = 0; for(int i = 1; i&lt;=n; i++) &#123; int min_dist = INF, min_vertex; for(int j = 1; j&lt;=n; j++) &#123; if(!vis[j] &amp;&amp; dist[j] &lt; min_dist) &#123; min_dist = dist[j]; min_vertex = j; &#125; &#125; vis[min_vertex] = 1; sum += min_dist; for(int j = 1; j&lt;=n; j++) &#123; if(!vis[j] &amp;&amp; mat[min_vertex][j] &lt; dist[j]) &#123; dist[j] = mat[min_vertex][j]; &#125; &#125; &#125; return sum;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n, m; while(cin &gt;&gt; n, n != 0) &#123; cin &gt;&gt; m; init(n); memset(vis, 0, sizeof(vis)); for(int i = 0; i&lt;m; i++) &#123; int x, y, val; cin &gt;&gt; x &gt;&gt; y &gt;&gt; val; Union(x, y, val); &#125; cout &lt;&lt; Prim(n) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞【专题六】 最小生成树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷-P3366 最小生成树]]></title>
    <url>%2F2018%2F10%2F09%2F%E6%B4%9B%E8%B0%B7-P3366%2F</url>
    <content type="text"><![CDATA[题目链接：洛谷-P3366&lt;/br&gt; 题目描述：如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出orz 输入输出格式输入格式：第一行包含两个整数N、M，表示该图共有N个结点和M条无向边。（N&lt;=5000，M&lt;=200000） 接下来M行每行包含三个整数Xi、Yi、Zi，表示有一条长度为Zi的无向边连接结点Xi、Yi 输出格式：输出包含一个数，即最小生成树的各边的长度之和；如果该图不连通则输出orz &lt;/br&gt; 思路Prim算法： Prim算法就是定义mat用来存图，dist数组用来存每个点到最小生成树的最短距离，vis数组标记此点是否已经在最小生成树中了（防止出现环）。 实际操作就是先随便把一个点加入到生成树里（一般是第一个点），然后寻找与该点距离最短的点并加入，然后在寻找与1,2点相连最短的点，并加入到生成树中，就这样不断的加下去，直到加入的点数与原图一致终止； 可以自己手动模仿一下过程，其实还是好理解的！Kruskal算法： 对边进行排序，依次加边，加边时需要判断是否在同一棵树，在同一颗树加边会产生环,如何判断是否在同一棵树？这里我们用到并查集，当当前边的左右端点不在同一棵树则可以进行合并，当加入的点数和给出的顶点数一致时就跳出循环，范围最小生成树的值，如果遍历完后还是不够给定的定点数，则其无法构成生成树！ 易错点1.每次加入前确保加入的权值比之前加入的权值要小，否则不加入； 如 第一次 给出 1-2边的权值为3， 然后某次加边操作说 1-2边权值为10， 这时候我们保留第一次的权值（保留权值较小的那次） 2.一般Prim适用于稠密图，用邻接矩阵存顶点； 3.Prim算法是存储顶点，Kruskal算法是存储边，注意给出的数据范围进行存储； &lt;/br&gt; 代码:Prim算法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3fint n, m, dist[5010], mat[5010][5010];bool vis[5010];void init(int k)&#123; for(int i = 1; i&lt;=k; i++) &#123; for(int j = 1; j&lt;=k; j++) &#123; mat[i][j] = INF; &#125; dist[i] = INF; &#125;&#125;void Union(int x, int y, int val)&#123; if(val &lt; mat[x][y]) &#123; mat[x][y] = mat[y][x] = val; &#125;&#125;int Prim()&#123; int sum = 0; dist[1] = 0; for(int i = 1; i&lt;=n; i++) &#123; int min_dist = INF, min_vertex; for(int j = 1; j &lt;= n; j++) &#123; if(!vis[j] &amp;&amp; min_dist &gt; dist[j]) &#123; min_dist = dist[j]; min_vertex = j; &#125; &#125; vis[min_vertex] = 1; sum += min_dist; for(int j = 1; j &lt;= n; j++) &#123; if(!vis[j] &amp;&amp; mat[min_vertex][j] &lt; dist[j]) &#123; dist[j] = mat[min_vertex][j]; &#125; &#125; &#125; return sum;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; n &gt;&gt; m; init(n); memset(vis, 0, sizeof(vis)); for(int i = 0; i&lt;m; i++) &#123; int x, y, val; cin &gt;&gt; x &gt;&gt; y &gt;&gt; val; Union(x, y, val); &#125; cout &lt;&lt; Prim() &lt;&lt; endl; return 0;&#125; Kruskal算法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX 200100struct Node&#123; int x, y, val;&#125;S[MAX];int pre[MAX];bool cmp(Node a, Node b)&#123; return a.val &lt; b.val;&#125;void init(int k)&#123; for(int i = 0; i&lt;k; i++) pre[i] = i;&#125;int Find(int x)&#123; int r = x; while(r != pre[r]) &#123; r = pre[r]; &#125; int i = x, j; while(i != r) &#123; j =pre[i]; pre[i] = r; i = j; &#125; return r;&#125;int Kruskal(int n, int m)&#123; int sum = 0, ans = 0; for(int i = 0; i&lt;m; i++) &#123; int x = Find(S[i].x); int y = Find(S[i].y); if(x != y) &#123; sum += S[i].val; pre[x] = y; ans++; &#125; if(ans == n) return sum; &#125; return sum;&#125;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; init(n); for(int i = 0; i&lt;m; i++) &#123; cin &gt;&gt; S[i].x &gt;&gt; S[i].y &gt;&gt; S[i].val; &#125; sort(S, S+m, cmp); cout &lt;&lt; Kruskal(n, m) &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU3038 How Many Answers Are Wrong【并查集】]]></title>
    <url>%2F2018%2F10%2F08%2FHDU3038-%20kuangbin%E5%B8%A6%E4%BD%A0%E9%A3%9E%E3%80%90%E4%B8%93%E9%A2%98%E4%BA%94%E3%80%91%20%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[题目链接：HDU-3038kuangbin带你飞【专题五 并查集】&lt;/br&gt; 题目描述：给定一系列的区间和，可能有一部分与之前给定的冲突；如：第一步给出 1-10的区间和为100， 第二步给出7-10的区间和为20，第三步给出1-5的区间和为90(显然这是个与之前相冲突的语言，即错误！) 乍看起来挺难的，其实也挺难的（23333）。感觉是带权并查集的基础？反正就是得用到向量思维+带权并查集可以过。 &lt;/br&gt; 思路: 看这位巨巨的博客:点击学习带权并查集 需要用到向量思维 设置sum数组为当前结点到父结点的和。例如6 10 100,则设置id[6] = 10, sum[6] = 100。代表6的父结点是10，而6到10的和为100。由于A[6] + A[7] + A[8] + A[9] + A[10] = sum[10] - sum[5]，所以输入后进行处理，这样在后面的换算中可以直接得出相减得到答案。同样得，在带权并查集中，使用向量思维去求即可。【路径压缩】由于sum数组为当前结点到父结点的和，当将当前结点的父结点指向结点的爷爷结点，r的值需要从【当前结点到父结点的和】变成【当前结点到父结点的和 + 父结点到爷爷结点的和】. &lt;/br&gt; 易错点：1.输入输出有多组数据，题目并没有给出；2.在存储区间和的时候，做端点-1 ， 易于后续的计算（这里还是手动模拟一下建树容易理解）； 代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX 200010int pre[MAX], sum[MAX];void init(int n)&#123; for(int i = 0; i&lt;=n; i++) &#123; pre[i] = i; sum[i] = 0; &#125;&#125;int Find(int x)&#123; while(pre[x] != pre[pre[x]]) &#123; sum[x] = sum[x] + sum[pre[x]]; pre[x] = pre[pre[x]]; &#125; return pre[x];&#125;void Union(int x, int y, int val)&#123; int xRoot = Find(x); int yRoot = Find(y); if(xRoot != yRoot) &#123; pre[xRoot] = yRoot; sum[xRoot] = sum[y] - sum[x] + val; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n, m; while(cin &gt;&gt; n &gt;&gt; m) &#123; int ans = 0; init(n); for(int i = 0; i&lt;m; i++) &#123; int x, y, val; cin &gt;&gt; x &gt;&gt; y &gt;&gt; val; x--; if(Find(x) == Find(y)) &#123; if(sum[x] - sum[y] != val) &#123; ans++; &#125; &#125; else &#123; Union(x, y, val); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞【专题五】 并查集</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1182 食物链【并查集】]]></title>
    <url>%2F2018%2F10%2F01%2FPOJ-1182%2F</url>
    <content type="text"><![CDATA[题目链接：POJ-1182kuangbin带你飞【专题五 并查集】&lt;/br&gt; 题目描述：动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。有人用两种说法对这N个动物所构成的食物链关系进行描述：第一种说法是”1 X Y”，表示X和Y是同类。第二种说法是”2 X Y”，表示X吃Y。此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。1） 当前的话与前面的某些真的话冲突，就是假话；2） 当前的话中X或Y比N大，就是假话；3） 当前的话表示X吃X，就是假话。你的任务是根据给定的N（1 &lt;= N &lt;= 50,000）和K句话（0 &lt;= K &lt;= 100,000），输出假话的总数。 &lt;/br&gt; 思路: 好难啊， 带权并查集； 看这位巨巨的博客:点击学习带权并查集 需要用到向量思维，还是有点难呀！&lt;/br&gt; 易错点：1.需要用scanf printf输入输出， 加速的cin cout 也会TLE2.在Union操作中 指定的父节点不同 则（d-1）的规则和（1-d）的规则不同，自己手动算一下不容易出错！ 代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;#define MAX_N 50010int pre[MAX_N], val[MAX_N];void init(int n)&#123; for(int i = 1; i&lt;=n; i++) &#123; pre[i] = i; val[i] = 0; &#125;&#125;int Find(int x)&#123; while(pre[x] != pre[pre[x]]) &#123; val[x] = (val[x] + val[pre[x]]) % 3; pre[x] = pre[pre[x]]; &#125; return pre[x];&#125;void Union(int p, int q, int d)&#123; int pRoot = Find(p); int qRoot = Find(q); if(qRoot != pRoot) &#123; pre[pRoot] = qRoot; val[pRoot] = (-val[p] + (1-d) + 3 + val[q]) % 3; &#125;&#125;int main()&#123; int n, k; scanf("%d %d", &amp;n, &amp;k); init(n); int ans = 0; for(int i = 1; i&lt;=k; i++) &#123; int key, x, y; scanf("%d %d %d", &amp;key, &amp;x, &amp;y); if(x &lt;= 0 || x &gt; n || y &lt;= 0 || y &gt; n) &#123; ans++; continue; &#125; if(Find(x) == Find(y)) &#123; if(key == 1 &amp;&amp; val[x] != val[y]) ans++; if(key == 2 &amp;&amp; (val[x] + 1) % 3 != val[y]) ans++; &#125; else &#123; Union(x, y, key); &#125; &#125; printf("%d", ans); return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞【专题五】 并查集</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1611 The Suspects 【并查集】]]></title>
    <url>%2F2018%2F09%2F29%2FPOJ-1611%2F</url>
    <content type="text"><![CDATA[题目链接：POJ-1611kuangbin带你飞【专题五 并查集】&lt;/br&gt; 题目描述：有n个同学，编号为0 - n-1 ， 每次给出一定的同学为一组， 问最后和0号在一个集合的有多少人&lt;/br&gt; 思路: 合并集合的时候，把集合的大小也进行合并，就可以求出集合的人数；&lt;/br&gt; 代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;using namespace std;int pre[30010], size[30010];void init(int n)&#123; for(int i = 0; i&lt;n; i++) &#123; pre[i] = i; size[i] = 1; &#125;&#125;int Find(int x)&#123; return x == pre[x] ? x : pre[x] = Find(pre[x]);&#125;void Union(int x, int y)&#123; x = Find(x); y = Find(y); if(x != y) &#123; pre[x] = y; size[y] += size[x]; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n , m; while(cin &gt;&gt; n &gt;&gt; m, n + m) &#123; init(n); for(int i = 1; i&lt;=m; i++) &#123; int k; cin &gt;&gt; k; int key; for(int j = 1; j&lt;=k; j++) &#123; int tmp; cin &gt;&gt; tmp; if(j == 1) &#123; key = tmp; continue; &#125; else &#123; Union(key, tmp); &#125; &#125; &#125; cout&lt;&lt;size[Find(0)]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞【专题五】 并查集</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU2236 Wireless Network【并查集】]]></title>
    <url>%2F2018%2F09%2F29%2FPOJ-2236%2F</url>
    <content type="text"><![CDATA[题目链接：POJ-2236kuangbin带你飞【专题五 并查集】&lt;/br&gt; 题目描述：有一个计算机网络的所有线路都坏了，网络中有n台计算机，现在你可以做两种操作，修理（O）和检测两台计算机是否连通（S），只有修理好的计算机才能连通。连通有个规则，两台计算机的距离不能超过给定的最大距离D（一开始会给你n台计算机的坐标）。检测的时候输出两台计算机是否能连通。&lt;/br&gt; 思路: 每次修理好一台计算机的时候就遍历一下所有修好的计算机，看距离是否&lt;=D，如果符合说明可以连通，将两台计算机所在集合合并。每次检查的时候判断一下这两台计算机是否在同一集合中即可。&lt;/br&gt; 易错点：1.输出是“FAIL” 不是 “FALL”2.先判断距离是否满足，然后进行Union操作； 如果先Find根， 然后判断距离会wa掉（这样子就是错误的）。比如 ：12345678910void Union(int x, int y)&#123; x = Find(x); y = Find(y); if(x != y) &#123; if(pow(p[x].x - p[y].x, 2) + pow(p[x].y - p[y].y, 2) &lt;= d * d) p[x].pre = y; &#125;&#125; 这样就会wa掉，原因很简单分析出来！ 代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;using namespace std;#define MAX_N 1010bool vis[MAX_N];//标记vis[k], 表示标号为k电脑的电脑是否可用int n, d;struct Node&#123; int x, y; int pre;//pre 代表祖宗&#125;p[MAX_N];void init(int n)&#123; for(int i = 1; i&lt;=n; i++) p[i].pre = i;&#125;int Find(int x)&#123; return x == p[x].pre ? x : p[x].pre = Find(p[x].pre);//路径压缩&#125;void Union(int x, int y)&#123; x = Find(x); y = Find(y); if(x != y) &#123; p[x].pre = y; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; d; init(n); for(int i = 1; i&lt;=n; i++) &#123; cin &gt;&gt; p[i].x &gt;&gt; p[i].y; &#125; memset(vis, 0, sizeof(vis)); string s; while(cin &gt;&gt; s) &#123; if(s == "O") &#123; int k; cin &gt;&gt; k; vis[k] = 1;//标记可用 for(int i = 1; i&lt;=n; i++)//如果之前有可用 而且距离合适 则进行合并 &#123; if(vis[i] &amp;&amp; i != k &amp;&amp; pow(p[i].x - p[k].x, 2) + pow(p[i].y - p[k].y, 2) &lt;= d * d) &#123; Union(i, k); &#125; &#125; &#125; else &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; if(Find(x) == Find(y))//判断是否是同一个集合 &#123; cout&lt;&lt;"SUCCESS"&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;"FAIL"&lt;&lt;endl; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞【专题五】 并查集</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1213 How Many Tables【并查集】]]></title>
    <url>%2F2018%2F09%2F28%2FHDU1213%2F</url>
    <content type="text"><![CDATA[题目链接：HDU1213kuangbin带你飞【专题五 并查集】&lt;/br&gt; 题目描述：有n个人，通过合并操作，问最后有多少个不同的集合; &lt;/br&gt; 思路:并查集的基操， 用set维护一下已经出现的祖宗节点，当出现的祖宗没有在set中保存，则其为一个新的集合，ans++即可。最后输出ans即可！&lt;/br&gt; 代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/************************************************************************* &gt; File Name: main.cpp &gt; Author: Hang_cc &gt; Mail: 545192053.com &gt; Created Time: Fri 28 Sep 2018 02:33:52 PM PDT ************************************************************************/#include&lt;bits/stdc++.h&gt;using namespace std;int pre[1010];void init(int n)&#123; for(int i = 1; i&lt;=n; i++) pre[i] = i;&#125;int Find(int x)&#123; return x == pre[x] ? x : pre[x] = Find(pre[x]);&#125;void Union(int x, int y)&#123; x = Find(x); y = Find(y); if(x != y) &#123; pre[x] = y; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int T; cin &gt;&gt; T; while(T--) &#123; int ans = 0; int n, m; cin &gt;&gt; n &gt;&gt; m; init(n); for(int i = 1; i&lt;=m; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; Union(x, y); &#125; set&lt;int&gt; S; for(int i = 1; i&lt;=n; i++) &#123; if(S.find(Find(i)) == S.end()) &#123; //cout&lt;&lt;"i = "&lt;&lt;i&lt;&lt; "pre = "&lt;&lt;pre[i]&lt;&lt;endl; ans++; S.insert(pre[i]); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>kuangbin带你飞【专题五】 并查集</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用IPV6免费上网]]></title>
    <url>%2F2018%2F09%2F24%2F%E3%80%90%E6%A0%A1%E5%9B%AD%E7%BD%91%E4%BD%BF%E7%94%A8ipv6%E5%85%8D%E6%B5%81%E3%80%91%2F</url>
    <content type="text"><![CDATA[【校园网使用ipv6免流】一、IPv6介绍 百度上说IPv6是IETF设计的用于替代现行版本IP协议（IPv4）的下一代IP协议，号称可以为全世界的每一粒沙子编上一个网址。太多的废话就不多说了，反正IPv6就是新的用来取代IPv4的协议，如果还想具体了解的话可能百度谷歌更好一点。好处：大多高校都是iPv4拦截，让你购买相关的上网账号进行上网，而对IPv6不进行拦截，而且IPv6是免费的，所以我们可以利用这一点进行免费使用网络，并且网速比ipv4更加优秀！ 二、环境监测 电脑连上学校的WIFI或者连上网线皆可以(注意！别登陆，别登陆关于认证的东西！)。然后打开“网络与Internet设置” 打开“查看网络信息并设置连接”这一栏，点击查看网络状态和任务， 查看是否开启了IPv6,像我这样就是支持IPv6的， 如果你的计算机在IPv6那一栏显示“无网络访问权限”，你可以打开属性， 在IPv6勾一下，然后点击确定， 点击禁用，然后启用(启用在更改适配器选项里面)，看看是不是已经支持IPv6了！ OK，我们按住win + r 打开快速启动程序窗口， 然后输入 ping ipv6.baidu.com 看看是不是显示像我这样的！如果是，恭喜你，可以使用这个免费的资源。如果不是的话， 请你默默的关了这个网页233333333333 三、已经可以成功上网了 这里我给出一些网址供大家玩耍！ 1、谷歌（优秀的搜索引擎）: 点击访问 2、YouTube（国外的视屏网站): 点击访问 3、清华大学IPTV（电视直播网站，亲测丝毫不卡！）点击访问 4、百度？(百度直供娱乐)：点击访问 四、题外话 自己想做个利用IPv6的特性，写一个播放器，差不多就是把各个直播资源整合到一块吧，这样用起来不是美滋滋，有想法及技术的同学私我啊！！]]></content>
      <categories>
        <category>校园网</category>
      </categories>
      <tags>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绕过web认证,实现免流上网]]></title>
    <url>%2F2018%2F09%2F22%2F%E7%BB%95%E8%BF%87web%E8%AE%A4%E8%AF%81%2C%E5%AE%9E%E7%8E%B0%E5%85%8D%E6%B5%81%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[声明：本教程只做学习交流，切勿用于商业用途！本文并不是原创，增加了自己的搭建经验和对原教程的更加细化的描述参考博客：https://blog.csdn.net/qq_37371161/article/details/78150628https://www.bennythink.com/softether-vpnserver.html SoftEther VPN Server安装手记+福利 作者：Benny小土豆https://www.bennythink.com/udp53.html UDP 53免费上网、DNS隧道经验谈 作者：Benny小土豆http://blog.aizhet.com/Linux/14873.html 作者未知 一、原理简介： 在连接到某个需要 Web 认证的热点之前，我们已经获得了一个内网 IP，此时，如果我们访问某个 HTTP 网站，网关会对这个 HTTP 响应报文劫持并篡改，302 重定向给我们一个 web 认证界面（所以点 HTTPS 的网站是不可能跳转到 web 认证页面的）。详细原理可以点击这里 我们看到了，网关（或者说交换机）都默认放行 DHCP 和 DNS 报文，也就是 UDP53 与 UDP 67。有些网关甚至不会报文进行检查，这也就意味着任何形式的数据包都可以顺畅通过。 既然如此，我们就可以在公网搞一台服务器，然后借此来免费上网，顺便还能防止网络审计——再一次画了删除线的 “免费”，其实只是把钱花在服务器上了。我们这次免费上网的主要突破点就是 UDP 53。 二、环境检测 本文的主要针对的目标是在校大学生，且认证方式包括但不限于web认证的群体！例如，本校的校园网连接后就会弹出登陆验证页面。 OK，如何进行环境检测？连上校园网，不要登陆， win+r 打开快速启动程序 输入 cmd， 点击确定。 然后输入以下内容 nslookup www.baidu.com 这是我得到的结果： 我们可以的看到， 在没有进行web认证的情况下，我们成功的得到了百度的ip地址。 所以可以确定我们学校是对UDP53端口不拦截的， 我们可以进行下一步操作！ 如果你测试的结果并没有得到百度的ip地址，那就可以关了此页面了（当然，你可以关注我一下，下一期可能会出ipv6的免流教程）。如果你可以顺利得到百度的ip，那么恭喜你，可以进行接下来的操作！ 三、服务器的购买与配置因为大家的水平残次不齐，所以以腾讯云为例；点击这里进入腾讯云，进入腾讯云，大家可以绑定一下自己的学生身份，每个月有便宜的服务器使用！然后我们进入学生专区点击进入学生专区，我们选择云服务器体验套餐 一个月10块钱，我的买过了，所以界面可能不太一样， 大家网络配置默认即可， 系统镜像选择Ubuntu16.04（64位） 14.04（64位）即可， ssh密匙就是你登录服务器的密码，根据自身设置。 下面是我创建好的服务器。 Xshell6下载：点击下载 然后我们用XShell连接到我们的服务器，我们打开Xshell我们点文件， 新建， 名称随意写， 主机写你的服务器的公网ip； 然后点击用户身份认证，用户名填入ubuntu， 密码填入你刚才设置的ssh密匙； 然后点击连接， 在弹出的对话框选择一次性接受并保存， 这时即可连接到我们的服务器！ 四、服务器配置SoftEther VPN对于没有学过linux的同学，可能比较难于理解。没关系，我将用最简单的方式让你成功搭建，你只需要复制粘贴即可； 接下来的步骤， 你只需要将我写出的命令依次复制即可， 大家复制的时候可以选择右键复制， 或者shift + ins进行复制， ctrl + v是复制不了的。 ①下载SoftEther VPN wget -e -robots=off http://files.mawenjian.net/SoftEtherVPN/softether-vpnserver-v4.10-9473-beta-2014.07.12-linux-x64-64bit.tar.gz ②解压 tar -zxvf softether-vpnserver-v4.10-9473-beta-2014.07.12-linux-x64-64bit.tar.gz ③安装 cd vpnserver ./.install.sh 期间连续输入三个“1”。 ④启动 ./vpnserver start ⑤ ./vpncmd 分别输入：“1” “回车” “回车”。提示符变为“VPN Server”时输入： ServerPasswordSet 输入你想设置的服务器管理密码即可。 六、 SotfEther VPN Sever 的配置SotfEther VPN Sever下载：点击下载 运行 SotfEther VPN Sever ， 点击新设置 依次输入’设置名’ ‘主机名’ 和 ‘密码’，点击确定。 打开你设置的服务器，首次连接需要输入服务器的管理员密码，然后在弹出的”SoftEther VPN Server/Bridge 简单安装”面板中，选择“VPN的其他高级配置”。 也就是最下面的那一项 依次选择“管理虚拟HUB”–&gt;“管理用户”–&gt;“新建” 按图片内容设置即可。 注意，监听端口一定要写53！ 然后点确定解压ZIP文件，找出“vm-245-240-ubunt_openvpn_remote_access_l3.ovpn”，以记事本方式打开，找到图中位置，修改对应信息，保存即可。 七、客户端配置OpenVPNOpenVPN下载：点击下载 下载并安装（推荐安装在默认目录）将“vm-245-240-ubunt_openvpn_remote_access_l3.ovpn”复制到OpenVPN目录下的“config”文件夹内。 八、连接运行bin目录下的“openvpn-gui.exe”。此时电脑右下角托盘多了一个openvpn的图标。右键-&gt;vm-245-240-ubunt_openvpn_remote_access_l3.ovpn-&gt;connect 输入刚刚设置的用户名密码即可。 等这个图标变绿，这时候我们就连到网络了， 当然，这个方法手机也可以用！包括你搭建国外服务器，那就可以自带梯子，访问YouTube，google等网站！ 显然，偷渡的网络与服务器的带宽有关，土豪们 可以通过都买服务器带宽以提高接入速度。推荐购买服务器：如果没有fq需求，买国内的阿里云，腾讯云即可。国外的推荐vultr的洛杉矶。搬瓦工的cn2.OK！到这里就结束了， 有问题欢迎大家留言，有时间一定帮大家解决！]]></content>
      <categories>
        <category>校园网</category>
      </categories>
      <tags>
        <tag>破解</tag>
      </tags>
  </entry>
</search>
