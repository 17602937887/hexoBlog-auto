---
title:  Java中关于volatile的理解
date: 2020年9月29日
tags:  面试

---

![在这里插入图片描述](/image/刺客伍六七/3.jpeg)
<escape><!-- more --></escape>
# 基本概念
　　由于计算机的存储设备与运算速度之间有着几个数量级的差距，所以现在的计算机系统都会加入一层或多层的高速缓存(Cache)来作为内存与处理器之间的缓冲。将运算使用的数据复制到高速缓存中，尽可能让处理器处于计算运行状态，而不在等待io、网络等其他资源上。当运算结束后再将缓存同步到内存中，这样处理器就不需要等待缓慢的内存读写了。
　　基于高速缓存的存储交互很好的解决了处理器与内存速度之间的差距。但同时也引入了一个新的问题：**缓存一致性**。在多核心处理器系统中，每个处理器都有自己的高速缓存，而他们又共享着内存。在这种系统中，**当多个处理器的运算任务都涉及从高速缓存写入共享内存操作时**，那么究竟该以哪一个处理器为准呢？
  ![在这里插入图片描述](/image/Java中关于volatile的理解/1.png)
  为了解决一致性的问题，处理器访问缓存时都遵循一些协议，在读写时要根据协议来操作，这类协议有**MSI，MESI,MOSI等**。
　　除此之外，为了使得处理器内部的运算单元尽可能被充分利用，处理器可能会对输入代码进行乱序执行优化，处理器会在计算之后将乱执行的结果重组，保证结果与顺序执行的结果是一致的，但并不保证程序中的各个语句计算的先后顺序与输入代码中的顺序一致，因此如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有**指令重排序优化**
 
 # Java内存模型（JMM
 　　定义Java内存模型是为了屏蔽各种硬件与操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。
  　　Java内存模型主要是定义程序中变量的访问规则，即在虚拟机中将变量存储到主内存或者将变量从主内存取出等这样的底层细节。**这里的变量是指`实例字段、静态字段、构成数组对象的元素`**，但不包括局部变量和方法参数等。可以简单地认为对于Java虚拟机而言，堆空间是共享的，所以在堆空间上存储的变量可能会涉及到多线程并行操作，而Java虚拟机栈是线程私有的，里面存储的变量就不会涉及到共享访问。
## 主内存
 　　Java内存模型规定了所有的变量都存储在主内存中（物理上还是虚拟机内存的一部分），可以简单的认为其就是堆区。
## 工作内存
 　　每条线程还有自己的工作内存（类比上文提到的高速缓存），线程的工作内存中保存了该线程使用的变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在**工作内存**中进行，而**不能**直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间变量值的传递**均需要通过主内存来完成**，线程、主内存、工作内存三者之间的交互关系如图所示
![在这里插入图片描述](/image/Java中关于volatile的理解/2.png)
## 与Java内存区域的区别
 　　这里所说的`主内存、工作内存`与Java内存区域中的`Java堆、栈、方法区`等并不是一个层次的划分。**这两者基本上是没有任何关系的**。如果一定要勉强对应起来，那么从变量、主内存、工作内存的定义来看，**主内存主要对应于Java堆中的对象实例数据部分**，而工作内存则对应于虚拟机栈中的部分区域。
   
 ## 内存间交互操作
 　　关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从
工作内存同步回主内存这一类的实现细节，Java内存模型中定义了以下8种操作来完成。Java虚拟机实
现时必须保证下面提及的每一种操作都是**原子的、不可再分的**
+ `lock`（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
+ `unlock`（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量
才可以被其他线程锁定。
+ `read`（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以
便随后的load动作使用。
+ `load`（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的
变量副本中。
+ `use`（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚
拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
+ `assign`（赋值）：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，
每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
+ `store`（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随
后的write操作使用。
+ `write`（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的
变量中

 　　如果要把一个变量从**主内存**拷贝到**工作内存**，那就要按**顺序执行read和load操作**，如果要把变量从**工作内存**同步回**主内存**，就要**按顺序执行store和write操作**。注意，Java内存模型只要求上述两个操作必须按顺序执行，但不要求是连续执行。也就是说read与load之间、store与write之间是可插入其他指令的，如对主内存中的变量a、b进行访问时，一种可能出现的顺序是read a、read b、load b、load a。除此之外，Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：
   
+ 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内
存不接受，或者工作内存发起回写了但主内存不接受的情况出现。
+ 不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回
主内存。
+ 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存
中。
+ 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或
assign）的变量，换句话说就是对一个变量实施use、store操作之前，必须先执行assign和load操作。
+ 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执
行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。
+ 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量
前，需要重新执行load或assign操作以初始化变量的值。
+ 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个
被其他线程锁定的变量。
+ 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。

## volatile
 　　volatile关键字是Java虚拟机提供的最轻量级的同步机制。
 　　当一个变量被定义为volatile之后，其将具备两个特性
### 保证此变量对所有的线程的可见性。
 　　具体是指当一条线程修改了这个变量，新值对于其他线程来说是可以立即得知的。而普通的变量并不能做到这一点，普通变量的值在线程间传递时需要通过主内存来完成。
比如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再对
主内存进行读取操作，新变量值才会对线程B可见。**但是并不是说加volatile关键字就可以保证原子性**
 　　由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized、java.util.concurrent中的锁或原子类）来保证原子性：
+ 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
+ 变量不需要与其他的状态变量共同参与不变约束。 
### 禁止指令重排序优化
 　　普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。
   volatile修饰的变量，会在指令层面添加内存屏障。